import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/react-basics/react-features-versions-版本特性.md",collection="posts",slug="front-end-frameworks/react/react-basics/react-features-versions-版本特性",body="\n# React Features & Versions-版本特性\n## React vs. JS\n\n### JS\n\n- Imperative\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516791954image.png)\n\n### React\n\n- Declarative\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516813982image.png)\n\n## [[front-end-frameworks/react/react-mini-app/filterable-product-table]]\n\n## Questions\n\n## 组件化开发概念\n\n- 分而治之思想，便于扩展与维护，以及代码复用\n- 组件 > 组件树 （应用）\n\n## Feature\n#### [使用 React 写一个 todo 应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n\n#### [经常用 React，你知道 React 的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n\n- [[front-end-frameworks/react/react-basics/pure-function-component-纯函数组件|Pure-Function-Component-纯函数组件]]\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React 是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [说说你对“在 React 中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [React 与 angular、vue 有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n\n#### [说说你喜欢 React 的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n\n- [你最喜欢 React 的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [你最不喜欢 React 的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n\n#### [在使用 React 过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n\n#### [你觉得 React 上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n\n#### [React 如何进行代码拆分？拆分的原则是什么？](https://github.com/haizlin/fe-interview/issues/931)\n\n## Version\n\n#### [从旧版本的 React 升级到新版本的 React 有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n\n#### [你用过 React 版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n\n#### React 16.x\n\n1）React 16.x 的三大新特性 Time Slicing, Suspense，hooks\n\n- 1. Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能\n- 2. Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式\n- 3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。  \n     2）React16.8\n- 加入 hooks，让 React 函数式组件更加灵活\n- hooks 之前，React 存在很多问题\n  - 1. 在组件间复用状态逻辑很难\n  - 2. 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n  - 3. class 组件的 this 指向问题\n  - 4. 难以记忆的生命周期\n- hooks 很好的解决了上述问题，hooks 提供了很多方法\n  - 1. useState 返回有状态值，以及更新这个状态值的函数\n  - 2. useEffect 接受包含命令式，可能有副作用代码的函数。\n  - 3. useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，\n  - 4. useReducer useState 的替代方案。接受类型为(state，action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。\n  - 5. useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性\n  - 6. useMemo 纯的一个记忆函数\n  - 7. useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\n  - 8. useImperativeMethods 自定义使用 ref 时公开给父组件的实例值\n  - 9. useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发\n  - 10. useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染  \n        3）React16.9\n- 1. 重命名 Unsafe 的生命周期方法。新的 UNSAFE\\_ 前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n- 2. 废弃 javascript: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。\n- 3. 废弃 “Factory” 组件。 工厂组件会导致 React 变大且变慢。\n- 4. act() 也支持异步函数，并且你可以在调用它时使用 await。\n- 5. 使用 <React.Profiler> 进行性能评估。 在较大的应用中追踪性能回归可能会很方便  \n     4）React16.13.0\n- 1. 支持在渲染期间调用 setState，但仅适用于同一组件\n- 2. 可检测冲突的样式规则并记录警告\n- 3. 废弃 unstable_createPortal，使用 createPortal\n- 4. 将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n\n\n\n\n",data={title:"React Features & Versions-版本特性",DateStarted:new Date(17096832e5),tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-basics/react-features-versions-版本特性.md",rawData:void 0},html='<h1 id="react-features--versions-版本特性">React Features &#x26; Versions-版本特性<a class="anchor" href="#react-features--versions-版本特性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="react-vs-js">React vs. JS<a class="anchor" href="#react-vs-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="js">JS<a class="anchor" href="#js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>Imperative\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516791954image.png" alt=""></li>\n</ul>\n</li>\n</ul>\n<h3 id="react">React<a class="anchor" href="#react"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>Declarative\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516813982image.png" alt=""></li>\n</ul>\n</li>\n</ul>\n<h2 id="front-end-frameworksreactreact-mini-appfilterable-product-table">[[front-end-frameworks/react/react-mini-app/filterable-product-table]]<a class="anchor" href="#front-end-frameworksreactreact-mini-appfilterable-product-table"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="组件化开发概念">组件化开发概念<a class="anchor" href="#组件化开发概念"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>分而治之思想，便于扩展与维护，以及代码复用</li>\n<li>组件 > 组件树 （应用）</li>\n</ul>\n<h2 id="feature">Feature<a class="anchor" href="#feature"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="使用-react-写一个-todo-应用说说你的思路"><a href="https://github.com/haizlin/fe-interview/issues/712">使用 React 写一个 todo 应用，说说你的思路</a><a class="anchor" href="#使用-react-写一个-todo-应用说说你的思路"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="经常用-react你知道-react-的核心思想是什么吗"><a href="https://github.com/haizlin/fe-interview/issues/811">经常用 React，你知道 React 的核心思想是什么吗？</a><a class="anchor" href="#经常用-react你知道-react-的核心思想是什么吗"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>[[front-end-frameworks/react/react-basics/pure-function-component-纯函数组件|Pure-Function-Component-纯函数组件]]</li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/615">说说你对声明式编程的理解？</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/612">React 是什么？它的主要特点是什么？</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/626">说说你对“在 React 中，一切都是组件”的理解</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/614">React 与 angular、vue 有什么区别？</a></li>\n</ul>\n<h4 id="说说你喜欢-react-的原因是什么它有什么优缺点"><a href="https://github.com/haizlin/fe-interview/issues/622">说说你喜欢 React 的原因是什么？它有什么优缺点？</a><a class="anchor" href="#说说你喜欢-react-的原因是什么它有什么优缺点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><a href="https://github.com/haizlin/fe-interview/issues/873">你最喜欢 React 的哪一个特性（说一个就好）？</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/871">你最不喜欢 React 的哪一个特性（说一个就好）？</a></li>\n</ul>\n<h4 id="在使用-react-过程中你都踩过哪些坑你是怎么填坑的"><a href="https://github.com/haizlin/fe-interview/issues/623">在使用 React 过程中你都踩过哪些坑？你是怎么填坑的？</a><a class="anchor" href="#在使用-react-过程中你都踩过哪些坑你是怎么填坑的"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="你觉得-react-上手快不快它有哪些限制"><a href="https://github.com/haizlin/fe-interview/issues/616">你觉得 React 上手快不快？它有哪些限制？</a><a class="anchor" href="#你觉得-react-上手快不快它有哪些限制"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-如何进行代码拆分拆分的原则是什么"><a href="https://github.com/haizlin/fe-interview/issues/931">React 如何进行代码拆分？拆分的原则是什么？</a><a class="anchor" href="#react-如何进行代码拆分拆分的原则是什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h2 id="version">Version<a class="anchor" href="#version"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="从旧版本的-react-升级到新版本的-react-有做过吗有遇到过什么坑"><a href="https://github.com/haizlin/fe-interview/issues/667">从旧版本的 React 升级到新版本的 React 有做过吗？有遇到过什么坑？</a><a class="anchor" href="#从旧版本的-react-升级到新版本的-react-有做过吗有遇到过什么坑"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="你用过-react-版本有哪些"><a href="https://github.com/haizlin/fe-interview/issues/666">你用过 React 版本有哪些？</a><a class="anchor" href="#你用过-react-版本有哪些"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-16x">React 16.x<a class="anchor" href="#react-16x"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>1）React 16.x 的三大新特性 Time Slicing, Suspense，hooks</p>\n<ul>\n<li>\n<ol>\n<li>Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。<br>\n2）React16.8</li>\n</ol>\n</li>\n<li>加入 hooks，让 React 函数式组件更加灵活</li>\n<li>hooks 之前，React 存在很多问题\n<ul>\n<li>\n<ol>\n<li>在组件间复用状态逻辑很难</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>class 组件的 this 指向问题</li>\n</ol>\n</li>\n<li>\n<ol start="4">\n<li>难以记忆的生命周期</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>hooks 很好的解决了上述问题，hooks 提供了很多方法\n<ul>\n<li>\n<ol>\n<li>useState 返回有状态值，以及更新这个状态值的函数</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>useEffect 接受包含命令式，可能有副作用代码的函数。</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，</li>\n</ol>\n</li>\n<li>\n<ol start="4">\n<li>useReducer useState 的替代方案。接受类型为(state，action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。</li>\n</ol>\n</li>\n<li>\n<ol start="5">\n<li>useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性</li>\n</ol>\n</li>\n<li>\n<ol start="6">\n<li>useMemo 纯的一个记忆函数</li>\n</ol>\n</li>\n<li>\n<ol start="7">\n<li>useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。</li>\n</ol>\n</li>\n<li>\n<ol start="8">\n<li>useImperativeMethods 自定义使用 ref 时公开给父组件的实例值</li>\n</ol>\n</li>\n<li>\n<ol start="9">\n<li>useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发</li>\n</ol>\n</li>\n<li>\n<ol start="10">\n<li>useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染<br>\n3）React16.9</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<ol>\n<li>重命名 Unsafe 的生命周期方法。新的 UNSAFE_ 前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>废弃 javascript: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>废弃 “Factory” 组件。 工厂组件会导致 React 变大且变慢。</li>\n</ol>\n</li>\n<li>\n<ol start="4">\n<li>act() 也支持异步函数，并且你可以在调用它时使用 await。</li>\n</ol>\n</li>\n<li>\n<ol start="5">\n<li>使用 &#x3C;React.Profiler> 进行性能评估。 在较大的应用中追踪性能回归可能会很方便<br>\n4）React16.13.0</li>\n</ol>\n</li>\n<li>\n<ol>\n<li>支持在渲染期间调用 setState，但仅适用于同一组件</li>\n</ol>\n</li>\n<li>\n<ol start="2">\n<li>可检测冲突的样式规则并记录警告</li>\n</ol>\n</li>\n<li>\n<ol start="3">\n<li>废弃 unstable_createPortal，使用 createPortal</li>\n</ol>\n</li>\n<li>\n<ol start="4">\n<li>将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。</li>\n</ol>\n</li>\n</ul>',frontmatter={title:"React Features & Versions-版本特性",topic:["Component-Basics"],type:"D",reviewed:1,difficulty:null,comment:null,tags:["React"],DateStarted:"2024-03-06T00:00:00.000Z",DateModified:"2024-09-14T00:00:00.000Z",Datereviewed:"2024-04-12T00:00:00.000Z",status:null,aliases:["React Features & Versions-版本特性"],"linter-yaml-title-alias":"React Features & Versions-版本特性",category:"Front-End Frameworks",minutes:6,words:1108},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-basics/react-features-versions-版本特性.md",url=void 0;function rawContent(){return"\n# React Features & Versions-版本特性\n## React vs. JS\n\n### JS\n\n- Imperative\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516791954image.png)\n\n### React\n\n- Declarative\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Paste-image-1701516813982image.png)\n\n## [[front-end-frameworks/react/react-mini-app/filterable-product-table]]\n\n## Questions\n\n## 组件化开发概念\n\n- 分而治之思想，便于扩展与维护，以及代码复用\n- 组件 > 组件树 （应用）\n\n## Feature\n#### [使用 React 写一个 todo 应用，说说你的思路](https://github.com/haizlin/fe-interview/issues/712)\n\n#### [经常用 React，你知道 React 的核心思想是什么吗？](https://github.com/haizlin/fe-interview/issues/811)\n\n- [[front-end-frameworks/react/react-basics/pure-function-component-纯函数组件|Pure-Function-Component-纯函数组件]]\n- [说说你对声明式编程的理解？](https://github.com/haizlin/fe-interview/issues/615)\n- [React 是什么？它的主要特点是什么？](https://github.com/haizlin/fe-interview/issues/612)\n- [说说你对“在 React 中，一切都是组件”的理解](https://github.com/haizlin/fe-interview/issues/626)\n- [React 与 angular、vue 有什么区别？](https://github.com/haizlin/fe-interview/issues/614)\n\n#### [说说你喜欢 React 的原因是什么？它有什么优缺点？](https://github.com/haizlin/fe-interview/issues/622)\n\n- [你最喜欢 React 的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/873)\n- [你最不喜欢 React 的哪一个特性（说一个就好）？](https://github.com/haizlin/fe-interview/issues/871)\n\n#### [在使用 React 过程中你都踩过哪些坑？你是怎么填坑的？](https://github.com/haizlin/fe-interview/issues/623)\n\n#### [你觉得 React 上手快不快？它有哪些限制？](https://github.com/haizlin/fe-interview/issues/616)\n\n#### [React 如何进行代码拆分？拆分的原则是什么？](https://github.com/haizlin/fe-interview/issues/931)\n\n## Version\n\n#### [从旧版本的 React 升级到新版本的 React 有做过吗？有遇到过什么坑？](https://github.com/haizlin/fe-interview/issues/667)\n\n#### [你用过 React 版本有哪些？](https://github.com/haizlin/fe-interview/issues/666)\n\n#### React 16.x\n\n1）React 16.x 的三大新特性 Time Slicing, Suspense，hooks\n\n- 1. Time Slicing（解决 CPU 速度问题）使得在执行任务的期间可以随时暂停，跑去干别的事情，这个特性使得 react 能在性能极其差的机器跑时，仍然保持有良好的性能\n- 2. Suspense （解决网络 IO 问题）和 lazy 配合，实现异步加载组件。 能暂停当前组件的渲染, 当完成某件事以后再继续渲染，解决从 react 出生到现在都存在的「异步副作用」的问题，而且解决得非常的优雅，使用的是「异步但是同步的写法」，我个人认为，这是最好的解决异步问题的方式\n- 3. 此外，还提供了一个内置函数 componentDidCatch，当有错误发生时, 我们可以友好地展示 fallback 组件；可以捕捉到它的子元素（包括嵌套子元素）抛出的异常；可以复用错误组件。  \n     2）React16.8\n- 加入 hooks，让 React 函数式组件更加灵活\n- hooks 之前，React 存在很多问题\n  - 1. 在组件间复用状态逻辑很难\n  - 2. 复杂组件变得难以理解，高阶组件和函数组件的嵌套过深。\n  - 3. class 组件的 this 指向问题\n  - 4. 难以记忆的生命周期\n- hooks 很好的解决了上述问题，hooks 提供了很多方法\n  - 1. useState 返回有状态值，以及更新这个状态值的函数\n  - 2. useEffect 接受包含命令式，可能有副作用代码的函数。\n  - 3. useContext 接受上下文对象（从 React.createContext 返回的值）并返回当前上下文值，\n  - 4. useReducer useState 的替代方案。接受类型为(state，action) => newState 的 reducer，并返回与 dispatch 方法配对的当前状态。\n  - 5. useCallback 返回一个回忆的 memoized 版本，该版本仅在其中一个输入发生更改时才会更改。纯函数的输入输出确定性\n  - 6. useMemo 纯的一个记忆函数\n  - 7. useRef 返回一个可变的 ref 对象，其.current 属性被初始化为传递的参数，返回的 ref 对象在组件的整个生命周期内保持不变。\n  - 8. useImperativeMethods 自定义使用 ref 时公开给父组件的实例值\n  - 9. useMutationEffect 更新兄弟组件之前，它在 React 执行其 DOM 改变的同一阶段同步触发\n  - 10. useLayoutEffect DOM 改变后同步触发。使用它来从 DOM 读取布局并同步重新渲染  \n        3）React16.9\n- 1. 重命名 Unsafe 的生命周期方法。新的 UNSAFE\\_ 前缀将有助于在代码 review 和 debug 期间，使这些有问题的字样更突出\n- 2. 废弃 javascript: 形式的 URL。以 javascript: 开头的 URL 非常容易遭受攻击，造成安全漏洞。\n- 3. 废弃 “Factory” 组件。 工厂组件会导致 React 变大且变慢。\n- 4. act() 也支持异步函数，并且你可以在调用它时使用 await。\n- 5. 使用 <React.Profiler> 进行性能评估。 在较大的应用中追踪性能回归可能会很方便  \n     4）React16.13.0\n- 1. 支持在渲染期间调用 setState，但仅适用于同一组件\n- 2. 可检测冲突的样式规则并记录警告\n- 3. 废弃 unstable_createPortal，使用 createPortal\n- 4. 将组件堆栈添加到其开发警告中，使开发人员能够隔离 bug 并调试其程序，这可以清楚地说明问题所在，并更快地定位和修复错误。\n\n\n\n\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"react-features--versions-版本特性",text:"React Features & Versions-版本特性#"},{depth:2,slug:"react-vs-js",text:"React vs. JS#"},{depth:3,slug:"js",text:"JS#"},{depth:3,slug:"react",text:"React#"},{depth:2,slug:"front-end-frameworksreactreact-mini-appfilterable-product-table",text:"[[front-end-frameworks/react/react-mini-app/filterable-product-table]]#"},{depth:2,slug:"questions",text:"Questions#"},{depth:2,slug:"组件化开发概念",text:"组件化开发概念#"},{depth:2,slug:"feature",text:"Feature#"},{depth:4,slug:"使用-react-写一个-todo-应用说说你的思路",text:"使用 React 写一个 todo 应用，说说你的思路#"},{depth:4,slug:"经常用-react你知道-react-的核心思想是什么吗",text:"经常用 React，你知道 React 的核心思想是什么吗？#"},{depth:4,slug:"说说你喜欢-react-的原因是什么它有什么优缺点",text:"说说你喜欢 React 的原因是什么？它有什么优缺点？#"},{depth:4,slug:"在使用-react-过程中你都踩过哪些坑你是怎么填坑的",text:"在使用 React 过程中你都踩过哪些坑？你是怎么填坑的？#"},{depth:4,slug:"你觉得-react-上手快不快它有哪些限制",text:"你觉得 React 上手快不快？它有哪些限制？#"},{depth:4,slug:"react-如何进行代码拆分拆分的原则是什么",text:"React 如何进行代码拆分？拆分的原则是什么？#"},{depth:2,slug:"version",text:"Version#"},{depth:4,slug:"从旧版本的-react-升级到新版本的-react-有做过吗有遇到过什么坑",text:"从旧版本的 React 升级到新版本的 React 有做过吗？有遇到过什么坑？#"},{depth:4,slug:"你用过-react-版本有哪些",text:"你用过 React 版本有哪些？#"},{depth:4,slug:"react-16x",text:"React 16.x#"}]}const Content=createComponent(((e,n,t)=>{const{layout:a,...i}=frontmatter;return i.file=file,i.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),reactFeaturesVersions_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,reactFeaturesVersions_____,slug};