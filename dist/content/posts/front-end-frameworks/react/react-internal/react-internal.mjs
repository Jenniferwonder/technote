import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726310608649/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/react-internal/react-internal.md",collection="posts",slug="front-end-frameworks/react/react-internal/react-internal",body="\n# React Internal\n\n[juejin.cn/post/7329780589061095434](https://juejin.cn/post/7329780589061095434)\n\n## Reverse Engineering\n\n[in Depth-level-up-your-reverse-engineering-skills](https://angularindepth.com/posts/1005/level-up-your-reverse-engineering-skills)  \n[in Depth-practical-application-of-reverse-engineering-guidelines-and-principles](https://angularindepth.com/posts/1006/practical-application-of-reverse-engineering-guidelines-and-principles)\n\n## Fiber\n\n[Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 - YouTube](https://www.youtube.com/watch?v=ZCuYPiUIONs)\n[GitHub - acdlite/react-fiber-architecture: A description of React's new core algorithm, React Fiber](https://github.com/acdlite/react-fiber-architecture?source=post_page---------------------------) (Notes by Andrew Clark)\n\n### What is Fiber\n\nFiber 实际上是对 React 虚拟 DOM 的每个节点的重新实现。每个 Fiber 节点代表一个工作单元，它对应一个 React 元素、组件实例或 DOM 节点。这个新的结构是个单链表的形式，允许 React 在执行中逐节点遍历和操作。\n每个 Fiber 节点都有自己的内部状态和对其他 Fiber 节点的引用（例如，对子节点、父节点、兄弟节点的引用），以及对实际 DOM 节点的引用（如果有的话）。React 可以独立地更新这些 Fiber 节点，这是 Fiber 架构的核心优势，它允许**任务分割和中断**工作。为未来的 React 特性和优化提供了基础，包括**异步渲染和并发模式（Concurrent Mode）**，这些都是 React 应用未来性能提升的关键方面。\n\n#### Why this name \"Fiber\"\n\nA fiber represents a **unit of work**\n Fiber is reimplementation of the stack, specialized for React components.\n You can think of a single fiber as a **virtual stack frame**\nIn order to use new Browser APIs ([Time-Slicing](react-internal%201.md#^u64q5e)) for scheduling update:\n\n- need a way to break rendering work into incremental units. If you rely only on the call stack, it will keep doing work until the stack is empty\n  So that we can\n- customize the behavior of the **call stack** to optimize for rendering UIs\n- interrupt the call stack at will and manipulate stack frames manually\n- can [keep stack frames in memory](https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/) and execute them however (and *whenever*) you want\n- potential for features such as concurrency and error boundaries\n\n#### Reconciliation\n\n一种新的调和算法 (Reconciliation algorithm), reimplementation of React's core algorithm\nthe algorithm React uses to **diff** one tree with another to determine which parts need to be changed\nthe culmination of over two years of research by the React team\n\n#### Data Structure (List & Tree)\n\na plain JS object that\n\n- contains information about a component, its input, and its output\n- corresponds to a stack frame, but it also corresponds to an instance of a component\n- has an 1-to-1 relationship with a component instance (to manage work for an instance)\n\n```js\nconst fiber = {\n  stateNode // To manage its instance\n  child\n  return\n  sibling\n}\n```\n\n![image.png|275](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151445079.png)\n\n##### Important fields of a fiber\n\n| Fields                                                                                                        | For                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `type` & `key`                                                                                                | The type and key of a fiber serve the same purpose as they do for React elements. (In fact, when a fiber is created from an element, these two fields are copied over directly.)<br>The `type` describes the component that it corresponds to; <br>It's the function (as in `v = f(d)`) whose execution is being tracked by the stack frame<br>The `key` is used during reconciliation to determine whether the fiber can be reused                                                                                                                                      |\n| `child` and `sibling`                                                                                         | point to other fibers, describing the **recursive tree structure** of a fiber<br>The child fibers form a singly-linked list (单向链表) whose head is the first child                                                                                                                                                                                                                                                                                                                                                                                                     |\n| `return`                                                                                                      | The return fiber is the fiber to which the program should return after processing the current one. It is conceptually the same as the return address of a stack frame. It can also be thought of as the parent fiber.<br>If a fiber has multiple child fibers, each child fiber's return fiber is the parent.                                                                                                                                                                                                                                                            |\n| `pendingProps` and `memoizedProps`                                                                            | `pendingProps` are set at the beginning of the function execution, and `memoizedProps` are set at the end.<br>When the incoming `pendingProps` are equal to `memoizedProps`, it signals that the fiber's previous output can be reused, preventing unnecessary work                                                                                                                                                                                                                                                                                                      |\n| `pendingWorkPriority` (New: FiberNode Implementations does not have any \"priorities\". instead it has \"Lanes\") | A number indicating the priority of the work represented by the fiber;<br>With the exception of `NoWork`, which is 0, a larger number indicates a lower priority.<br>The scheduler uses the priority field to search for the next unit of work to perform<br>`js<br>  /**<br>   * Each filer knows<br>   * 1. priorities for the work of itself - lanes<br>   * 2. priorities for the work of its descendant - childLanes<br>   */<br>  this.lanes = NoLanes;<br>  this.childLanes = NoLanes;<br>` <br>                                                                  |\n| `alternate`                                                                                                   | a component instance has at most two fibers that correspond to it: the current, flushed fiber, and the work-in-progress fiber;<br>The alternate of the current fiber is the work-in-progress, and the alternate of the work-in-progress is the current fiber.<br>A fiber's alternate is created lazily using a function called `cloneFiber`. Rather than always creating a new object, `cloneFiber` will attempt to reuse the fiber's alternate if it exists, minimizing allocations (Double buffering/ 改变指针指向)                                                    |\n| `output`                                                                                                      | the output of a fiber is the return value of a function<br>Every fiber eventually has output, but output is created only at the leaf nodes by **host components** (The leaf nodes of a React application. They are specific to the rendering environment (e.g., in a browser app, they are `div`, `span`, etc.)). The output is then transferred up the tree<br>The output is what is eventually given to the renderer so that it can flush the changes to the rendering environment. It's the renderer's responsibility to define how the output is created and updated |\n\nThe child fiber corresponds to the value returned by a component's `render` method. So in the following example\n\n```js\nfunction Parent() {\n  return <Child />;\n}\n```\n\nThe child fiber of `Parent` corresponds to `Child`.\nThe sibling field accounts for the case where `render` returns multiple children (a new feature in Fiber!):\n\n```js\nfunction Parent() {\n  return [<Child1 />, <Child2 />];\n}\n```\n\n### Background\n\n[zhihu.com/question/31809713/answer/53544875](https://www.zhihu.com/question/31809713/answer/53544875)\n\n#### 杀手级特性 (killer feature)\n\n- **Declarative:** React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug. (make UI coding easier (declarative instead of imperative))\n- **Component-Based:** Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep the state out of the DOM.\n- **Learn Once, Write Anywhere:** We don't make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. React can also render on the server using [Node](https://nodejs.org/en) and power mobile apps using [React Native](https://reactnative.dev/).\n- The central idea of React's API is to think of updates as if they cause the entire app to re-render.\n\n#### Re-render\n\nA change in the data used to render a React app. Usually the result of `setState`. Eventually results in a re-render.\n\n#### Diff\n\n![image.png](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-diff.png)\n\n#### Reconciliation / Virtual DOM (虚拟 DOM)\n\n> Virtual DOM 是 React 的一个非常核心的技术细节，它也是前端渲染和性能的关键技术。所以，你有必要要好好学习一下这个技术的实现原理和算法。当然，前提条件是你需要学习过前面我所推荐过的浏览器的工作原理。下面是一些不错的文章可以帮你学习这一技术。\n> 虚拟 DOM（Virtual DOM）是一种 **在内存中表示真实 DOM 的数据结构**。它允许我们在内存中对 DOM 进行操作，而不是直接操作真实的 DOM。\n\n- Optimization for re-rendering\n- When the app is updated (usually via `setState`), a new tree is generated.\n- The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app. ^a7iagv\n  - Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.\n  - Diffing of lists is performed using keys. Keys should be \"stable, predictable, and unique.\"\n\n##### Supports DOM, and iOS, Android via React Native\n\n| Reconciler                                                                                               | Renderer                                                                                                         |\n| -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |\n| only 1 reconciliation algorithm when download react (-> Rewritten to **Fiber reconciliation algorithm**) | pluggable (can work with other host platform besides DOM)                                                        |\n| does the work of computing which parts of a tree have changed                                            | uses that information to actually update the rendered app                                                        |\n|                                                                                                          | React DOM and React Native can use their own renderers while sharing the same reconciler, provided by React core |\n\n##### [你知道 Virtual DOM 的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n\n- [为何说虚拟 DOM 会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React 的虚拟 DOM 和 vue 的虚拟 DOM 有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n  虚拟 DOM 的主要优势是性能提升，原因如下：\n\n1. 减少 DOM 操作次数：真实 DOM 的操作（如创建、更新、删除元素）通常比内存操作更耗时。虚拟 DOM 允许我们在内存中进行大量操作，然后一次性将这些操作应用到真实 DOM 上，减少了对真实 DOM 的操作次数。\n2. 最小化更新范围：虚拟 DOM 结合 diff 算法，可以找出新旧虚拟 DOM 之间的差异，从而仅对有差异的部分进行真实 DOM 的更新。这可以减少不必要的 DOM 操作，提高性能。\n3. 批量更新：当有多个更改需要应用到真实 DOM 时，虚拟 DOM 可以将这些更改合并为一次更新。这有助于避免因多次操作导致的布局抖动（Layout Thrashing）和重绘，从而提高性能。\n4. 更好的跨平台兼容性：虚拟 DOM 不仅可以表示 Web 页面中的 DOM，还可以表示其他平台的 UI（例如移动应用或桌面应用）。这意味着使用虚拟 DOM 的框架（如 Vue 或 React）可以更容易地实现跨平台应用程序，而不必为每个平台编写特定的代码。  \n   虚拟 DOM 的性能提升并非绝对，它主要适用于大型应用和频繁更新的场景。对于简单的应用或更新较少的情况，虚拟 DOM 可能带来一定的开销。然而，在许多情况下，虚拟 DOM 提供了一种有效的方法来减少真实 DOM 操作，从而提高应用程序的性能。\n\n##### Pre-requisite\n\n- DOM: ![image.png|475](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406160709065.png)\n- 🏷️Browser-浏览器工作原理\n\n##### Reference\n\n- [in Depth-how-virtual-dom-is-implemented-in-react](https://angularindepth.com/posts/1501/exploring-how-virtual-dom-is-implemented-in-react)\n- [How to write your own Virtual DOM | by deathmood | Medium](https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060)\n- [Write your Virtual DOM 2: Props & Events | by deathmood | Medium](https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76)\n- [How Virtual-DOM and diffing works in React | by Gethyl George Kurian | Medium](https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e)\n- [The Inner Workings Of Virtual DOM | by rajaraodv | Medium](https://rajaraodv.medium.com/the-inner-workings-of-virtual-dom-666ee7ad47cf)\n- [深度剖析：如何实现一个 Virtual DOM 算法 · Issue #13 · livoras/blog · GitHub](https://github.com/livoras/blog/issues/13)\n- 两个 Vitual-DOM 实现供你参考\n  - [GitHub - Matt-Esch/virtual-dom: A Virtual DOM and diffing algorithm](https://github.com/Matt-Esch/virtual-dom)\n  - [Maquette](https://maquettejs.org/)\n\n##### Questions\n\n- [说说 React diff 的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [说说你对 React 的 reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [React16 的 reconciliation 和 commit 分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n\n### Goal of Fiber\n\nincrease react core algorithm's suitability for areas like animation, layout, and gestures\n**incremental rendering**: the ability to split rendering work into chunks and spread it out over multiple frames\n\n#### the ability to pause, abort, or reuse work as new updates come in\n\n- pause work and come back to it later.\n- reuse previously completed work.\n- abort work if it's no longer needed.\n\n#### the ability to assign priority to different types of updates\n\n### How Fiber works\n\n- how the **scheduler** finds the next unit of work to perform.\n- how **priority** is tracked and propagated through the fiber tree.\n- how the scheduler knows when to pause and resume work.\n- how work is flushed and marked as complete.\n- how side-effects (such as lifecycle methods) work.\n- what a coroutine is and how it can be used to implement features like context and layout.\n\n#### Comparison with old reconciler\n\n| Previous (Stack) Reconciler                                                                                                                        | Fiber Reconciler                                                                                                                                | How optimization happens                                                                                                                                                                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| element > instance > Dom node                                                                                                                      |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| React walks the tree recursively and calls render functions of the whole updated tree during a single tick (main thread gets stuck)                | be able to break up & schedule high priority work to be handled before low priority work (start delaying some updates to avoid dropping frames) | Current Tree & workInProgress Tree                                                                                                                                                                                                                                                                                                                                                                                      |\n| ![image.png                                                                                                                                        | 200](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151436374.png)<br>                                                        | ![image.png                                                                                                                                                                                                                                                                                                                                                                                                             | 400](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151437675.png)<br> | **Phases**: <br>P1: render/ reconciliation (can be interrupted)<br>- `componentWillMount`<br>- `componentWillReceiveProps`<br>- `shouldComponentUpate`<br>- `componentWillUpdate`<br>P2: commit (can not be interrupted)<br>- `componentDidMount`<br>- `componentDidUpdate`<br>- `componentWillUnmount` |\n| make changes to the DOM node immediately when changes detected (before other updates are computed/ before calling render on other bottom elements) | Why? to avoid change DOM directly while computing changes to the tree                                                                           | **Schedule updates**: `requestIdleCallback()` <br>- Browser will let React know how much idle time it has to spare to commit updates<br>**work loop**: <br>- **next unit of work**: HostRoot (starts from HostRoot, <br> - if no updates it's gonna clone the node then continues to check its child )<br> - if updates exits, it's gonna tag the change to the workInProgress tree node<br>- **time remaining**: 13 ms |\n|                                                                                                                                                    | Enable error boundary                                                                                                                           | **Double buffering**: <br>when updates completed, react will switch pointer to the current tree and workInProgress tree                                                                                                                                                                                                                                                                                                 |\n|                                                                                                                                                    | Higher priority work will be handled before lower priority work                                                                                 | **Priority**<br>- High Priority: UI changes<br>- Low Priority: Data content changes from server <br>**Cooperative scheduling**<br>- Break work into small pieces of task, so that it can be paused                                                                                                                                                                                                                      |\n| render a single tree                                                                                                                               | steaming rendering                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                                                                                                                                                    | handle work in parallel                                                                                                                         | Split branches of the tree                                                                                                                                                                                                                                                                                                                                                                                              |\n|                                                                                                                                                    |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n\n#### Chunking（分包）\n\nFiber 架构把渲染工作拆分成了多个小块（chunks）。每个 Fiber 节点代表了一个工作单元。React 渲染时，会按顺序遍历 Fiber 树中的节点，执行与每个节点相关的工作。\n![image.png](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-fiber.png)\n\n#### Double Buffering (双缓冲)\n\nReact 在内存中维护了两个树结构：当前的树和正在工作的树。这使得 React 可以在用户不可见的地方进行工作，并且只有当工作完成并且整个树都准备好更新时，才会进行提交。\n\n\x3c!-- ![diff](react-internal%201.md#^a7iagv) --\x3e\n\n#### Priority\n\n[react/packages/scheduler/src/SchedulerPriorities.js at main · facebook/react · GitHub](https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerPriorities.js)\n\n- Different types of updates have different priorities — an animation update needs to complete more quickly than, say, an update from a data store.\n- **Immediate Priority**：用于不能等待的工作，比如由用户输入或动画触发的更新。\n- **User Blocking Priority**：用于可能阻塞用户操作的工作。\n- **Normal Priority**：用于正常的数据抓取、DOM 更新等。\n- **Low Priority**：用于不急迫的任务，可以推迟的工作，如日志记录。\n- **Idle Priority**：用于完全不紧急的任务，只有在主线程空闲时才执行，如离屏渲染。\n\n#### Scheduler (调度器) / Concurrent Mode (并发模式)\n\n> it's not necessary for every update to be applied immediately\n\nUnlike a push-based approach which requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you.\n_scheduling_\nthe process of determining when work should be performed.\n_work_\nany computations that must be performed. Work is usually the result of an update (e.g. `setState`).\n [here](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L29-L28) you can see all types of work targets in Fiber\n\n##### MessageChannel\n\n`MessageChannel` API 可以创建一个新的消息通道，并通过它的两个`MessagePort`属性发送数据。在 React 的任务调度器中，使用`MessageChannel`主要是为了实现一种可以跨浏览器和环境持续运行的“微任务”调度。\n使用`MessageChannel`可以使得 React 在处理如输入事件之后尽快调度更新，因为它可以将任务排队为微任务，这些微任务将在当前宏任务结束后尽快执行，但在下一个宏任务开始之前执行\n\n##### Time Slicing（时间分片）\n\nReact 使用浏览器的`requestIdleCallback`和`requestAnimationFrame`API 来执行时间分片。使用`requestIdleCallback`可以让 React 在浏览器空闲时执行低优先级的更新，而`requestAnimationFrame`则用于高优先级的更新，如动画。 ^u64q5e\nReact 将更新分解成小的任务单元。每个任务单元在执行时都会检查是否还有剩余时间，如果没有，就将控制权交还给浏览器。这样可以让 React 在执行大量工作时仍然能够响应用户的交互。\n\n###### 实现功能\n\nnon-blocking rendering\napplying updates based on the priority\npre-rendering content in the background\n\n#### 使用 Concurrent Mode\n\n为了启用 Concurrent Mode，你需要使用`React.createRoot`代替`ReactDOM.render`来创建根节点\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n```\n\n#### [React Fiber 它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n\n#### [说说你对 Fiber 架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n\n- [Inside Fiber: in-depth overview of the new reconciliation algorithm in React | by Max Koretskyi | React In Depth | Medium](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)\n- [in Depth-inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react](https://angularindepth.com/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react)\n- [in Depth-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree](https://angularindepth.com/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree)\n\n### React 18 批处理\n\n在 React 18 中，自动批处理被扩展到更多的场景，包括：\n\n- **Promise 的解决和拒绝处理程序**：在异步代码中，例如 Promise 链或 async/await 函数中的状态更新现在也会自动批处理。\n- **setTimeout 和 setInterval 回调**：使用这些定时器函数的回调中的状态更新现在也会被批处理。\n- **原生事件处理程序**：在非 React 合成事件的监听器中进行的状态更新也会被批处理。\n- **任何其他事件循环中的事件处理**：几乎所有的状态更新，不管它们来源于什么，只要它们在同一个事件循环中，都会被自动批处理。\n  React 18 批处理自动批处理的工作原理是 React 在执行更新时采用了一种懒惰的方式，它会将多个更新累积起来，然后一次性应用这些更新，而不是对每个更新立即进行重新渲染。这减少了重复的工作和不必要的 DOM 更新，从而提高了性能。\n\n```jsx\n// 假设我们有两个状态更新函数\nconst [count, setCount] = useState(0);\nconst [flag, setFlag] = useState(false);\n// 在 React 17 中，这些更新会导致两次重新渲染\nsetTimeout(() => {\n  setCount((c) => c + 1); // 1st re-render\n  setFlag((f) => !f); // 2nd re-render\n}, 1000);\n// 在 React 18 中，这些更新会被自动批处理为一次重新渲染\nsetTimeout(() => {\n  setCount((c) => c + 1); // Both updates are batched\n  setFlag((f) => !f); // into a single re-render\n}, 1000);\n```\n\n#### 选择性批处理\n\nReact 18 提供了 `flushSync` 函数，允许你选择性地退出批处理，可以确保在回调中的更新立即被应用，触发同步的重新渲染\n\n```jsx\nimport { flushSync } from \"react-dom\";\n// 在 flushSync 的回调中的更新不会批处理\nflushSync(() => {\n  setCount((c) => c + 1); // These updates are\n});\nflushSync(() => {\n  setFlag((f) => !f); // applied immediately\n});\n```\n\n## Questions\n\n#### [简要描述下你知道的 React 工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n\n#### [你阅读了几遍 React 的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n\n#### [你阅读过 React 的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n\n#### [React 怎么拿到组件对应的 DOM 元素？](https://github.com/haizlin/fe-interview/issues/663)\n\n#### 讲一下 react 状态发生变化触发视图更新的链路\n\n##### 1. 状态更新\n\n这个过程通常从一个状态更新开始。这可能是由于 `setState`、`useState` 的 setter 函数或 `useReducer` 的 dispatch 调用引起的。\n当状态更新被触发时，React 会将该组件标记为需要更新。\n\n##### 2. 调度更新\n\nReact 的调度器接收到更新请求，并根据其优先级决定何时执行更新。在 Concurrent Mode 下，React 可能会根据任务的紧急程度和浏览器的空闲时间来推迟或中断更新。\n\n##### 3. 协调（Reconciliation）\n\n协调过程开始时，React 会为当前的更新创建一个工作单元，并开始遍历组件树（也称为 Fiber 树）。\n\n1. **比较阶段**：React 会比较新的组件状态和上一次渲染的状态，计算出实际需要变更的部分。\n2. **生成 Fiber 树**：React 为渲染中的每个组件创建或更新 Fiber 节点。Fiber 是 React 用于跟踪组件树中的每个组件状态和结构的内部数据结构。\n\n##### 4. 渲染\n\n在协调过程中，React 为组件调用渲染函数（例如，函数组件本身或类组件的 `render` 方法），生成新的虚拟 DOM（React 元素）。\n\n##### 5. 提交\n\n当协调完成并且 React 准备好应用变更到实际 DOM 时，它会执行提交阶段。\n\n1. **执行副作用**：在提交阶段，React 会执行 `useEffect`、`useLayoutEffect` 等 Hook 中的副作用函数。\n2. **更新 DOM**：React 将更新计算出来的变更应用到实际的 DOM 上。这可能包括属性的更新、元素的添加或删除等。\n3. **引用赋值**：React 会更新需要变更的组件的引用，例如将 DOM 节点赋值给通过 `useRef` 创建的 Refs。\n\n##### 6. 清理与通知\n\n最后，React 清理之前渲染的状态、执行副作用的清理函数，并在需要时通知组件更新完成。这是一个清理并使系统保持最新状态的过程。\n\n##### 思考\n\n整个过程是高度优化的，涉及到了一系列复杂的内部机制。React 使用了如 Fiber 架构、双缓冲、时间切片等技术，使得即使在大规模的更新中也能保持高性能并避免阻塞主线程。\n在实践中，React 开发者不需要深入了解所有内部细节，但理解状态更新和视图更新之间的基本链路对于编写高效且符合预期的代码是非常有帮助的。\n",data={title:"react-internal",DateStarted:new Date(17165088e5),draft:!1,tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-internal/react-internal.md",rawData:void 0},html='<h1 id="react-internal">React Internal<a class="anchor" href="#react-internal"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<p><a href="https://juejin.cn/post/7329780589061095434">juejin.cn/post/7329780589061095434</a></p>\n<h2 id="reverse-engineering">Reverse Engineering<a class="anchor" href="#reverse-engineering"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p><a href="https://angularindepth.com/posts/1005/level-up-your-reverse-engineering-skills">in Depth-level-up-your-reverse-engineering-skills</a><br>\n<a href="https://angularindepth.com/posts/1006/practical-application-of-reverse-engineering-guidelines-and-principles">in Depth-practical-application-of-reverse-engineering-guidelines-and-principles</a></p>\n<h2 id="fiber">Fiber<a class="anchor" href="#fiber"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p><a href="https://www.youtube.com/watch?v=ZCuYPiUIONs">Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 - YouTube</a>\n<a href="https://github.com/acdlite/react-fiber-architecture?source=post_page---------------------------">GitHub - acdlite/react-fiber-architecture: A description of React’s new core algorithm, React Fiber</a> (Notes by Andrew Clark)</p>\n<h3 id="what-is-fiber">What is Fiber<a class="anchor" href="#what-is-fiber"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Fiber 实际上是对 React 虚拟 DOM 的每个节点的重新实现。每个 Fiber 节点代表一个工作单元，它对应一个 React 元素、组件实例或 DOM 节点。这个新的结构是个单链表的形式，允许 React 在执行中逐节点遍历和操作。\n每个 Fiber 节点都有自己的内部状态和对其他 Fiber 节点的引用（例如，对子节点、父节点、兄弟节点的引用），以及对实际 DOM 节点的引用（如果有的话）。React 可以独立地更新这些 Fiber 节点，这是 Fiber 架构的核心优势，它允许<strong>任务分割和中断</strong>工作。为未来的 React 特性和优化提供了基础，包括<strong>异步渲染和并发模式（Concurrent Mode）</strong>，这些都是 React 应用未来性能提升的关键方面。</p>\n<h4 id="why-this-name-fiber">Why this name “Fiber”<a class="anchor" href="#why-this-name-fiber"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>A fiber represents a <strong>unit of work</strong>\n Fiber is reimplementation of the stack, specialized for React components.\n You can think of a single fiber as a <strong>virtual stack frame</strong>\nIn order to use new Browser APIs (<a href="react-internal%201.md#%5Eu64q5e">Time-Slicing</a>) for scheduling update:</p>\n<ul>\n<li>need a way to break rendering work into incremental units. If you rely only on the call stack, it will keep doing work until the stack is empty\nSo that we can</li>\n<li>customize the behavior of the <strong>call stack</strong> to optimize for rendering UIs</li>\n<li>interrupt the call stack at will and manipulate stack frames manually</li>\n<li>can <a href="https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/">keep stack frames in memory</a> and execute them however (and <em>whenever</em>) you want</li>\n<li>potential for features such as concurrency and error boundaries</li>\n</ul>\n<h4 id="reconciliation">Reconciliation<a class="anchor" href="#reconciliation"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>一种新的调和算法 (Reconciliation algorithm), reimplementation of React’s core algorithm\nthe algorithm React uses to <strong>diff</strong> one tree with another to determine which parts need to be changed\nthe culmination of over two years of research by the React team</p>\n<h4 id="data-structure-list--tree">Data Structure (List &#x26; Tree)<a class="anchor" href="#data-structure-list--tree"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>a plain JS object that</p>\n<ul>\n<li>contains information about a component, its input, and its output</li>\n<li>corresponds to a stack frame, but it also corresponds to an instance of a component</li>\n<li>has an 1-to-1 relationship with a component instance (to manage work for an instance)</li>\n</ul>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> fiber</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">  stateNode </span><span style="color:#6A737D">// To manage its instance</span></span>\n<span class="line"><span style="color:#E1E4E8">  child</span></span>\n<span class="line"><span style="color:#E1E4E8">  return</span></span>\n<span class="line"><span style="color:#E1E4E8">  sibling</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<p><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151445079.png" alt="image.png|275"></p>\n<h5 id="important-fields-of-a-fiber">Important fields of a fiber<a class="anchor" href="#important-fields-of-a-fiber"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Fields</th><th>For</th></tr></thead><tbody><tr><td><code>type</code> &#x26; <code>key</code></td><td>The type and key of a fiber serve the same purpose as they do for React elements. (In fact, when a fiber is created from an element, these two fields are copied over directly.)<br>The <code>type</code> describes the component that it corresponds to; <br>It’s the function (as in <code>v = f(d)</code>) whose execution is being tracked by the stack frame<br>The <code>key</code> is used during reconciliation to determine whether the fiber can be reused</td></tr><tr><td><code>child</code> and <code>sibling</code></td><td>point to other fibers, describing the <strong>recursive tree structure</strong> of a fiber<br>The child fibers form a singly-linked list (单向链表) whose head is the first child</td></tr><tr><td><code>return</code></td><td>The return fiber is the fiber to which the program should return after processing the current one. It is conceptually the same as the return address of a stack frame. It can also be thought of as the parent fiber.<br>If a fiber has multiple child fibers, each child fiber’s return fiber is the parent.</td></tr><tr><td><code>pendingProps</code> and <code>memoizedProps</code></td><td><code>pendingProps</code> are set at the beginning of the function execution, and <code>memoizedProps</code> are set at the end.<br>When the incoming <code>pendingProps</code> are equal to <code>memoizedProps</code>, it signals that the fiber’s previous output can be reused, preventing unnecessary work</td></tr><tr><td><code>pendingWorkPriority</code> (New: FiberNode Implementations does not have any “priorities”. instead it has “Lanes”)</td><td>A number indicating the priority of the work represented by the fiber;<br>With the exception of <code>NoWork</code>, which is 0, a larger number indicates a lower priority.<br>The scheduler uses the priority field to search for the next unit of work to perform<br><code>js&#x3C;br>  /**&#x3C;br>   * Each filer knows&#x3C;br>   * 1. priorities for the work of itself - lanes&#x3C;br>   * 2. priorities for the work of its descendant - childLanes&#x3C;br>   */&#x3C;br>  this.lanes = NoLanes;&#x3C;br>  this.childLanes = NoLanes;&#x3C;br></code> <br></td></tr><tr><td><code>alternate</code></td><td>a component instance has at most two fibers that correspond to it: the current, flushed fiber, and the work-in-progress fiber;<br>The alternate of the current fiber is the work-in-progress, and the alternate of the work-in-progress is the current fiber.<br>A fiber’s alternate is created lazily using a function called <code>cloneFiber</code>. Rather than always creating a new object, <code>cloneFiber</code> will attempt to reuse the fiber’s alternate if it exists, minimizing allocations (Double buffering/ 改变指针指向)</td></tr><tr><td><code>output</code></td><td>the output of a fiber is the return value of a function<br>Every fiber eventually has output, but output is created only at the leaf nodes by <strong>host components</strong> (The leaf nodes of a React application. They are specific to the rendering environment (e.g., in a browser app, they are <code>div</code>, <code>span</code>, etc.)). The output is then transferred up the tree<br>The output is what is eventually given to the renderer so that it can flush the changes to the rendering environment. It’s the renderer’s responsibility to define how the output is created and updated</td></tr></tbody></table>\n<p>The child fiber corresponds to the value returned by a component’s <code>render</code> method. So in the following example</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Parent</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#79B8FF">Child</span><span style="color:#E1E4E8"> />;</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<p>The child fiber of <code>Parent</code> corresponds to <code>Child</code>.\nThe sibling field accounts for the case where <code>render</code> returns multiple children (a new feature in Fiber!):</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Parent</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">  return</span><span style="color:#E1E4E8"> [&#x3C;</span><span style="color:#79B8FF">Child1</span><span style="color:#E1E4E8"> />, &#x3C;</span><span style="color:#79B8FF">Child2</span><span style="color:#E1E4E8"> />];</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<h3 id="background">Background<a class="anchor" href="#background"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p><a href="https://www.zhihu.com/question/31809713/answer/53544875">zhihu.com/question/31809713/answer/53544875</a></p>\n<h4 id="杀手级特性-killer-feature">杀手级特性 (killer feature)<a class="anchor" href="#杀手级特性-killer-feature"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><strong>Declarative:</strong> React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug. (make UI coding easier (declarative instead of imperative))</li>\n<li><strong>Component-Based:</strong> Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep the state out of the DOM.</li>\n<li><strong>Learn Once, Write Anywhere:</strong> We don’t make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. React can also render on the server using <a href="https://nodejs.org/en">Node</a> and power mobile apps using <a href="https://reactnative.dev/">React Native</a>.</li>\n<li>The central idea of React’s API is to think of updates as if they cause the entire app to re-render.</li>\n</ul>\n<h4 id="re-render">Re-render<a class="anchor" href="#re-render"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>A change in the data used to render a React app. Usually the result of <code>setState</code>. Eventually results in a re-render.</p>\n<h4 id="diff">Diff<a class="anchor" href="#diff"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-diff.png" alt="image.png"></p>\n<h4 id="reconciliation--virtual-dom-虚拟-dom">Reconciliation / Virtual DOM (虚拟 DOM)<a class="anchor" href="#reconciliation--virtual-dom-虚拟-dom"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<blockquote>\n<p>Virtual DOM 是 React 的一个非常核心的技术细节，它也是前端渲染和性能的关键技术。所以，你有必要要好好学习一下这个技术的实现原理和算法。当然，前提条件是你需要学习过前面我所推荐过的浏览器的工作原理。下面是一些不错的文章可以帮你学习这一技术。\n虚拟 DOM（Virtual DOM）是一种 <strong>在内存中表示真实 DOM 的数据结构</strong>。它允许我们在内存中对 DOM 进行操作，而不是直接操作真实的 DOM。</p>\n</blockquote>\n<ul>\n<li>Optimization for re-rendering</li>\n<li>When the app is updated (usually via <code>setState</code>), a new tree is generated.</li>\n<li>The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app. ^a7iagv\n<ul>\n<li>Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.</li>\n<li>Diffing of lists is performed using keys. Keys should be “stable, predictable, and unique.”</li>\n</ul>\n</li>\n</ul>\n<h5 id="supports-dom-and-ios-android-via-react-native">Supports DOM, and iOS, Android via React Native<a class="anchor" href="#supports-dom-and-ios-android-via-react-native"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n<table><thead><tr><th>Reconciler</th><th>Renderer</th></tr></thead><tbody><tr><td>only 1 reconciliation algorithm when download react (-> Rewritten to <strong>Fiber reconciliation algorithm</strong>)</td><td>pluggable (can work with other host platform besides DOM)</td></tr><tr><td>does the work of computing which parts of a tree have changed</td><td>uses that information to actually update the rendered app</td></tr><tr><td></td><td>React DOM and React Native can use their own renderers while sharing the same reconciler, provided by React core</td></tr></tbody></table>\n<h5 id="你知道-virtual-dom-的工作原理吗"><a href="https://github.com/haizlin/fe-interview/issues/655">你知道 Virtual DOM 的工作原理吗？</a><a class="anchor" href="#你知道-virtual-dom-的工作原理吗"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ul>\n<li><a href="https://github.com/haizlin/fe-interview/issues/720">为何说虚拟 DOM 会提高性能？</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/617">React 的虚拟 DOM 和 vue 的虚拟 DOM 有什么区别？</a>\n虚拟 DOM 的主要优势是性能提升，原因如下：</li>\n</ul>\n<ol>\n<li>减少 DOM 操作次数：真实 DOM 的操作（如创建、更新、删除元素）通常比内存操作更耗时。虚拟 DOM 允许我们在内存中进行大量操作，然后一次性将这些操作应用到真实 DOM 上，减少了对真实 DOM 的操作次数。</li>\n<li>最小化更新范围：虚拟 DOM 结合 diff 算法，可以找出新旧虚拟 DOM 之间的差异，从而仅对有差异的部分进行真实 DOM 的更新。这可以减少不必要的 DOM 操作，提高性能。</li>\n<li>批量更新：当有多个更改需要应用到真实 DOM 时，虚拟 DOM 可以将这些更改合并为一次更新。这有助于避免因多次操作导致的布局抖动（Layout Thrashing）和重绘，从而提高性能。</li>\n<li>更好的跨平台兼容性：虚拟 DOM 不仅可以表示 Web 页面中的 DOM，还可以表示其他平台的 UI（例如移动应用或桌面应用）。这意味着使用虚拟 DOM 的框架（如 Vue 或 React）可以更容易地实现跨平台应用程序，而不必为每个平台编写特定的代码。<br>\n虚拟 DOM 的性能提升并非绝对，它主要适用于大型应用和频繁更新的场景。对于简单的应用或更新较少的情况，虚拟 DOM 可能带来一定的开销。然而，在许多情况下，虚拟 DOM 提供了一种有效的方法来减少真实 DOM 操作，从而提高应用程序的性能。</li>\n</ol>\n<h5 id="pre-requisite">Pre-requisite<a class="anchor" href="#pre-requisite"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ul>\n<li>DOM: <img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406160709065.png" alt="image.png|475"></li>\n<li>🏷️Browser-浏览器工作原理</li>\n</ul>\n<h5 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ul>\n<li><a href="https://angularindepth.com/posts/1501/exploring-how-virtual-dom-is-implemented-in-react">in Depth-how-virtual-dom-is-implemented-in-react</a></li>\n<li><a href="https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060">How to write your own Virtual DOM | by deathmood | Medium</a></li>\n<li><a href="https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76">Write your Virtual DOM 2: Props &#x26; Events | by deathmood | Medium</a></li>\n<li><a href="https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e">How Virtual-DOM and diffing works in React | by Gethyl George Kurian | Medium</a></li>\n<li><a href="https://rajaraodv.medium.com/the-inner-workings-of-virtual-dom-666ee7ad47cf">The Inner Workings Of Virtual DOM | by rajaraodv | Medium</a></li>\n<li><a href="https://github.com/livoras/blog/issues/13">深度剖析：如何实现一个 Virtual DOM 算法 · Issue #13 · livoras/blog · GitHub</a></li>\n<li>两个 Vitual-DOM 实现供你参考\n<ul>\n<li><a href="https://github.com/Matt-Esch/virtual-dom">GitHub - Matt-Esch/virtual-dom: A Virtual DOM and diffing algorithm</a></li>\n<li><a href="https://maquettejs.org/">Maquette</a></li>\n</ul>\n</li>\n</ul>\n<h5 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ul>\n<li><a href="https://github.com/haizlin/fe-interview/issues/724">说说 React diff 的原理是什么？</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/870">说说你对 React 的 reconciliation（一致化算法）的理解</a></li>\n<li><a href="https://github.com/haizlin/fe-interview/issues/711">React16 的 reconciliation 和 commit 分别是什么？</a></li>\n</ul>\n<h3 id="goal-of-fiber">Goal of Fiber<a class="anchor" href="#goal-of-fiber"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>increase react core algorithm’s suitability for areas like animation, layout, and gestures\n<strong>incremental rendering</strong>: the ability to split rendering work into chunks and spread it out over multiple frames</p>\n<h4 id="the-ability-to-pause-abort-or-reuse-work-as-new-updates-come-in">the ability to pause, abort, or reuse work as new updates come in<a class="anchor" href="#the-ability-to-pause-abort-or-reuse-work-as-new-updates-come-in"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>pause work and come back to it later.</li>\n<li>reuse previously completed work.</li>\n<li>abort work if it’s no longer needed.</li>\n</ul>\n<h4 id="the-ability-to-assign-priority-to-different-types-of-updates">the ability to assign priority to different types of updates<a class="anchor" href="#the-ability-to-assign-priority-to-different-types-of-updates"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h3 id="how-fiber-works">How Fiber works<a class="anchor" href="#how-fiber-works"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>how the <strong>scheduler</strong> finds the next unit of work to perform.</li>\n<li>how <strong>priority</strong> is tracked and propagated through the fiber tree.</li>\n<li>how the scheduler knows when to pause and resume work.</li>\n<li>how work is flushed and marked as complete.</li>\n<li>how side-effects (such as lifecycle methods) work.</li>\n<li>what a coroutine is and how it can be used to implement features like context and layout.</li>\n</ul>\n<h4 id="comparison-with-old-reconciler">Comparison with old reconciler<a class="anchor" href="#comparison-with-old-reconciler"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>| Previous (Stack) Reconciler                                                                                                                        | Fiber Reconciler                                                                                                                                | How optimization happens                                                                                                                                                                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| element > instance > Dom node                                                                                                                      |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| React walks the tree recursively and calls render functions of the whole updated tree during a single tick (main thread gets stuck)                | be able to break up &#x26; schedule high priority work to be handled before low priority work (start delaying some updates to avoid dropping frames) | Current Tree &#x26; workInProgress Tree                                                                                                                                                                                                                                                                                                                                                                                      |\n| <img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151436374.png" alt="image.png                                                                                                                                        | 200"><br>                                                        | <img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151437675.png" alt="image.png                                                                                                                                                                                                                                                                                                                                                                                                             | 400"><br> | <strong>Phases</strong>: <br>P1: render/ reconciliation (can be interrupted)<br>- <code>componentWillMount</code><br>- <code>componentWillReceiveProps</code><br>- <code>shouldComponentUpate</code><br>- <code>componentWillUpdate</code><br>P2: commit (can not be interrupted)<br>- <code>componentDidMount</code><br>- <code>componentDidUpdate</code><br>- <code>componentWillUnmount</code> |\n| make changes to the DOM node immediately when changes detected (before other updates are computed/ before calling render on other bottom elements) | Why? to avoid change DOM directly while computing changes to the tree                                                                           | <strong>Schedule updates</strong>: <code>requestIdleCallback()</code> <br>- Browser will let React know how much idle time it has to spare to commit updates<br><strong>work loop</strong>: <br>- <strong>next unit of work</strong>: HostRoot (starts from HostRoot, <br> - if no updates it’s gonna clone the node then continues to check its child )<br> - if updates exits, it’s gonna tag the change to the workInProgress tree node<br>- <strong>time remaining</strong>: 13 ms |\n|                                                                                                                                                    | Enable error boundary                                                                                                                           | <strong>Double buffering</strong>: <br>when updates completed, react will switch pointer to the current tree and workInProgress tree                                                                                                                                                                                                                                                                                                 |\n|                                                                                                                                                    | Higher priority work will be handled before lower priority work                                                                                 | <strong>Priority</strong><br>- High Priority: UI changes<br>- Low Priority: Data content changes from server <br><strong>Cooperative scheduling</strong><br>- Break work into small pieces of task, so that it can be paused                                                                                                                                                                                                                      |\n| render a single tree                                                                                                                               | steaming rendering                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                                                                                                                                                    | handle work in parallel                                                                                                                         | Split branches of the tree                                                                                                                                                                                                                                                                                                                                                                                              |\n|                                                                                                                                                    |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |</p>\n<h4 id="chunking分包">Chunking（分包）<a class="anchor" href="#chunking分包"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>Fiber 架构把渲染工作拆分成了多个小块（chunks）。每个 Fiber 节点代表了一个工作单元。React 渲染时，会按顺序遍历 Fiber 树中的节点，执行与每个节点相关的工作。\n<img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-fiber.png" alt="image.png"></p>\n<h4 id="double-buffering-双缓冲">Double Buffering (双缓冲)<a class="anchor" href="#double-buffering-双缓冲"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>React 在内存中维护了两个树结构：当前的树和正在工作的树。这使得 React 可以在用户不可见的地方进行工作，并且只有当工作完成并且整个树都准备好更新时，才会进行提交。</p>\n\x3c!-- ![diff](react-internal%201.md#^a7iagv) --\x3e\n<h4 id="priority">Priority<a class="anchor" href="#priority"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p><a href="https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerPriorities.js">react/packages/scheduler/src/SchedulerPriorities.js at main · facebook/react · GitHub</a></p>\n<ul>\n<li>Different types of updates have different priorities — an animation update needs to complete more quickly than, say, an update from a data store.</li>\n<li><strong>Immediate Priority</strong>：用于不能等待的工作，比如由用户输入或动画触发的更新。</li>\n<li><strong>User Blocking Priority</strong>：用于可能阻塞用户操作的工作。</li>\n<li><strong>Normal Priority</strong>：用于正常的数据抓取、DOM 更新等。</li>\n<li><strong>Low Priority</strong>：用于不急迫的任务，可以推迟的工作，如日志记录。</li>\n<li><strong>Idle Priority</strong>：用于完全不紧急的任务，只有在主线程空闲时才执行，如离屏渲染。</li>\n</ul>\n<h4 id="scheduler-调度器--concurrent-mode-并发模式">Scheduler (调度器) / Concurrent Mode (并发模式)<a class="anchor" href="#scheduler-调度器--concurrent-mode-并发模式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<blockquote>\n<p>it’s not necessary for every update to be applied immediately</p>\n</blockquote>\n<p>Unlike a push-based approach which requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you.\n<em>scheduling</em>\nthe process of determining when work should be performed.\n<em>work</em>\nany computations that must be performed. Work is usually the result of an update (e.g. <code>setState</code>).\n <a href="https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L29-L28">here</a> you can see all types of work targets in Fiber</p>\n<h5 id="messagechannel">MessageChannel<a class="anchor" href="#messagechannel"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p><code>MessageChannel</code> API 可以创建一个新的消息通道，并通过它的两个<code>MessagePort</code>属性发送数据。在 React 的任务调度器中，使用<code>MessageChannel</code>主要是为了实现一种可以跨浏览器和环境持续运行的“微任务”调度。\n使用<code>MessageChannel</code>可以使得 React 在处理如输入事件之后尽快调度更新，因为它可以将任务排队为微任务，这些微任务将在当前宏任务结束后尽快执行，但在下一个宏任务开始之前执行</p>\n<h5 id="time-slicing时间分片">Time Slicing（时间分片）<a class="anchor" href="#time-slicing时间分片"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>React 使用浏览器的<code>requestIdleCallback</code>和<code>requestAnimationFrame</code>API 来执行时间分片。使用<code>requestIdleCallback</code>可以让 React 在浏览器空闲时执行低优先级的更新，而<code>requestAnimationFrame</code>则用于高优先级的更新，如动画。 ^u64q5e\nReact 将更新分解成小的任务单元。每个任务单元在执行时都会检查是否还有剩余时间，如果没有，就将控制权交还给浏览器。这样可以让 React 在执行大量工作时仍然能够响应用户的交互。</p>\n<h6 id="实现功能">实现功能<a class="anchor" href="#实现功能"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h6>\n<p>non-blocking rendering\napplying updates based on the priority\npre-rendering content in the background</p>\n<h4 id="使用-concurrent-mode">使用 Concurrent Mode<a class="anchor" href="#使用-concurrent-mode"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>为了启用 Concurrent Mode，你需要使用<code>React.createRoot</code>代替<code>ReactDOM.render</code>来创建根节点</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> React </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "react"</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> ReactDOM </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "react-dom"</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> root</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> ReactDOM.</span><span style="color:#B392F0">createRoot</span><span style="color:#E1E4E8">(document.</span><span style="color:#B392F0">getElementById</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"root"</span><span style="color:#E1E4E8">));</span></span>\n<span class="line"><span style="color:#E1E4E8">root.</span><span style="color:#B392F0">render</span><span style="color:#E1E4E8">(&#x3C;</span><span style="color:#79B8FF">App</span><span style="color:#E1E4E8"> />);</span></span>\n<span class="line"></span></code></pre>\n<h4 id="react-fiber-它的目的是解决什么问题"><a href="https://github.com/haizlin/fe-interview/issues/858">React Fiber 它的目的是解决什么问题？</a><a class="anchor" href="#react-fiber-它的目的是解决什么问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="说说你对-fiber-架构的理解"><a href="https://github.com/haizlin/fe-interview/issues/700">说说你对 Fiber 架构的理解</a><a class="anchor" href="#说说你对-fiber-架构的理解"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><a href="https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e">Inside Fiber: in-depth overview of the new reconciliation algorithm in React | by Max Koretskyi | React In Depth | Medium</a></li>\n<li><a href="https://angularindepth.com/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react">in Depth-inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react</a></li>\n<li><a href="https://angularindepth.com/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree">in Depth-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree</a></li>\n</ul>\n<h3 id="react-18-批处理">React 18 批处理<a class="anchor" href="#react-18-批处理"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>在 React 18 中，自动批处理被扩展到更多的场景，包括：</p>\n<ul>\n<li><strong>Promise 的解决和拒绝处理程序</strong>：在异步代码中，例如 Promise 链或 async/await 函数中的状态更新现在也会自动批处理。</li>\n<li><strong>setTimeout 和 setInterval 回调</strong>：使用这些定时器函数的回调中的状态更新现在也会被批处理。</li>\n<li><strong>原生事件处理程序</strong>：在非 React 合成事件的监听器中进行的状态更新也会被批处理。</li>\n<li><strong>任何其他事件循环中的事件处理</strong>：几乎所有的状态更新，不管它们来源于什么，只要它们在同一个事件循环中，都会被自动批处理。\nReact 18 批处理自动批处理的工作原理是 React 在执行更新时采用了一种懒惰的方式，它会将多个更新累积起来，然后一次性应用这些更新，而不是对每个更新立即进行重新渲染。这减少了重复的工作和不必要的 DOM 更新，从而提高了性能。</li>\n</ul>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#6A737D">// 假设我们有两个状态更新函数</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">count</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setCount</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">flag</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">setFlag</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#B392F0"> useState</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">false</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#6A737D">// 在 React 17 中，这些更新会导致两次重新渲染</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">  setCount</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">c</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 1st re-render</span></span>\n<span class="line"><span style="color:#B392F0">  setFlag</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">f); </span><span style="color:#6A737D">// 2nd re-render</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#6A737D">// 在 React 18 中，这些更新会被自动批处理为一次重新渲染</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">  setCount</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">c</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// Both updates are batched</span></span>\n<span class="line"><span style="color:#B392F0">  setFlag</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">f); </span><span style="color:#6A737D">// into a single re-render</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">1000</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"></span></code></pre>\n<h4 id="选择性批处理">选择性批处理<a class="anchor" href="#选择性批处理"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>React 18 提供了 <code>flushSync</code> 函数，允许你选择性地退出批处理，可以确保在回调中的更新立即被应用，触发同步的重新渲染</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">import</span><span style="color:#E1E4E8"> { flushSync } </span><span style="color:#F97583">from</span><span style="color:#9ECBFF"> "react-dom"</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#6A737D">// 在 flushSync 的回调中的更新不会批处理</span></span>\n<span class="line"><span style="color:#B392F0">flushSync</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">  setCount</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">c</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> c </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// These updates are</span></span>\n<span class="line"><span style="color:#E1E4E8">});</span></span>\n<span class="line"><span style="color:#B392F0">flushSync</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">  setFlag</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">f</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#F97583"> !</span><span style="color:#E1E4E8">f); </span><span style="color:#6A737D">// applied immediately</span></span>\n<span class="line"><span style="color:#E1E4E8">});</span></span>\n<span class="line"></span></code></pre>\n<h2 id="questions-1">Questions<a class="anchor" href="#questions-1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="简要描述下你知道的-react-工作原理是什么"><a href="https://github.com/haizlin/fe-interview/issues/611">简要描述下你知道的 React 工作原理是什么？</a><a class="anchor" href="#简要描述下你知道的-react-工作原理是什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="你阅读了几遍-react-的源码都有哪些收获你是怎么阅读的"><a href="https://github.com/haizlin/fe-interview/issues/879">你阅读了几遍 React 的源码？都有哪些收获？你是怎么阅读的？</a><a class="anchor" href="#你阅读了几遍-react-的源码都有哪些收获你是怎么阅读的"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="你阅读过-react-的源码吗简要说下它的执行流程"><a href="https://github.com/haizlin/fe-interview/issues/654">你阅读过 React 的源码吗？简要说下它的执行流程</a><a class="anchor" href="#你阅读过-react-的源码吗简要说下它的执行流程"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-怎么拿到组件对应的-dom-元素"><a href="https://github.com/haizlin/fe-interview/issues/663">React 怎么拿到组件对应的 DOM 元素？</a><a class="anchor" href="#react-怎么拿到组件对应的-dom-元素"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="讲一下-react-状态发生变化触发视图更新的链路">讲一下 react 状态发生变化触发视图更新的链路<a class="anchor" href="#讲一下-react-状态发生变化触发视图更新的链路"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h5 id="1-状态更新">1. 状态更新<a class="anchor" href="#1-状态更新"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>这个过程通常从一个状态更新开始。这可能是由于 <code>setState</code>、<code>useState</code> 的 setter 函数或 <code>useReducer</code> 的 dispatch 调用引起的。\n当状态更新被触发时，React 会将该组件标记为需要更新。</p>\n<h5 id="2-调度更新">2. 调度更新<a class="anchor" href="#2-调度更新"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>React 的调度器接收到更新请求，并根据其优先级决定何时执行更新。在 Concurrent Mode 下，React 可能会根据任务的紧急程度和浏览器的空闲时间来推迟或中断更新。</p>\n<h5 id="3-协调reconciliation">3. 协调（Reconciliation）<a class="anchor" href="#3-协调reconciliation"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>协调过程开始时，React 会为当前的更新创建一个工作单元，并开始遍历组件树（也称为 Fiber 树）。</p>\n<ol>\n<li><strong>比较阶段</strong>：React 会比较新的组件状态和上一次渲染的状态，计算出实际需要变更的部分。</li>\n<li><strong>生成 Fiber 树</strong>：React 为渲染中的每个组件创建或更新 Fiber 节点。Fiber 是 React 用于跟踪组件树中的每个组件状态和结构的内部数据结构。</li>\n</ol>\n<h5 id="4-渲染">4. 渲染<a class="anchor" href="#4-渲染"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>在协调过程中，React 为组件调用渲染函数（例如，函数组件本身或类组件的 <code>render</code> 方法），生成新的虚拟 DOM（React 元素）。</p>\n<h5 id="5-提交">5. 提交<a class="anchor" href="#5-提交"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>当协调完成并且 React 准备好应用变更到实际 DOM 时，它会执行提交阶段。</p>\n<ol>\n<li><strong>执行副作用</strong>：在提交阶段，React 会执行 <code>useEffect</code>、<code>useLayoutEffect</code> 等 Hook 中的副作用函数。</li>\n<li><strong>更新 DOM</strong>：React 将更新计算出来的变更应用到实际的 DOM 上。这可能包括属性的更新、元素的添加或删除等。</li>\n<li><strong>引用赋值</strong>：React 会更新需要变更的组件的引用，例如将 DOM 节点赋值给通过 <code>useRef</code> 创建的 Refs。</li>\n</ol>\n<h5 id="6-清理与通知">6. 清理与通知<a class="anchor" href="#6-清理与通知"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>最后，React 清理之前渲染的状态、执行副作用的清理函数，并在需要时通知组件更新完成。这是一个清理并使系统保持最新状态的过程。</p>\n<h5 id="思考">思考<a class="anchor" href="#思考"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>整个过程是高度优化的，涉及到了一系列复杂的内部机制。React 使用了如 Fiber 架构、双缓冲、时间切片等技术，使得即使在大规模的更新中也能保持高性能并避免阻塞主线程。\n在实践中，React 开发者不需要深入了解所有内部细节，但理解状态更新和视图更新之间的基本链路对于编写高效且符合预期的代码是非常有帮助的。</p>',frontmatter={title:"react-internal",topic:["React"],type:"D",tags:["React"],category:"Front-End Frameworks",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,draft:!1,DateStarted:"2024-05-24T00:00:00.000Z",DateModified:"2024-09-14T00:00:00.000Z",minutes:22,words:4366},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-internal/react-internal.md",url=void 0;function rawContent(){return"\n# React Internal\n\n[juejin.cn/post/7329780589061095434](https://juejin.cn/post/7329780589061095434)\n\n## Reverse Engineering\n\n[in Depth-level-up-your-reverse-engineering-skills](https://angularindepth.com/posts/1005/level-up-your-reverse-engineering-skills)  \n[in Depth-practical-application-of-reverse-engineering-guidelines-and-principles](https://angularindepth.com/posts/1006/practical-application-of-reverse-engineering-guidelines-and-principles)\n\n## Fiber\n\n[Lin Clark - A Cartoon Intro to Fiber - React Conf 2017 - YouTube](https://www.youtube.com/watch?v=ZCuYPiUIONs)\n[GitHub - acdlite/react-fiber-architecture: A description of React's new core algorithm, React Fiber](https://github.com/acdlite/react-fiber-architecture?source=post_page---------------------------) (Notes by Andrew Clark)\n\n### What is Fiber\n\nFiber 实际上是对 React 虚拟 DOM 的每个节点的重新实现。每个 Fiber 节点代表一个工作单元，它对应一个 React 元素、组件实例或 DOM 节点。这个新的结构是个单链表的形式，允许 React 在执行中逐节点遍历和操作。\n每个 Fiber 节点都有自己的内部状态和对其他 Fiber 节点的引用（例如，对子节点、父节点、兄弟节点的引用），以及对实际 DOM 节点的引用（如果有的话）。React 可以独立地更新这些 Fiber 节点，这是 Fiber 架构的核心优势，它允许**任务分割和中断**工作。为未来的 React 特性和优化提供了基础，包括**异步渲染和并发模式（Concurrent Mode）**，这些都是 React 应用未来性能提升的关键方面。\n\n#### Why this name \"Fiber\"\n\nA fiber represents a **unit of work**\n Fiber is reimplementation of the stack, specialized for React components.\n You can think of a single fiber as a **virtual stack frame**\nIn order to use new Browser APIs ([Time-Slicing](react-internal%201.md#^u64q5e)) for scheduling update:\n\n- need a way to break rendering work into incremental units. If you rely only on the call stack, it will keep doing work until the stack is empty\n  So that we can\n- customize the behavior of the **call stack** to optimize for rendering UIs\n- interrupt the call stack at will and manipulate stack frames manually\n- can [keep stack frames in memory](https://www.facebook.com/groups/2003630259862046/permalink/2054053404819731/) and execute them however (and *whenever*) you want\n- potential for features such as concurrency and error boundaries\n\n#### Reconciliation\n\n一种新的调和算法 (Reconciliation algorithm), reimplementation of React's core algorithm\nthe algorithm React uses to **diff** one tree with another to determine which parts need to be changed\nthe culmination of over two years of research by the React team\n\n#### Data Structure (List & Tree)\n\na plain JS object that\n\n- contains information about a component, its input, and its output\n- corresponds to a stack frame, but it also corresponds to an instance of a component\n- has an 1-to-1 relationship with a component instance (to manage work for an instance)\n\n```js\nconst fiber = {\n  stateNode // To manage its instance\n  child\n  return\n  sibling\n}\n```\n\n![image.png|275](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151445079.png)\n\n##### Important fields of a fiber\n\n| Fields                                                                                                        | For                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |\n| ------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |\n| `type` & `key`                                                                                                | The type and key of a fiber serve the same purpose as they do for React elements. (In fact, when a fiber is created from an element, these two fields are copied over directly.)<br>The `type` describes the component that it corresponds to; <br>It's the function (as in `v = f(d)`) whose execution is being tracked by the stack frame<br>The `key` is used during reconciliation to determine whether the fiber can be reused                                                                                                                                      |\n| `child` and `sibling`                                                                                         | point to other fibers, describing the **recursive tree structure** of a fiber<br>The child fibers form a singly-linked list (单向链表) whose head is the first child                                                                                                                                                                                                                                                                                                                                                                                                     |\n| `return`                                                                                                      | The return fiber is the fiber to which the program should return after processing the current one. It is conceptually the same as the return address of a stack frame. It can also be thought of as the parent fiber.<br>If a fiber has multiple child fibers, each child fiber's return fiber is the parent.                                                                                                                                                                                                                                                            |\n| `pendingProps` and `memoizedProps`                                                                            | `pendingProps` are set at the beginning of the function execution, and `memoizedProps` are set at the end.<br>When the incoming `pendingProps` are equal to `memoizedProps`, it signals that the fiber's previous output can be reused, preventing unnecessary work                                                                                                                                                                                                                                                                                                      |\n| `pendingWorkPriority` (New: FiberNode Implementations does not have any \"priorities\". instead it has \"Lanes\") | A number indicating the priority of the work represented by the fiber;<br>With the exception of `NoWork`, which is 0, a larger number indicates a lower priority.<br>The scheduler uses the priority field to search for the next unit of work to perform<br>`js<br>  /**<br>   * Each filer knows<br>   * 1. priorities for the work of itself - lanes<br>   * 2. priorities for the work of its descendant - childLanes<br>   */<br>  this.lanes = NoLanes;<br>  this.childLanes = NoLanes;<br>` <br>                                                                  |\n| `alternate`                                                                                                   | a component instance has at most two fibers that correspond to it: the current, flushed fiber, and the work-in-progress fiber;<br>The alternate of the current fiber is the work-in-progress, and the alternate of the work-in-progress is the current fiber.<br>A fiber's alternate is created lazily using a function called `cloneFiber`. Rather than always creating a new object, `cloneFiber` will attempt to reuse the fiber's alternate if it exists, minimizing allocations (Double buffering/ 改变指针指向)                                                    |\n| `output`                                                                                                      | the output of a fiber is the return value of a function<br>Every fiber eventually has output, but output is created only at the leaf nodes by **host components** (The leaf nodes of a React application. They are specific to the rendering environment (e.g., in a browser app, they are `div`, `span`, etc.)). The output is then transferred up the tree<br>The output is what is eventually given to the renderer so that it can flush the changes to the rendering environment. It's the renderer's responsibility to define how the output is created and updated |\n\nThe child fiber corresponds to the value returned by a component's `render` method. So in the following example\n\n```js\nfunction Parent() {\n  return <Child />;\n}\n```\n\nThe child fiber of `Parent` corresponds to `Child`.\nThe sibling field accounts for the case where `render` returns multiple children (a new feature in Fiber!):\n\n```js\nfunction Parent() {\n  return [<Child1 />, <Child2 />];\n}\n```\n\n### Background\n\n[zhihu.com/question/31809713/answer/53544875](https://www.zhihu.com/question/31809713/answer/53544875)\n\n#### 杀手级特性 (killer feature)\n\n- **Declarative:** React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes. Declarative views make your code more predictable, simpler to understand, and easier to debug. (make UI coding easier (declarative instead of imperative))\n- **Component-Based:** Build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep the state out of the DOM.\n- **Learn Once, Write Anywhere:** We don't make assumptions about the rest of your technology stack, so you can develop new features in React without rewriting existing code. React can also render on the server using [Node](https://nodejs.org/en) and power mobile apps using [React Native](https://reactnative.dev/).\n- The central idea of React's API is to think of updates as if they cause the entire app to re-render.\n\n#### Re-render\n\nA change in the data used to render a React app. Usually the result of `setState`. Eventually results in a re-render.\n\n#### Diff\n\n![image.png](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-diff.png)\n\n#### Reconciliation / Virtual DOM (虚拟 DOM)\n\n> Virtual DOM 是 React 的一个非常核心的技术细节，它也是前端渲染和性能的关键技术。所以，你有必要要好好学习一下这个技术的实现原理和算法。当然，前提条件是你需要学习过前面我所推荐过的浏览器的工作原理。下面是一些不错的文章可以帮你学习这一技术。\n> 虚拟 DOM（Virtual DOM）是一种 **在内存中表示真实 DOM 的数据结构**。它允许我们在内存中对 DOM 进行操作，而不是直接操作真实的 DOM。\n\n- Optimization for re-rendering\n- When the app is updated (usually via `setState`), a new tree is generated.\n- The new tree is diffed with the previous tree to compute which operations are needed to update the rendered app. ^a7iagv\n  - Different component types are assumed to generate substantially different trees. React will not attempt to diff them, but rather replace the old tree completely.\n  - Diffing of lists is performed using keys. Keys should be \"stable, predictable, and unique.\"\n\n##### Supports DOM, and iOS, Android via React Native\n\n| Reconciler                                                                                               | Renderer                                                                                                         |\n| -------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------- |\n| only 1 reconciliation algorithm when download react (-> Rewritten to **Fiber reconciliation algorithm**) | pluggable (can work with other host platform besides DOM)                                                        |\n| does the work of computing which parts of a tree have changed                                            | uses that information to actually update the rendered app                                                        |\n|                                                                                                          | React DOM and React Native can use their own renderers while sharing the same reconciler, provided by React core |\n\n##### [你知道 Virtual DOM 的工作原理吗？](https://github.com/haizlin/fe-interview/issues/655)\n\n- [为何说虚拟 DOM 会提高性能？](https://github.com/haizlin/fe-interview/issues/720)\n- [React 的虚拟 DOM 和 vue 的虚拟 DOM 有什么区别？](https://github.com/haizlin/fe-interview/issues/617)\n  虚拟 DOM 的主要优势是性能提升，原因如下：\n\n1. 减少 DOM 操作次数：真实 DOM 的操作（如创建、更新、删除元素）通常比内存操作更耗时。虚拟 DOM 允许我们在内存中进行大量操作，然后一次性将这些操作应用到真实 DOM 上，减少了对真实 DOM 的操作次数。\n2. 最小化更新范围：虚拟 DOM 结合 diff 算法，可以找出新旧虚拟 DOM 之间的差异，从而仅对有差异的部分进行真实 DOM 的更新。这可以减少不必要的 DOM 操作，提高性能。\n3. 批量更新：当有多个更改需要应用到真实 DOM 时，虚拟 DOM 可以将这些更改合并为一次更新。这有助于避免因多次操作导致的布局抖动（Layout Thrashing）和重绘，从而提高性能。\n4. 更好的跨平台兼容性：虚拟 DOM 不仅可以表示 Web 页面中的 DOM，还可以表示其他平台的 UI（例如移动应用或桌面应用）。这意味着使用虚拟 DOM 的框架（如 Vue 或 React）可以更容易地实现跨平台应用程序，而不必为每个平台编写特定的代码。  \n   虚拟 DOM 的性能提升并非绝对，它主要适用于大型应用和频繁更新的场景。对于简单的应用或更新较少的情况，虚拟 DOM 可能带来一定的开销。然而，在许多情况下，虚拟 DOM 提供了一种有效的方法来减少真实 DOM 操作，从而提高应用程序的性能。\n\n##### Pre-requisite\n\n- DOM: ![image.png|475](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406160709065.png)\n- 🏷️Browser-浏览器工作原理\n\n##### Reference\n\n- [in Depth-how-virtual-dom-is-implemented-in-react](https://angularindepth.com/posts/1501/exploring-how-virtual-dom-is-implemented-in-react)\n- [How to write your own Virtual DOM | by deathmood | Medium](https://medium.com/@deathmood/how-to-write-your-own-virtual-dom-ee74acc13060)\n- [Write your Virtual DOM 2: Props & Events | by deathmood | Medium](https://medium.com/@deathmood/write-your-virtual-dom-2-props-events-a957608f5c76)\n- [How Virtual-DOM and diffing works in React | by Gethyl George Kurian | Medium](https://medium.com/@gethylgeorge/how-virtual-dom-and-diffing-works-in-react-6fc805f9f84e)\n- [The Inner Workings Of Virtual DOM | by rajaraodv | Medium](https://rajaraodv.medium.com/the-inner-workings-of-virtual-dom-666ee7ad47cf)\n- [深度剖析：如何实现一个 Virtual DOM 算法 · Issue #13 · livoras/blog · GitHub](https://github.com/livoras/blog/issues/13)\n- 两个 Vitual-DOM 实现供你参考\n  - [GitHub - Matt-Esch/virtual-dom: A Virtual DOM and diffing algorithm](https://github.com/Matt-Esch/virtual-dom)\n  - [Maquette](https://maquettejs.org/)\n\n##### Questions\n\n- [说说 React diff 的原理是什么？](https://github.com/haizlin/fe-interview/issues/724)\n- [说说你对 React 的 reconciliation（一致化算法）的理解](https://github.com/haizlin/fe-interview/issues/870)\n- [React16 的 reconciliation 和 commit 分别是什么？](https://github.com/haizlin/fe-interview/issues/711)\n\n### Goal of Fiber\n\nincrease react core algorithm's suitability for areas like animation, layout, and gestures\n**incremental rendering**: the ability to split rendering work into chunks and spread it out over multiple frames\n\n#### the ability to pause, abort, or reuse work as new updates come in\n\n- pause work and come back to it later.\n- reuse previously completed work.\n- abort work if it's no longer needed.\n\n#### the ability to assign priority to different types of updates\n\n### How Fiber works\n\n- how the **scheduler** finds the next unit of work to perform.\n- how **priority** is tracked and propagated through the fiber tree.\n- how the scheduler knows when to pause and resume work.\n- how work is flushed and marked as complete.\n- how side-effects (such as lifecycle methods) work.\n- what a coroutine is and how it can be used to implement features like context and layout.\n\n#### Comparison with old reconciler\n\n| Previous (Stack) Reconciler                                                                                                                        | Fiber Reconciler                                                                                                                                | How optimization happens                                                                                                                                                                                                                                                                                                                                                                                                |\n| -------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| element > instance > Dom node                                                                                                                      |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n| React walks the tree recursively and calls render functions of the whole updated tree during a single tick (main thread gets stuck)                | be able to break up & schedule high priority work to be handled before low priority work (start delaying some updates to avoid dropping frames) | Current Tree & workInProgress Tree                                                                                                                                                                                                                                                                                                                                                                                      |\n| ![image.png                                                                                                                                        | 200](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151436374.png)<br>                                                        | ![image.png                                                                                                                                                                                                                                                                                                                                                                                                             | 400](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/202406151437675.png)<br> | **Phases**: <br>P1: render/ reconciliation (can be interrupted)<br>- `componentWillMount`<br>- `componentWillReceiveProps`<br>- `shouldComponentUpate`<br>- `componentWillUpdate`<br>P2: commit (can not be interrupted)<br>- `componentDidMount`<br>- `componentDidUpdate`<br>- `componentWillUnmount` |\n| make changes to the DOM node immediately when changes detected (before other updates are computed/ before calling render on other bottom elements) | Why? to avoid change DOM directly while computing changes to the tree                                                                           | **Schedule updates**: `requestIdleCallback()` <br>- Browser will let React know how much idle time it has to spare to commit updates<br>**work loop**: <br>- **next unit of work**: HostRoot (starts from HostRoot, <br> - if no updates it's gonna clone the node then continues to check its child )<br> - if updates exits, it's gonna tag the change to the workInProgress tree node<br>- **time remaining**: 13 ms |\n|                                                                                                                                                    | Enable error boundary                                                                                                                           | **Double buffering**: <br>when updates completed, react will switch pointer to the current tree and workInProgress tree                                                                                                                                                                                                                                                                                                 |\n|                                                                                                                                                    | Higher priority work will be handled before lower priority work                                                                                 | **Priority**<br>- High Priority: UI changes<br>- Low Priority: Data content changes from server <br>**Cooperative scheduling**<br>- Break work into small pieces of task, so that it can be paused                                                                                                                                                                                                                      |\n| render a single tree                                                                                                                               | steaming rendering                                                                                                                              |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n|                                                                                                                                                    | handle work in parallel                                                                                                                         | Split branches of the tree                                                                                                                                                                                                                                                                                                                                                                                              |\n|                                                                                                                                                    |                                                                                                                                                 |                                                                                                                                                                                                                                                                                                                                                                                                                         |\n\n#### Chunking（分包）\n\nFiber 架构把渲染工作拆分成了多个小块（chunks）。每个 Fiber 节点代表了一个工作单元。React 渲染时，会按顺序遍历 Fiber 树中的节点，执行与每个节点相关的工作。\n![image.png](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/react-fiber.png)\n\n#### Double Buffering (双缓冲)\n\nReact 在内存中维护了两个树结构：当前的树和正在工作的树。这使得 React 可以在用户不可见的地方进行工作，并且只有当工作完成并且整个树都准备好更新时，才会进行提交。\n\n\x3c!-- ![diff](react-internal%201.md#^a7iagv) --\x3e\n\n#### Priority\n\n[react/packages/scheduler/src/SchedulerPriorities.js at main · facebook/react · GitHub](https://github.com/facebook/react/blob/main/packages/scheduler/src/SchedulerPriorities.js)\n\n- Different types of updates have different priorities — an animation update needs to complete more quickly than, say, an update from a data store.\n- **Immediate Priority**：用于不能等待的工作，比如由用户输入或动画触发的更新。\n- **User Blocking Priority**：用于可能阻塞用户操作的工作。\n- **Normal Priority**：用于正常的数据抓取、DOM 更新等。\n- **Low Priority**：用于不急迫的任务，可以推迟的工作，如日志记录。\n- **Idle Priority**：用于完全不紧急的任务，只有在主线程空闲时才执行，如离屏渲染。\n\n#### Scheduler (调度器) / Concurrent Mode (并发模式)\n\n> it's not necessary for every update to be applied immediately\n\nUnlike a push-based approach which requires the app (you, the programmer) to decide how to schedule work. A pull-based approach allows the framework (React) to be smart and make those decisions for you.\n_scheduling_\nthe process of determining when work should be performed.\n_work_\nany computations that must be performed. Work is usually the result of an update (e.g. `setState`).\n [here](https://github.com/facebook/react/blob/340bfd9393e8173adca5380e6587e1ea1a23cefa/packages/shared/ReactWorkTags.js?source=post_page---------------------------#L29-L28) you can see all types of work targets in Fiber\n\n##### MessageChannel\n\n`MessageChannel` API 可以创建一个新的消息通道，并通过它的两个`MessagePort`属性发送数据。在 React 的任务调度器中，使用`MessageChannel`主要是为了实现一种可以跨浏览器和环境持续运行的“微任务”调度。\n使用`MessageChannel`可以使得 React 在处理如输入事件之后尽快调度更新，因为它可以将任务排队为微任务，这些微任务将在当前宏任务结束后尽快执行，但在下一个宏任务开始之前执行\n\n##### Time Slicing（时间分片）\n\nReact 使用浏览器的`requestIdleCallback`和`requestAnimationFrame`API 来执行时间分片。使用`requestIdleCallback`可以让 React 在浏览器空闲时执行低优先级的更新，而`requestAnimationFrame`则用于高优先级的更新，如动画。 ^u64q5e\nReact 将更新分解成小的任务单元。每个任务单元在执行时都会检查是否还有剩余时间，如果没有，就将控制权交还给浏览器。这样可以让 React 在执行大量工作时仍然能够响应用户的交互。\n\n###### 实现功能\n\nnon-blocking rendering\napplying updates based on the priority\npre-rendering content in the background\n\n#### 使用 Concurrent Mode\n\n为了启用 Concurrent Mode，你需要使用`React.createRoot`代替`ReactDOM.render`来创建根节点\n\n```jsx\nimport React from \"react\";\nimport ReactDOM from \"react-dom\";\nconst root = ReactDOM.createRoot(document.getElementById(\"root\"));\nroot.render(<App />);\n```\n\n#### [React Fiber 它的目的是解决什么问题？](https://github.com/haizlin/fe-interview/issues/858)\n\n#### [说说你对 Fiber 架构的理解](https://github.com/haizlin/fe-interview/issues/700)\n\n- [Inside Fiber: in-depth overview of the new reconciliation algorithm in React | by Max Koretskyi | React In Depth | Medium](https://medium.com/react-in-depth/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react-e1c04700ef6e)\n- [in Depth-inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react](https://angularindepth.com/posts/1008/inside-fiber-in-depth-overview-of-the-new-reconciliation-algorithm-in-react)\n- [in Depth-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree](https://angularindepth.com/posts/1007/the-how-and-why-on-reacts-usage-of-linked-list-in-fiber-to-walk-the-components-tree)\n\n### React 18 批处理\n\n在 React 18 中，自动批处理被扩展到更多的场景，包括：\n\n- **Promise 的解决和拒绝处理程序**：在异步代码中，例如 Promise 链或 async/await 函数中的状态更新现在也会自动批处理。\n- **setTimeout 和 setInterval 回调**：使用这些定时器函数的回调中的状态更新现在也会被批处理。\n- **原生事件处理程序**：在非 React 合成事件的监听器中进行的状态更新也会被批处理。\n- **任何其他事件循环中的事件处理**：几乎所有的状态更新，不管它们来源于什么，只要它们在同一个事件循环中，都会被自动批处理。\n  React 18 批处理自动批处理的工作原理是 React 在执行更新时采用了一种懒惰的方式，它会将多个更新累积起来，然后一次性应用这些更新，而不是对每个更新立即进行重新渲染。这减少了重复的工作和不必要的 DOM 更新，从而提高了性能。\n\n```jsx\n// 假设我们有两个状态更新函数\nconst [count, setCount] = useState(0);\nconst [flag, setFlag] = useState(false);\n// 在 React 17 中，这些更新会导致两次重新渲染\nsetTimeout(() => {\n  setCount((c) => c + 1); // 1st re-render\n  setFlag((f) => !f); // 2nd re-render\n}, 1000);\n// 在 React 18 中，这些更新会被自动批处理为一次重新渲染\nsetTimeout(() => {\n  setCount((c) => c + 1); // Both updates are batched\n  setFlag((f) => !f); // into a single re-render\n}, 1000);\n```\n\n#### 选择性批处理\n\nReact 18 提供了 `flushSync` 函数，允许你选择性地退出批处理，可以确保在回调中的更新立即被应用，触发同步的重新渲染\n\n```jsx\nimport { flushSync } from \"react-dom\";\n// 在 flushSync 的回调中的更新不会批处理\nflushSync(() => {\n  setCount((c) => c + 1); // These updates are\n});\nflushSync(() => {\n  setFlag((f) => !f); // applied immediately\n});\n```\n\n## Questions\n\n#### [简要描述下你知道的 React 工作原理是什么？](https://github.com/haizlin/fe-interview/issues/611)\n\n#### [你阅读了几遍 React 的源码？都有哪些收获？你是怎么阅读的？](https://github.com/haizlin/fe-interview/issues/879)\n\n#### [你阅读过 React 的源码吗？简要说下它的执行流程](https://github.com/haizlin/fe-interview/issues/654)\n\n#### [React 怎么拿到组件对应的 DOM 元素？](https://github.com/haizlin/fe-interview/issues/663)\n\n#### 讲一下 react 状态发生变化触发视图更新的链路\n\n##### 1. 状态更新\n\n这个过程通常从一个状态更新开始。这可能是由于 `setState`、`useState` 的 setter 函数或 `useReducer` 的 dispatch 调用引起的。\n当状态更新被触发时，React 会将该组件标记为需要更新。\n\n##### 2. 调度更新\n\nReact 的调度器接收到更新请求，并根据其优先级决定何时执行更新。在 Concurrent Mode 下，React 可能会根据任务的紧急程度和浏览器的空闲时间来推迟或中断更新。\n\n##### 3. 协调（Reconciliation）\n\n协调过程开始时，React 会为当前的更新创建一个工作单元，并开始遍历组件树（也称为 Fiber 树）。\n\n1. **比较阶段**：React 会比较新的组件状态和上一次渲染的状态，计算出实际需要变更的部分。\n2. **生成 Fiber 树**：React 为渲染中的每个组件创建或更新 Fiber 节点。Fiber 是 React 用于跟踪组件树中的每个组件状态和结构的内部数据结构。\n\n##### 4. 渲染\n\n在协调过程中，React 为组件调用渲染函数（例如，函数组件本身或类组件的 `render` 方法），生成新的虚拟 DOM（React 元素）。\n\n##### 5. 提交\n\n当协调完成并且 React 准备好应用变更到实际 DOM 时，它会执行提交阶段。\n\n1. **执行副作用**：在提交阶段，React 会执行 `useEffect`、`useLayoutEffect` 等 Hook 中的副作用函数。\n2. **更新 DOM**：React 将更新计算出来的变更应用到实际的 DOM 上。这可能包括属性的更新、元素的添加或删除等。\n3. **引用赋值**：React 会更新需要变更的组件的引用，例如将 DOM 节点赋值给通过 `useRef` 创建的 Refs。\n\n##### 6. 清理与通知\n\n最后，React 清理之前渲染的状态、执行副作用的清理函数，并在需要时通知组件更新完成。这是一个清理并使系统保持最新状态的过程。\n\n##### 思考\n\n整个过程是高度优化的，涉及到了一系列复杂的内部机制。React 使用了如 Fiber 架构、双缓冲、时间切片等技术，使得即使在大规模的更新中也能保持高性能并避免阻塞主线程。\n在实践中，React 开发者不需要深入了解所有内部细节，但理解状态更新和视图更新之间的基本链路对于编写高效且符合预期的代码是非常有帮助的。\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"react-internal",text:"React Internal#"},{depth:2,slug:"reverse-engineering",text:"Reverse Engineering#"},{depth:2,slug:"fiber",text:"Fiber#"},{depth:3,slug:"what-is-fiber",text:"What is Fiber#"},{depth:4,slug:"why-this-name-fiber",text:"Why this name “Fiber”#"},{depth:4,slug:"reconciliation",text:"Reconciliation#"},{depth:4,slug:"data-structure-list--tree",text:"Data Structure (List & Tree)#"},{depth:5,slug:"important-fields-of-a-fiber",text:"Important fields of a fiber#"},{depth:3,slug:"background",text:"Background#"},{depth:4,slug:"杀手级特性-killer-feature",text:"杀手级特性 (killer feature)#"},{depth:4,slug:"re-render",text:"Re-render#"},{depth:4,slug:"diff",text:"Diff#"},{depth:4,slug:"reconciliation--virtual-dom-虚拟-dom",text:"Reconciliation / Virtual DOM (虚拟 DOM)#"},{depth:5,slug:"supports-dom-and-ios-android-via-react-native",text:"Supports DOM, and iOS, Android via React Native#"},{depth:5,slug:"你知道-virtual-dom-的工作原理吗",text:"你知道 Virtual DOM 的工作原理吗？#"},{depth:5,slug:"pre-requisite",text:"Pre-requisite#"},{depth:5,slug:"reference",text:"Reference#"},{depth:5,slug:"questions",text:"Questions#"},{depth:3,slug:"goal-of-fiber",text:"Goal of Fiber#"},{depth:4,slug:"the-ability-to-pause-abort-or-reuse-work-as-new-updates-come-in",text:"the ability to pause, abort, or reuse work as new updates come in#"},{depth:4,slug:"the-ability-to-assign-priority-to-different-types-of-updates",text:"the ability to assign priority to different types of updates#"},{depth:3,slug:"how-fiber-works",text:"How Fiber works#"},{depth:4,slug:"comparison-with-old-reconciler",text:"Comparison with old reconciler#"},{depth:4,slug:"chunking分包",text:"Chunking（分包）#"},{depth:4,slug:"double-buffering-双缓冲",text:"Double Buffering (双缓冲)#"},{depth:4,slug:"priority",text:"Priority#"},{depth:4,slug:"scheduler-调度器--concurrent-mode-并发模式",text:"Scheduler (调度器) / Concurrent Mode (并发模式)#"},{depth:5,slug:"messagechannel",text:"MessageChannel#"},{depth:5,slug:"time-slicing时间分片",text:"Time Slicing（时间分片）#"},{depth:6,slug:"实现功能",text:"实现功能#"},{depth:4,slug:"使用-concurrent-mode",text:"使用 Concurrent Mode#"},{depth:4,slug:"react-fiber-它的目的是解决什么问题",text:"React Fiber 它的目的是解决什么问题？#"},{depth:4,slug:"说说你对-fiber-架构的理解",text:"说说你对 Fiber 架构的理解#"},{depth:3,slug:"react-18-批处理",text:"React 18 批处理#"},{depth:4,slug:"选择性批处理",text:"选择性批处理#"},{depth:2,slug:"questions-1",text:"Questions#"},{depth:4,slug:"简要描述下你知道的-react-工作原理是什么",text:"简要描述下你知道的 React 工作原理是什么？#"},{depth:4,slug:"你阅读了几遍-react-的源码都有哪些收获你是怎么阅读的",text:"你阅读了几遍 React 的源码？都有哪些收获？你是怎么阅读的？#"},{depth:4,slug:"你阅读过-react-的源码吗简要说下它的执行流程",text:"你阅读过 React 的源码吗？简要说下它的执行流程#"},{depth:4,slug:"react-怎么拿到组件对应的-dom-元素",text:"React 怎么拿到组件对应的 DOM 元素？#"},{depth:4,slug:"讲一下-react-状态发生变化触发视图更新的链路",text:"讲一下 react 状态发生变化触发视图更新的链路#"},{depth:5,slug:"1-状态更新",text:"1. 状态更新#"},{depth:5,slug:"2-调度更新",text:"2. 调度更新#"},{depth:5,slug:"3-协调reconciliation",text:"3. 协调（Reconciliation）#"},{depth:5,slug:"4-渲染",text:"4. 渲染#"},{depth:5,slug:"5-提交",text:"5. 提交#"},{depth:5,slug:"6-清理与通知",text:"6. 清理与通知#"},{depth:5,slug:"思考",text:"思考#"}]}const Content=createComponent(((e,n,t)=>{const{layout:a,...r}=frontmatter;return r.file=file,r.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),reactInternal=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,reactInternal,slug};