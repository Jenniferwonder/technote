import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/hooks/useMemo.md",collection="posts",slug="front-end-frameworks/react/hooks/usememo",body='\n# useMemo\n\n[How to useMemo and useCallback: you can remove most of them | by Nadia Makarevich | Medium](https://adevnadia.medium.com/how-to-usememo-and-usecallback-you-can-remove-most-of-them-b8ef01b2020d)\n\n## Why\n\n`useMemo` is a React Hook that lets you cache the result of a calculation between re-renders  \n✅ If the overall logged time adds up to a significant amount (say, `1ms` or more), and its dependencies rarely change, it might make sense to memorize that calculation\n\n```js\nconsole.time("filter array");\nconst visibleTodos = useMemo(() => {\n\treturn filterTodos(todos, tab); // Skipped if todos and tab haven\'t changed\n}, [todos, tab]);\nconsole.timeEnd("filter array");\n```\n\n✅❓ You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn\'t changed. Memorization lets your component re-render only when dependencies aren\'t the same  \n✅❓ The value you\'re passing is later used as a dependency of some Hook. For example, maybe another `useMemo` calculation value depends on it. Or maybe you are depending on this value from [`useEffect`](https://react.dev/reference/react/useEffect)  \n✅ If a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memorization, and add memorization where needed  \n❌ **You should only rely on `useMemo` as a performance optimization.** If your code doesn\'t work without it, find the underlying problem and fix it first. Then you may add `useMemo` to improve performance.  \n❌ `useMemo` won\'t make the _first_ render faster. It only helps you skip unnecessary work on updates\n\n### Approaches to make memorization unnecessary\n\n✅ When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render  \n✅ Prefer local state and don\'t [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary  \n✅ Keep your [rendering logic pure](https://react.dev/learn/keeping-components-pure)  \n✅ Avoid [unnecessary Effects that update state](https://react.dev/learn/you-might-not-need-an-effect)  \n✅ Try to [remove unnecessary dependencies from your Effects](https://react.dev/learn/removing-effect-dependencies)\n\n## Basics\n\n`const cachedValue = useMemo(calculateValue, dependencies)`\n\n### Parameters\n\n#### 1. `calculateValue`\n\n- The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type\n- React will call your function during the initial render. On next renders, React will return the same value again if the `dependencies` have not changed since the last render. Otherwise, it will call `calculateValue`, return its result, and store it so it can be reused later\n\n#### 1. `dependencies`:\n\n- The list of all reactive values referenced inside of the `calculateValue` code.\n\n### Return\n\nOn the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.  \nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call `calculateValue` again, and return the result that `calculateValue` has returned\n\n## Use Case\n\n#### Skipping re-rendering with `useMemo` and `memo`\n\n📌 MemoToDo.jsx  \n📌 RecalToDo.jsx\n\n#### Memorizing a dependency of another Hook\n\nhave a calculation that depends on an object created directly in the component body;  \n✅ To fix this, you could memorize the object _itself_ before passing it as a dependency\n\n```jsx\nfunction Dropdown({ allItems, text }) {\n\tconst searchOptions = useMemo(() => {\n\t\treturn { matchMode: \'whole-word\', text };\n\t}, [text]); // ✅ Only changes when text changes\n\tconst visibleItems = useMemo(() => {\n\t\treturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes\n// ...\n```\n\n✅ an even better fix is to move the `searchOptions` object declaration _inside_ of the `useMemo` calculation function\n\n```jsx\nfunction Dropdown({ allItems, text }) {\nconst visibleItems = useMemo(() => {\n\tconst searchOptions = { matchMode: \'whole-word\', text };\n\treturn searchItems(allItems, searchOptions);\n}, [allItems, text]); // ✅ Only changes when allItems or text changes\n// ...\n```\n\n#### Memorizing a function\n\n💡 Just as `{}` creates a different object, function declarations like `function() {}` and expressions like `() => {}` produce a _different_ function on every re-render  \n❌ To memorize a function with `useMemo`, your calculation function would have to return another function\n\n```jsx\nexport default function Page({ productId, referrer }) {\n\tconst handleSubmit = useMemo(() => {\n\t\treturn (orderDetails) => {\n\t\t\tpost("/product/" + productId + "/buy", {\n\t\t\t\treferrer,\n\t\t\t\torderDetails,\n\t\t\t});\n\t\t};\n\t}, [productId, referrer]);\n\treturn <Form onSubmit={handleSubmit} />;\n}\n```\n\n✅ **Wrap your functions into [`useCallback`](https://react.dev/reference/react/useCallback) instead of `useMemo`** to avoid having to write an extra nested function\n\n```jsx\nexport default function Page({ productId, referrer }) {\n\tconst handleSubmit = useCallback(\n\t\t(orderDetails) => {\n\t\t\tpost("/product/" + productId + "/buy", {\n\t\t\t\treferrer,\n\t\t\t\torderDetails,\n\t\t\t});\n\t\t},\n\t\t[productId, referrer]\n\t);\n\treturn <Form onSubmit={handleSubmit} />;\n}\n```\n\n## Questions\n\n[怎样实现 React 组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n',data={title:"useMemo",DateStarted:new Date(17095968e5),tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/hooks/useMemo.md",rawData:void 0},html='<h1 id="usememo">useMemo<a class="anchor" href="#usememo"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<p><a href="https://adevnadia.medium.com/how-to-usememo-and-usecallback-you-can-remove-most-of-them-b8ef01b2020d">How to useMemo and useCallback: you can remove most of them | by Nadia Makarevich | Medium</a></p>\n<h2 id="why">Why<a class="anchor" href="#why"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p><code>useMemo</code> is a React Hook that lets you cache the result of a calculation between re-renders<br>\n✅ If the overall logged time adds up to a significant amount (say, <code>1ms</code> or more), and its dependencies rarely change, it might make sense to memorize that calculation</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">time</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"filter array"</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> visibleTodos</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#B392F0"> filterTodos</span><span style="color:#E1E4E8">(todos, tab); </span><span style="color:#6A737D">// Skipped if todos and tab haven\'t changed</span></span>\n<span class="line"><span style="color:#E1E4E8">}, [todos, tab]);</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">timeEnd</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"filter array"</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"></span></code></pre>\n<p>✅❓ You pass it as a prop to a component wrapped in <a href="https://react.dev/reference/react/memo"><code>memo</code>.</a> You want to skip re-rendering if the value hasn’t changed. Memorization lets your component re-render only when dependencies aren’t the same<br>\n✅❓ The value you’re passing is later used as a dependency of some Hook. For example, maybe another <code>useMemo</code> calculation value depends on it. Or maybe you are depending on this value from <a href="https://react.dev/reference/react/useEffect"><code>useEffect</code></a><br>\n✅ If a specific interaction still feels laggy, <a href="https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html">use the React Developer Tools profiler</a> to see which components would benefit the most from memorization, and add memorization where needed<br>\n❌ <strong>You should only rely on <code>useMemo</code> as a performance optimization.</strong> If your code doesn’t work without it, find the underlying problem and fix it first. Then you may add <code>useMemo</code> to improve performance.<br>\n❌ <code>useMemo</code> won’t make the <em>first</em> render faster. It only helps you skip unnecessary work on updates</p>\n<h3 id="approaches-to-make-memorization-unnecessary">Approaches to make memorization unnecessary<a class="anchor" href="#approaches-to-make-memorization-unnecessary"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>✅ When a component visually wraps other components, let it <a href="https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children">accept JSX as children.</a> This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render<br>\n✅ Prefer local state and don’t <a href="https://react.dev/learn/sharing-state-between-components">lift state up</a> any further than necessary<br>\n✅ Keep your <a href="https://react.dev/learn/keeping-components-pure">rendering logic pure</a><br>\n✅ Avoid <a href="https://react.dev/learn/you-might-not-need-an-effect">unnecessary Effects that update state</a><br>\n✅ Try to <a href="https://react.dev/learn/removing-effect-dependencies">remove unnecessary dependencies from your Effects</a></p>\n<h2 id="basics">Basics<a class="anchor" href="#basics"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p><code>const cachedValue = useMemo(calculateValue, dependencies)</code></p>\n<h3 id="parameters">Parameters<a class="anchor" href="#parameters"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="1-calculatevalue">1. <code>calculateValue</code><a class="anchor" href="#1-calculatevalue"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type</li>\n<li>React will call your function during the initial render. On next renders, React will return the same value again if the <code>dependencies</code> have not changed since the last render. Otherwise, it will call <code>calculateValue</code>, return its result, and store it so it can be reused later</li>\n</ul>\n<h4 id="1-dependencies">1. <code>dependencies</code>:<a class="anchor" href="#1-dependencies"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>The list of all reactive values referenced inside of the <code>calculateValue</code> code.</li>\n</ul>\n<h3 id="return">Return<a class="anchor" href="#return"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>On the initial render, <code>useMemo</code> returns the result of calling <code>calculateValue</code> with no arguments.<br>\nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call <code>calculateValue</code> again, and return the result that <code>calculateValue</code> has returned</p>\n<h2 id="use-case">Use Case<a class="anchor" href="#use-case"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="skipping-re-rendering-withusememoandmemo">Skipping re-rendering with <code>useMemo</code> and <code>memo</code><a class="anchor" href="#skipping-re-rendering-withusememoandmemo"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>📌 MemoToDo.jsx<br>\n📌 RecalToDo.jsx</p>\n<h4 id="memorizing-a-dependency-of-another-hook">Memorizing a dependency of another Hook<a class="anchor" href="#memorizing-a-dependency-of-another-hook"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>have a calculation that depends on an object created directly in the component body;<br>\n✅ To fix this, you could memorize the object <em>itself</em> before passing it as a dependency</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Dropdown</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">allItems</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">text</span><span style="color:#E1E4E8"> }) {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> searchOptions</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> { matchMode: </span><span style="color:#9ECBFF">\'whole-word\'</span><span style="color:#E1E4E8">, text };</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}, [text]); </span><span style="color:#6A737D">// ✅ Only changes when text changes</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> visibleItems</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#B392F0"> searchItems</span><span style="color:#E1E4E8">(allItems, searchOptions);</span></span>\n<span class="line"><span style="color:#E1E4E8">}, [allItems, searchOptions]); </span><span style="color:#6A737D">// ✅ Only changes when allItems or searchOptions changes</span></span>\n<span class="line"><span style="color:#6A737D">// ...</span></span>\n<span class="line"></span></code></pre>\n<p>✅ an even better fix is to move the <code>searchOptions</code> object declaration <em>inside</em> of the <code>useMemo</code> calculation function</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Dropdown</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">allItems</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">text</span><span style="color:#E1E4E8"> }) {</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> visibleItems</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> searchOptions</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> { matchMode: </span><span style="color:#9ECBFF">\'whole-word\'</span><span style="color:#E1E4E8">, text };</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#B392F0"> searchItems</span><span style="color:#E1E4E8">(allItems, searchOptions);</span></span>\n<span class="line"><span style="color:#E1E4E8">}, [allItems, text]); </span><span style="color:#6A737D">// ✅ Only changes when allItems or text changes</span></span>\n<span class="line"><span style="color:#6A737D">// ...</span></span>\n<span class="line"></span></code></pre>\n<h4 id="memorizing-a-function">Memorizing a function<a class="anchor" href="#memorizing-a-function"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>💡 Just as <code>{}</code> creates a different object, function declarations like <code>function() {}</code> and expressions like <code>() => {}</code> produce a <em>different</em> function on every re-render<br>\n❌ To memorize a function with <code>useMemo</code>, your calculation function would have to return another function</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> Page</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">productId</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">referrer</span><span style="color:#E1E4E8"> }) {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> handleSubmit</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useMemo</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">orderDetails</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">\t\t\tpost</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"/product/"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> productId </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "/buy"</span><span style="color:#E1E4E8">, {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t\treferrer,</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t\torderDetails,</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t};</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}, [productId, referrer]);</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#79B8FF">Form</span><span style="color:#B392F0"> onSubmit</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{handleSubmit} />;</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<p>✅ <strong>Wrap your functions into <a href="https://react.dev/reference/react/useCallback"><code>useCallback</code></a> instead of <code>useMemo</code></strong> to avoid having to write an extra nested function</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">export</span><span style="color:#F97583"> default</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> Page</span><span style="color:#E1E4E8">({ </span><span style="color:#FFAB70">productId</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">referrer</span><span style="color:#E1E4E8"> }) {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> handleSubmit</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useCallback</span><span style="color:#E1E4E8">(</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t(</span><span style="color:#FFAB70">orderDetails</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#B392F0">\t\t\tpost</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">"/product/"</span><span style="color:#F97583"> +</span><span style="color:#E1E4E8"> productId </span><span style="color:#F97583">+</span><span style="color:#9ECBFF"> "/buy"</span><span style="color:#E1E4E8">, {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t\treferrer,</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t\torderDetails,</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t},</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t[productId, referrer]</span></span>\n<span class="line"><span style="color:#E1E4E8">\t);</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#79B8FF">Form</span><span style="color:#B392F0"> onSubmit</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{handleSubmit} />;</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<h2 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p><a href="https://github.com/haizlin/fe-interview/issues/755">怎样实现 React 组件的记忆？原理是什么？</a></p>',frontmatter={title:"useMemo",topic:["Hooks"],type:"D",tags:["React"],DateStarted:"2024-03-05T00:00:00.000Z",DateModified:"2024-09-14T00:00:00.000Z",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,category:"Front-End Frameworks",minutes:3,words:693},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/hooks/useMemo.md",url=void 0;function rawContent(){return'\n# useMemo\n\n[How to useMemo and useCallback: you can remove most of them | by Nadia Makarevich | Medium](https://adevnadia.medium.com/how-to-usememo-and-usecallback-you-can-remove-most-of-them-b8ef01b2020d)\n\n## Why\n\n`useMemo` is a React Hook that lets you cache the result of a calculation between re-renders  \n✅ If the overall logged time adds up to a significant amount (say, `1ms` or more), and its dependencies rarely change, it might make sense to memorize that calculation\n\n```js\nconsole.time("filter array");\nconst visibleTodos = useMemo(() => {\n\treturn filterTodos(todos, tab); // Skipped if todos and tab haven\'t changed\n}, [todos, tab]);\nconsole.timeEnd("filter array");\n```\n\n✅❓ You pass it as a prop to a component wrapped in [`memo`.](https://react.dev/reference/react/memo) You want to skip re-rendering if the value hasn\'t changed. Memorization lets your component re-render only when dependencies aren\'t the same  \n✅❓ The value you\'re passing is later used as a dependency of some Hook. For example, maybe another `useMemo` calculation value depends on it. Or maybe you are depending on this value from [`useEffect`](https://react.dev/reference/react/useEffect)  \n✅ If a specific interaction still feels laggy, [use the React Developer Tools profiler](https://legacy.reactjs.org/blog/2018/09/10/introducing-the-react-profiler.html) to see which components would benefit the most from memorization, and add memorization where needed  \n❌ **You should only rely on `useMemo` as a performance optimization.** If your code doesn\'t work without it, find the underlying problem and fix it first. Then you may add `useMemo` to improve performance.  \n❌ `useMemo` won\'t make the _first_ render faster. It only helps you skip unnecessary work on updates\n\n### Approaches to make memorization unnecessary\n\n✅ When a component visually wraps other components, let it [accept JSX as children.](https://react.dev/learn/passing-props-to-a-component#passing-jsx-as-children) This way, when the wrapper component updates its own state, React knows that its children don’t need to re-render  \n✅ Prefer local state and don\'t [lift state up](https://react.dev/learn/sharing-state-between-components) any further than necessary  \n✅ Keep your [rendering logic pure](https://react.dev/learn/keeping-components-pure)  \n✅ Avoid [unnecessary Effects that update state](https://react.dev/learn/you-might-not-need-an-effect)  \n✅ Try to [remove unnecessary dependencies from your Effects](https://react.dev/learn/removing-effect-dependencies)\n\n## Basics\n\n`const cachedValue = useMemo(calculateValue, dependencies)`\n\n### Parameters\n\n#### 1. `calculateValue`\n\n- The function calculating the value that you want to cache. It should be pure, should take no arguments, and should return a value of any type\n- React will call your function during the initial render. On next renders, React will return the same value again if the `dependencies` have not changed since the last render. Otherwise, it will call `calculateValue`, return its result, and store it so it can be reused later\n\n#### 1. `dependencies`:\n\n- The list of all reactive values referenced inside of the `calculateValue` code.\n\n### Return\n\nOn the initial render, `useMemo` returns the result of calling `calculateValue` with no arguments.  \nDuring next renders, it will either return an already stored value from the last render (if the dependencies haven’t changed), or call `calculateValue` again, and return the result that `calculateValue` has returned\n\n## Use Case\n\n#### Skipping re-rendering with `useMemo` and `memo`\n\n📌 MemoToDo.jsx  \n📌 RecalToDo.jsx\n\n#### Memorizing a dependency of another Hook\n\nhave a calculation that depends on an object created directly in the component body;  \n✅ To fix this, you could memorize the object _itself_ before passing it as a dependency\n\n```jsx\nfunction Dropdown({ allItems, text }) {\n\tconst searchOptions = useMemo(() => {\n\t\treturn { matchMode: \'whole-word\', text };\n\t}, [text]); // ✅ Only changes when text changes\n\tconst visibleItems = useMemo(() => {\n\t\treturn searchItems(allItems, searchOptions);\n}, [allItems, searchOptions]); // ✅ Only changes when allItems or searchOptions changes\n// ...\n```\n\n✅ an even better fix is to move the `searchOptions` object declaration _inside_ of the `useMemo` calculation function\n\n```jsx\nfunction Dropdown({ allItems, text }) {\nconst visibleItems = useMemo(() => {\n\tconst searchOptions = { matchMode: \'whole-word\', text };\n\treturn searchItems(allItems, searchOptions);\n}, [allItems, text]); // ✅ Only changes when allItems or text changes\n// ...\n```\n\n#### Memorizing a function\n\n💡 Just as `{}` creates a different object, function declarations like `function() {}` and expressions like `() => {}` produce a _different_ function on every re-render  \n❌ To memorize a function with `useMemo`, your calculation function would have to return another function\n\n```jsx\nexport default function Page({ productId, referrer }) {\n\tconst handleSubmit = useMemo(() => {\n\t\treturn (orderDetails) => {\n\t\t\tpost("/product/" + productId + "/buy", {\n\t\t\t\treferrer,\n\t\t\t\torderDetails,\n\t\t\t});\n\t\t};\n\t}, [productId, referrer]);\n\treturn <Form onSubmit={handleSubmit} />;\n}\n```\n\n✅ **Wrap your functions into [`useCallback`](https://react.dev/reference/react/useCallback) instead of `useMemo`** to avoid having to write an extra nested function\n\n```jsx\nexport default function Page({ productId, referrer }) {\n\tconst handleSubmit = useCallback(\n\t\t(orderDetails) => {\n\t\t\tpost("/product/" + productId + "/buy", {\n\t\t\t\treferrer,\n\t\t\t\torderDetails,\n\t\t\t});\n\t\t},\n\t\t[productId, referrer]\n\t);\n\treturn <Form onSubmit={handleSubmit} />;\n}\n```\n\n## Questions\n\n[怎样实现 React 组件的记忆？原理是什么？](https://github.com/haizlin/fe-interview/issues/755)\n'}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"usememo",text:"useMemo#"},{depth:2,slug:"why",text:"Why#"},{depth:3,slug:"approaches-to-make-memorization-unnecessary",text:"Approaches to make memorization unnecessary#"},{depth:2,slug:"basics",text:"Basics#"},{depth:3,slug:"parameters",text:"Parameters#"},{depth:4,slug:"1-calculatevalue",text:"1. calculateValue#"},{depth:4,slug:"1-dependencies",text:"1. dependencies:#"},{depth:3,slug:"return",text:"Return#"},{depth:2,slug:"use-case",text:"Use Case#"},{depth:4,slug:"skipping-re-rendering-withusememoandmemo",text:"Skipping re-rendering with useMemo and memo#"},{depth:4,slug:"memorizing-a-dependency-of-another-hook",text:"Memorizing a dependency of another Hook#"},{depth:4,slug:"memorizing-a-function",text:"Memorizing a function#"},{depth:2,slug:"questions",text:"Questions#"}]}const Content=createComponent(((e,n,a)=>{const{layout:t,...s}=frontmatter;return s.file=file,s.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),useMemo=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,slug,useMemo};