import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/hooks/useRef.md",collection="posts",slug="front-end-frameworks/react/hooks/useref",body="\n# useRef\n\n> [useRef â€“ React](https://react.dev/reference/react/useRef)\n\n### Why\n\nWhen you want a component to â€œrememberâ€ some information, but you don't want that information to [trigger new renders](https://react.dev/learn/render-and-commit), you can use a _ref_  \nLike state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!  \nRefs are an escape hatch. You should only use them when you have to â€œstep outside Reactâ€. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose\n\n### âŒ Pitfall\n\nğŸš© Don't write a ref during rendering  \nğŸš© Don't read a ref during rendering  \nğŸš© **Do not overuse refs.** You should only use refs for _imperative_ behaviors that you can't express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on  \nâœ… You can read or write refs **from event handlers or effects instead**.\n\n### Basics\n\n`const ref = useRef(initialValue)`\n\n#### Access Ref's Current Value\n\n`ref.current`  \nThis value is intentionally mutable, meaning you can both read and write to it. Itâ€™s like a secret pocket of your component that React doesn't track. (This is what makes it an â€œescape hatchâ€ from React's one-way data flow)\n\n#### Parameter\n\n`initialValue`: The value you want the ref objectâ€™sÂ `current`Â property to be initially. It can be a value of any type. This argument is ignored after the initial render\n\n##### Avoid recreating the ref contents\n\n```js\n// âŒ Don't do this\n// the result of `new VideoPlayer()` is only used for the initial render, youâ€™re still calling this function on every render. This can be wasteful if itâ€™s creating expensive objects.\nfunction Video() {\n\tconst playerRef = useRef(new VideoPlayer());\n}\n// âœ… Do this instead\nfunction Video() {\n\tconst playerRef = useRef(null);\n\tif (playerRef.current === null) {\n\t\tplayerRef.current = new VideoPlayer();\n}\n```\n\n#### Returns\n\n`useRef` returns an object with a single property:\n\n- `current`: Initially, itâ€™s set to theÂ `initialValue`Â you have passed. You can later set it to something else. If you pass the ref object to React as aÂ `ref`Â attribute to a JSX node, React will set itsÂ `current`Â property.\n\n### Manipulate DOM with refs\n\n1. declare a ref object with an initial value of `null`:\n   - `const inputRef = useRef(null);`\n2. pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate\n   - `return <input ref={inputRef} />;`\n3. React will set the `current` property of your ref object to that DOM node\n\n```js\nfunction handleClick() {\n\tinputRef.current.focus();\n}\n```\n\n### `forwardRef`\n\n#### Exposing a ref to your own component\n\nuse a combination of `useRef` to hold the input and [`forwardRef`](https://react.dev/reference/react/forwardRef) to expose it to the parent component\n\n```jsx\nconst MyInput = forwardRef((props, ref) => {\n\treturn <input {...props} ref={ref} />;\n});\n<MyInput ref={inputRef} />;\n```\n\nIn design systems, it is a common pattern for low-level components like buttons, inputs, and so on, **to forward their refs to their DOM nodes**. On the other hand, high-level components like forms, lists, or page sections usually won't expose their DOM nodes to avoid accidental dependencies on the DOM structure\n\n## Questions\n\n#### [è¯·è¯´è¯´ä»€ä¹ˆæ˜¯ useRefï¼Ÿ](https://github.com/haizlin/fe-interview/issues/706)\n\n#### [ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨ Refsï¼Ÿ](https://github.com/haizlin/fe-interview/issues/753)\n\n#### [React ä¸­ refs çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›åº”ç”¨åœºæ™¯ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/633)\n\n#### [ä»€ä¹ˆæ˜¯ React.forwardRefï¼Ÿå®ƒæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/878)\n\n#### [ä½¿ç”¨ React çš„ memo å’Œ forwardRef åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º children ç±»å‹ä¸å¯¹ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/844)\n",data={title:"useRef",DateStarted:new Date(1712016e6),tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/hooks/useRef.md",rawData:void 0},html='<h1 id="useref">useRef<a class="anchor" href="#useref"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<blockquote>\n<p><a href="https://react.dev/reference/react/useRef">useRef â€“ React</a></p>\n</blockquote>\n<h3 id="why">Why<a class="anchor" href="#why"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>When you want a component to â€œrememberâ€ some information, but you donâ€™t want that information to <a href="https://react.dev/learn/render-and-commit">trigger new renders</a>, you can use a <em>ref</em><br>\nLike state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!<br>\nRefs are an escape hatch. You should only use them when you have to â€œstep outside Reactâ€. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose</p>\n<h3 id="-pitfall">âŒ Pitfall<a class="anchor" href="#-pitfall"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>ğŸš© Donâ€™t write a ref during rendering<br>\nğŸš© Donâ€™t read a ref during rendering<br>\nğŸš© <strong>Do not overuse refs.</strong> You should only use refs for <em>imperative</em> behaviors that you canâ€™t express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on<br>\nâœ… You can read or write refs <strong>from event handlers or effects instead</strong>.</p>\n<h3 id="basics">Basics<a class="anchor" href="#basics"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p><code>const ref = useRef(initialValue)</code></p>\n<h4 id="access-refs-current-value">Access Refâ€™s Current Value<a class="anchor" href="#access-refs-current-value"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p><code>ref.current</code><br>\nThis value is intentionally mutable, meaning you can both read and write to it. Itâ€™s like a secret pocket of your component that React doesnâ€™t track. (This is what makes it an â€œescape hatchâ€ from Reactâ€™s one-way data flow)</p>\n<h4 id="parameter">Parameter<a class="anchor" href="#parameter"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p><code>initialValue</code>: The value you want the ref objectâ€™sÂ <code>current</code>Â property to be initially. It can be a value of any type. This argument is ignored after the initial render</p>\n<h5 id="avoid-recreating-the-ref-contents">Avoid recreating the ref contents<a class="anchor" href="#avoid-recreating-the-ref-contents"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#6A737D">// âŒ Don\'t do this</span></span>\n<span class="line"><span style="color:#6A737D">// the result of `new VideoPlayer()` is only used for the initial render, youâ€™re still calling this function on every render. This can be wasteful if itâ€™s creating expensive objects.</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Video</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> playerRef</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useRef</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">new</span><span style="color:#B392F0"> VideoPlayer</span><span style="color:#E1E4E8">());</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#6A737D">// âœ… Do this instead</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> Video</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> playerRef</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> useRef</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">null</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (playerRef.current </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tplayerRef.current </span><span style="color:#F97583">=</span><span style="color:#F97583"> new</span><span style="color:#B392F0"> VideoPlayer</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<h4 id="returns">Returns<a class="anchor" href="#returns"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p><code>useRef</code> returns an object with a single property:</p>\n<ul>\n<li><code>current</code>: Initially, itâ€™s set to theÂ <code>initialValue</code>Â you have passed. You can later set it to something else. If you pass the ref object to React as aÂ <code>ref</code>Â attribute to a JSX node, React will set itsÂ <code>current</code>Â property.</li>\n</ul>\n<h3 id="manipulate-dom-with-refs">Manipulate DOM with refs<a class="anchor" href="#manipulate-dom-with-refs"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>declare a ref object with an initial value of <code>null</code>:\n<ul>\n<li><code>const inputRef = useRef(null);</code></li>\n</ul>\n</li>\n<li>pass your ref object as the <code>ref</code> attribute to the JSX of the DOM node you want to manipulate\n<ul>\n<li><code>return &#x3C;input ref={inputRef} />;</code></li>\n</ul>\n</li>\n<li>React will set the <code>current</code> property of your ref object to that DOM node</li>\n</ol>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> handleClick</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tinputRef.current.</span><span style="color:#B392F0">focus</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<h3 id="forwardref"><code>forwardRef</code><a class="anchor" href="#forwardref"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="exposing-a-ref-to-your-own-component">Exposing a ref to your own component<a class="anchor" href="#exposing-a-ref-to-your-own-component"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>use a combination of <code>useRef</code> to hold the input and <a href="https://react.dev/reference/react/forwardRef"><code>forwardRef</code></a> to expose it to the parent component</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> MyInput</span><span style="color:#F97583"> =</span><span style="color:#B392F0"> forwardRef</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">props</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">ref</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> &#x3C;</span><span style="color:#85E89D">input</span><span style="color:#E1E4E8"> {</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">props} </span><span style="color:#B392F0">ref</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{ref} />;</span></span>\n<span class="line"><span style="color:#E1E4E8">});</span></span>\n<span class="line"><span style="color:#E1E4E8">&#x3C;</span><span style="color:#79B8FF">MyInput</span><span style="color:#B392F0"> ref</span><span style="color:#F97583">=</span><span style="color:#E1E4E8">{inputRef} />;</span></span>\n<span class="line"></span></code></pre>\n<p>In design systems, it is a common pattern for low-level components like buttons, inputs, and so on, <strong>to forward their refs to their DOM nodes</strong>. On the other hand, high-level components like forms, lists, or page sections usually wonâ€™t expose their DOM nodes to avoid accidental dependencies on the DOM structure</p>\n<h2 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="è¯·è¯´è¯´ä»€ä¹ˆæ˜¯-useref"><a href="https://github.com/haizlin/fe-interview/issues/706">è¯·è¯´è¯´ä»€ä¹ˆæ˜¯ useRefï¼Ÿ</a><a class="anchor" href="#è¯·è¯´è¯´ä»€ä¹ˆæ˜¯-useref"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨-refs"><a href="https://github.com/haizlin/fe-interview/issues/753">ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨ Refsï¼Ÿ</a><a class="anchor" href="#ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨-refs"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-ä¸­-refs-çš„ä½œç”¨æ˜¯ä»€ä¹ˆæœ‰å“ªäº›åº”ç”¨åœºæ™¯"><a href="https://github.com/haizlin/fe-interview/issues/633">React ä¸­ refs çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›åº”ç”¨åœºæ™¯ï¼Ÿ</a><a class="anchor" href="#react-ä¸­-refs-çš„ä½œç”¨æ˜¯ä»€ä¹ˆæœ‰å“ªäº›åº”ç”¨åœºæ™¯"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="ä»€ä¹ˆæ˜¯-reactforwardrefå®ƒæœ‰ä»€ä¹ˆä½œç”¨"><a href="https://github.com/haizlin/fe-interview/issues/878">ä»€ä¹ˆæ˜¯ React.forwardRefï¼Ÿå®ƒæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ</a><a class="anchor" href="#ä»€ä¹ˆæ˜¯-reactforwardrefå®ƒæœ‰ä»€ä¹ˆä½œç”¨"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="ä½¿ç”¨-react-çš„-memo-å’Œ-forwardref-åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º-children-ç±»å‹ä¸å¯¹"><a href="https://github.com/haizlin/fe-interview/issues/844">ä½¿ç”¨ React çš„ memo å’Œ forwardRef åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º children ç±»å‹ä¸å¯¹ï¼Ÿ</a><a class="anchor" href="#ä½¿ç”¨-react-çš„-memo-å’Œ-forwardref-åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º-children-ç±»å‹ä¸å¯¹"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>',frontmatter={topic:["Hooks"],type:"D",tags:["React"],DateStarted:"2024-04-02T00:00:00.000Z",DateModified:"2024-09-14T00:00:00.000Z",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,title:"useRef",category:"Front-End Frameworks",minutes:3,words:525},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/hooks/useRef.md",url=void 0;function rawContent(){return"\n# useRef\n\n> [useRef â€“ React](https://react.dev/reference/react/useRef)\n\n### Why\n\nWhen you want a component to â€œrememberâ€ some information, but you don't want that information to [trigger new renders](https://react.dev/learn/render-and-commit), you can use a _ref_  \nLike state, refs are retained by React between re-renders. However, setting state re-renders a component. Changing a ref does not!  \nRefs are an escape hatch. You should only use them when you have to â€œstep outside Reactâ€. Common examples of this include managing focus, scroll position, or calling browser APIs that React does not expose\n\n### âŒ Pitfall\n\nğŸš© Don't write a ref during rendering  \nğŸš© Don't read a ref during rendering  \nğŸš© **Do not overuse refs.** You should only use refs for _imperative_ behaviors that you can't express as props: for example, scrolling to a node, focusing a node, triggering an animation, selecting text, and so on  \nâœ… You can read or write refs **from event handlers or effects instead**.\n\n### Basics\n\n`const ref = useRef(initialValue)`\n\n#### Access Ref's Current Value\n\n`ref.current`  \nThis value is intentionally mutable, meaning you can both read and write to it. Itâ€™s like a secret pocket of your component that React doesn't track. (This is what makes it an â€œescape hatchâ€ from React's one-way data flow)\n\n#### Parameter\n\n`initialValue`: The value you want the ref objectâ€™sÂ `current`Â property to be initially. It can be a value of any type. This argument is ignored after the initial render\n\n##### Avoid recreating the ref contents\n\n```js\n// âŒ Don't do this\n// the result of `new VideoPlayer()` is only used for the initial render, youâ€™re still calling this function on every render. This can be wasteful if itâ€™s creating expensive objects.\nfunction Video() {\n\tconst playerRef = useRef(new VideoPlayer());\n}\n// âœ… Do this instead\nfunction Video() {\n\tconst playerRef = useRef(null);\n\tif (playerRef.current === null) {\n\t\tplayerRef.current = new VideoPlayer();\n}\n```\n\n#### Returns\n\n`useRef` returns an object with a single property:\n\n- `current`: Initially, itâ€™s set to theÂ `initialValue`Â you have passed. You can later set it to something else. If you pass the ref object to React as aÂ `ref`Â attribute to a JSX node, React will set itsÂ `current`Â property.\n\n### Manipulate DOM with refs\n\n1. declare a ref object with an initial value of `null`:\n   - `const inputRef = useRef(null);`\n2. pass your ref object as the `ref` attribute to the JSX of the DOM node you want to manipulate\n   - `return <input ref={inputRef} />;`\n3. React will set the `current` property of your ref object to that DOM node\n\n```js\nfunction handleClick() {\n\tinputRef.current.focus();\n}\n```\n\n### `forwardRef`\n\n#### Exposing a ref to your own component\n\nuse a combination of `useRef` to hold the input and [`forwardRef`](https://react.dev/reference/react/forwardRef) to expose it to the parent component\n\n```jsx\nconst MyInput = forwardRef((props, ref) => {\n\treturn <input {...props} ref={ref} />;\n});\n<MyInput ref={inputRef} />;\n```\n\nIn design systems, it is a common pattern for low-level components like buttons, inputs, and so on, **to forward their refs to their DOM nodes**. On the other hand, high-level components like forms, lists, or page sections usually won't expose their DOM nodes to avoid accidental dependencies on the DOM structure\n\n## Questions\n\n#### [è¯·è¯´è¯´ä»€ä¹ˆæ˜¯ useRefï¼Ÿ](https://github.com/haizlin/fe-interview/issues/706)\n\n#### [ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨ Refsï¼Ÿ](https://github.com/haizlin/fe-interview/issues/753)\n\n#### [React ä¸­ refs çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›åº”ç”¨åœºæ™¯ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/633)\n\n#### [ä»€ä¹ˆæ˜¯ React.forwardRefï¼Ÿå®ƒæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/878)\n\n#### [ä½¿ç”¨ React çš„ memo å’Œ forwardRef åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º children ç±»å‹ä¸å¯¹ï¼Ÿ](https://github.com/haizlin/fe-interview/issues/844)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"useref",text:"useRef#"},{depth:3,slug:"why",text:"Why#"},{depth:3,slug:"-pitfall",text:"âŒ Pitfall#"},{depth:3,slug:"basics",text:"Basics#"},{depth:4,slug:"access-refs-current-value",text:"Access Refâ€™s Current Value#"},{depth:4,slug:"parameter",text:"Parameter#"},{depth:5,slug:"avoid-recreating-the-ref-contents",text:"Avoid recreating the ref contents#"},{depth:4,slug:"returns",text:"Returns#"},{depth:3,slug:"manipulate-dom-with-refs",text:"Manipulate DOM with refs#"},{depth:3,slug:"forwardref",text:"forwardRef#"},{depth:4,slug:"exposing-a-ref-to-your-own-component",text:"Exposing a ref to your own component#"},{depth:2,slug:"questions",text:"Questions#"},{depth:4,slug:"è¯·è¯´è¯´ä»€ä¹ˆæ˜¯-useref",text:"è¯·è¯´è¯´ä»€ä¹ˆæ˜¯ useRefï¼Ÿ#"},{depth:4,slug:"ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨-refs",text:"ä¸ºä»€ä¹ˆå»ºè®®ä¸è¦è¿‡åº¦ä½¿ç”¨ Refsï¼Ÿ#"},{depth:4,slug:"react-ä¸­-refs-çš„ä½œç”¨æ˜¯ä»€ä¹ˆæœ‰å“ªäº›åº”ç”¨åœºæ™¯",text:"React ä¸­ refs çš„ä½œç”¨æ˜¯ä»€ä¹ˆï¼Ÿæœ‰å“ªäº›åº”ç”¨åœºæ™¯ï¼Ÿ#"},{depth:4,slug:"ä»€ä¹ˆæ˜¯-reactforwardrefå®ƒæœ‰ä»€ä¹ˆä½œç”¨",text:"ä»€ä¹ˆæ˜¯ React.forwardRefï¼Ÿå®ƒæœ‰ä»€ä¹ˆä½œç”¨ï¼Ÿ#"},{depth:4,slug:"ä½¿ç”¨-react-çš„-memo-å’Œ-forwardref-åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º-children-ç±»å‹ä¸å¯¹",text:"ä½¿ç”¨ React çš„ memo å’Œ forwardRef åŒ…è£…çš„ç»„ä»¶ä¸ºä»€ä¹ˆæç¤º children ç±»å‹ä¸å¯¹ï¼Ÿ#"}]}const Content=createComponent(((e,n,t)=>{const{layout:a,...s}=frontmatter;return s.file=file,s.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),useRef=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,slug,useRef};