import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726310608649/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/react-mini-app/tic-tac-toe.md",collection="posts",slug="front-end-frameworks/react/react-mini-app/tic-tac-toe",body='\n# Tic-Tac-Toe\n\n## Build _Tic-Tac-Toe_\n### ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Demo-tic-tac-toe.png)\n\n## 📌*Square*\n\n### Display the value of each square\n\n### Respond to Click event\n\n## 📌*Board*\n\n### 🛠️Store Array in `useState`\n\n- To store 9 squares value (X/O) in state\n  - `const [squares, setSquares] = useState(Array(9).fill(null));`\n\n### ✅Update the squares array with `handleClick(i)` function\n\n- 🛠️Store Boolean in `useState`\n  - To decide the value of next move\n    - `const [xIsNext, setXIsNext] = useState(true);`\n- ✅Create a copy of the squares array\n  - call `.slice()`\n  - `const nextSquares = squares.slice();`\n  - 📌Immutability is important\n    - Immutability makes complex features much easier to implement.\n      - “time travel” feature\n    - skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons\n      - By default, all child components re-render automatically when the state of a parent component changes.\n    - how React chooses when to re-render a component\n      - https://react.dev/reference/react/memo\n- ✅Take turns\n  - Use `xIsNext` and assign value to the copied array\n    - `xIsNext ? (nextSquares[i] = "X") : (nextSquares[i] = "O");`\n  - Prevent the X being overwritten by an O\n    - check if X/O exist, if true, return\n\n### ✅⭐Declare winners\n\n- Use _calculateWinner_ function (using a 2d-array)\n  - Store all possible winning cases\n- Add the function result to the _preventing statement_ (in Take turns)\n- Display winning message\n  - String concatenation\n    - `status = "Next player: " + (xIsNext ? "X" : "O");`\n\n### Render Board value\n\n## 📌*Game* > _Index.js_\n\n### Add time travel\n\n- ✅Lifting state up, again\n  - write a new top-level component called _Game_ to display a list of past moves\n- Control squares state in Game\n  - Store the past _squares_ arrays in another array called _history_ as a new state\n    - `const [history, setHistory] = useState([Array(9).fill(null)]);`\n    - It represents all board states, from the first to the last move\n  - 🛠️Render the last move from the history\n    - `const currentSquares = history[history.length - 1];`\n- 🛠️Add function `handlePlay` to update the game\n  - It will be called by the Board component to update the game\n  - Pass `xIsNext`, `currentSquares` and `handlePlay` as props to the Board component\n  - update `history` by appending the updated `squares` array as a new history entry\n    - `setHistory([...history, nextSquares]);`\n  - Update `xIsNext`\n    - toggle `xIsNext`, just as Board used to do\n      - `setXIsNext(!xIsNext);`\n- ✅Display moves history as buttons\n  - use `map` to transform your `history` of moves into React elements representing buttons on the screen,\n    - `history.map((squares, move) =>{}`\n    - Render button description for each move\n      - move > 0\n        - `description = "Go to move #" + move;`\n      - else\n        - `description = "Go to game start";`\n    - Unique ID for each list of button\n      - it’s safe to use the move index as a key\n        - `<li key={move}> </li>`\n      - 📌Avoid _key_ error\n        - If no key is specified, React will report an error and use the _array index_ as a key by default.\n          - It is problematic when trying to re-order a list’s items or inserting/removing list items\n        - Keys do not need to be globally unique; they only need to be unique between components and their siblings.\n  - Define button function to update `currentMove`\n    - keep track of which step the user is currently viewing\n      - `const [currentMove, setCurrentMove] = useState(0);`\n    - `<button onClick={() => jumpTo(move)}>{description}</button>`\n    - Add _jumpTo_ function inside `Game`\n      - update that `currentMove`\n        - `setCurrentMove(nextMove);`\n      - set `xIsNext` to true if the number that you’re changing `currentMove` to is even (偶数)\n        - 🛠️`setXIsNext(nextMove % 2 === 0);`\n        - ✅`const xIsNext = currentMove % 2 === 0;`\n- ✅Modify _handlePlay_ function\n  - If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point.\n    - add it after all items in `history.slice(0, currentMove + 1)` so that you’re only keeping that portion of the old history.\n      - `const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];`\n  - Each time a move is made, you need to update `currentMove` to point to the latest history entry.\n    - `setHistory(nextHistory);`\n    - `setCurrentMove(nextHistory.length - 1);`\n- ✅Render the currently selected move\n  - modify the `Game` component\n    - `const currentSquares = history[currentMove];`\n\n\n\n',data={title:"Tic-Tac-Toe",DateStarted:new Date(17015616e5),draft:!0,tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-mini-app/tic-tac-toe.md",rawData:void 0},html='<h1 id="tic-tac-toe">Tic-Tac-Toe<a class="anchor" href="#tic-tac-toe"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="build-tic-tac-toe">Build <em>Tic-Tac-Toe</em><a class="anchor" href="#build-tic-tac-toe"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id=""><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Demo-tic-tac-toe.png" alt=""></h3>\n<h2 id="square">📌<em>Square</em><a class="anchor" href="#square"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="display-the-value-of-each-square">Display the value of each square<a class="anchor" href="#display-the-value-of-each-square"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="respond-to-click-event">Respond to Click event<a class="anchor" href="#respond-to-click-event"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="board">📌<em>Board</em><a class="anchor" href="#board"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="️store-array-in-usestate">🛠️Store Array in <code>useState</code><a class="anchor" href="#️store-array-in-usestate"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>To store 9 squares value (X/O) in state\n<ul>\n<li><code>const [squares, setSquares] = useState(Array(9).fill(null));</code></li>\n</ul>\n</li>\n</ul>\n<h3 id="update-the-squares-array-with-handleclicki-function">✅Update the squares array with <code>handleClick(i)</code> function<a class="anchor" href="#update-the-squares-array-with-handleclicki-function"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>🛠️Store Boolean in <code>useState</code>\n<ul>\n<li>To decide the value of next move\n<ul>\n<li><code>const [xIsNext, setXIsNext] = useState(true);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>✅Create a copy of the squares array\n<ul>\n<li>call <code>.slice()</code></li>\n<li><code>const nextSquares = squares.slice();</code></li>\n<li>📌Immutability is important\n<ul>\n<li>Immutability makes complex features much easier to implement.\n<ul>\n<li>“time travel” feature</li>\n</ul>\n</li>\n<li>skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons\n<ul>\n<li>By default, all child components re-render automatically when the state of a parent component changes.</li>\n</ul>\n</li>\n<li>how React chooses when to re-render a component\n<ul>\n<li><a href="https://react.dev/reference/react/memo">https://react.dev/reference/react/memo</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>✅Take turns\n<ul>\n<li>Use <code>xIsNext</code> and assign value to the copied array\n<ul>\n<li><code>xIsNext ? (nextSquares[i] = "X") : (nextSquares[i] = "O");</code></li>\n</ul>\n</li>\n<li>Prevent the X being overwritten by an O\n<ul>\n<li>check if X/O exist, if true, return</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="declare-winners">✅⭐Declare winners<a class="anchor" href="#declare-winners"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>Use <em>calculateWinner</em> function (using a 2d-array)\n<ul>\n<li>Store all possible winning cases</li>\n</ul>\n</li>\n<li>Add the function result to the <em>preventing statement</em> (in Take turns)</li>\n<li>Display winning message\n<ul>\n<li>String concatenation\n<ul>\n<li><code>status = "Next player: " + (xIsNext ? "X" : "O");</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id="render-board-value">Render Board value<a class="anchor" href="#render-board-value"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="game--indexjs">📌<em>Game</em> > <em>Index.js</em><a class="anchor" href="#game--indexjs"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="add-time-travel">Add time travel<a class="anchor" href="#add-time-travel"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>✅Lifting state up, again\n<ul>\n<li>write a new top-level component called <em>Game</em> to display a list of past moves</li>\n</ul>\n</li>\n<li>Control squares state in Game\n<ul>\n<li>Store the past <em>squares</em> arrays in another array called <em>history</em> as a new state\n<ul>\n<li><code>const [history, setHistory] = useState([Array(9).fill(null)]);</code></li>\n<li>It represents all board states, from the first to the last move</li>\n</ul>\n</li>\n<li>🛠️Render the last move from the history\n<ul>\n<li><code>const currentSquares = history[history.length - 1];</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>🛠️Add function <code>handlePlay</code> to update the game\n<ul>\n<li>It will be called by the Board component to update the game</li>\n<li>Pass <code>xIsNext</code>, <code>currentSquares</code> and <code>handlePlay</code> as props to the Board component</li>\n<li>update <code>history</code> by appending the updated <code>squares</code> array as a new history entry\n<ul>\n<li><code>setHistory([...history, nextSquares]);</code></li>\n</ul>\n</li>\n<li>Update <code>xIsNext</code>\n<ul>\n<li>toggle <code>xIsNext</code>, just as Board used to do\n<ul>\n<li><code>setXIsNext(!xIsNext);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>✅Display moves history as buttons\n<ul>\n<li>use <code>map</code> to transform your <code>history</code> of moves into React elements representing buttons on the screen,\n<ul>\n<li><code>history.map((squares, move) =>{}</code></li>\n<li>Render button description for each move\n<ul>\n<li>move > 0\n<ul>\n<li><code>description = "Go to move #" + move;</code></li>\n</ul>\n</li>\n<li>else\n<ul>\n<li><code>description = "Go to game start";</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Unique ID for each list of button\n<ul>\n<li>it’s safe to use the move index as a key\n<ul>\n<li><code>&#x3C;li key={move}> &#x3C;/li></code></li>\n</ul>\n</li>\n<li>📌Avoid <em>key</em> error\n<ul>\n<li>If no key is specified, React will report an error and use the <em>array index</em> as a key by default.\n<ul>\n<li>It is problematic when trying to re-order a list’s items or inserting/removing list items</li>\n</ul>\n</li>\n<li>Keys do not need to be globally unique; they only need to be unique between components and their siblings.</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Define button function to update <code>currentMove</code>\n<ul>\n<li>keep track of which step the user is currently viewing\n<ul>\n<li><code>const [currentMove, setCurrentMove] = useState(0);</code></li>\n</ul>\n</li>\n<li><code>&#x3C;button onClick={() => jumpTo(move)}>{description}&#x3C;/button></code></li>\n<li>Add <em>jumpTo</em> function inside <code>Game</code>\n<ul>\n<li>update that <code>currentMove</code>\n<ul>\n<li><code>setCurrentMove(nextMove);</code></li>\n</ul>\n</li>\n<li>set <code>xIsNext</code> to true if the number that you’re changing <code>currentMove</code> to is even (偶数)\n<ul>\n<li>🛠️<code>setXIsNext(nextMove % 2 === 0);</code></li>\n<li>✅<code>const xIsNext = currentMove % 2 === 0;</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>✅Modify <em>handlePlay</em> function\n<ul>\n<li>If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point.\n<ul>\n<li>add it after all items in <code>history.slice(0, currentMove + 1)</code> so that you’re only keeping that portion of the old history.\n<ul>\n<li><code>const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Each time a move is made, you need to update <code>currentMove</code> to point to the latest history entry.\n<ul>\n<li><code>setHistory(nextHistory);</code></li>\n<li><code>setCurrentMove(nextHistory.length - 1);</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>✅Render the currently selected move\n<ul>\n<li>modify the <code>Game</code> component\n<ul>\n<li><code>const currentSquares = history[currentMove];</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>',frontmatter={topic:["State"],type:"D",tags:["React"],Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,title:"Tic-Tac-Toe",DateStarted:"2023-12-03T00:00:00.000Z",DateModified:"2024-09-14T00:00:00.000Z",aliases:["Tic-Tac-Toe"],"linter-yaml-title-alias":"Tic-Tac-Toe",category:"Front-End Frameworks",draft:!0,minutes:3,words:523},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/react-mini-app/tic-tac-toe.md",url=void 0;function rawContent(){return'\n# Tic-Tac-Toe\n\n## Build _Tic-Tac-Toe_\n### ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/full-stack/Demo-tic-tac-toe.png)\n\n## 📌*Square*\n\n### Display the value of each square\n\n### Respond to Click event\n\n## 📌*Board*\n\n### 🛠️Store Array in `useState`\n\n- To store 9 squares value (X/O) in state\n  - `const [squares, setSquares] = useState(Array(9).fill(null));`\n\n### ✅Update the squares array with `handleClick(i)` function\n\n- 🛠️Store Boolean in `useState`\n  - To decide the value of next move\n    - `const [xIsNext, setXIsNext] = useState(true);`\n- ✅Create a copy of the squares array\n  - call `.slice()`\n  - `const nextSquares = squares.slice();`\n  - 📌Immutability is important\n    - Immutability makes complex features much easier to implement.\n      - “time travel” feature\n    - skip re-rendering a part of the tree that clearly wasn’t affected by it for performance reasons\n      - By default, all child components re-render automatically when the state of a parent component changes.\n    - how React chooses when to re-render a component\n      - https://react.dev/reference/react/memo\n- ✅Take turns\n  - Use `xIsNext` and assign value to the copied array\n    - `xIsNext ? (nextSquares[i] = "X") : (nextSquares[i] = "O");`\n  - Prevent the X being overwritten by an O\n    - check if X/O exist, if true, return\n\n### ✅⭐Declare winners\n\n- Use _calculateWinner_ function (using a 2d-array)\n  - Store all possible winning cases\n- Add the function result to the _preventing statement_ (in Take turns)\n- Display winning message\n  - String concatenation\n    - `status = "Next player: " + (xIsNext ? "X" : "O");`\n\n### Render Board value\n\n## 📌*Game* > _Index.js_\n\n### Add time travel\n\n- ✅Lifting state up, again\n  - write a new top-level component called _Game_ to display a list of past moves\n- Control squares state in Game\n  - Store the past _squares_ arrays in another array called _history_ as a new state\n    - `const [history, setHistory] = useState([Array(9).fill(null)]);`\n    - It represents all board states, from the first to the last move\n  - 🛠️Render the last move from the history\n    - `const currentSquares = history[history.length - 1];`\n- 🛠️Add function `handlePlay` to update the game\n  - It will be called by the Board component to update the game\n  - Pass `xIsNext`, `currentSquares` and `handlePlay` as props to the Board component\n  - update `history` by appending the updated `squares` array as a new history entry\n    - `setHistory([...history, nextSquares]);`\n  - Update `xIsNext`\n    - toggle `xIsNext`, just as Board used to do\n      - `setXIsNext(!xIsNext);`\n- ✅Display moves history as buttons\n  - use `map` to transform your `history` of moves into React elements representing buttons on the screen,\n    - `history.map((squares, move) =>{}`\n    - Render button description for each move\n      - move > 0\n        - `description = "Go to move #" + move;`\n      - else\n        - `description = "Go to game start";`\n    - Unique ID for each list of button\n      - it’s safe to use the move index as a key\n        - `<li key={move}> </li>`\n      - 📌Avoid _key_ error\n        - If no key is specified, React will report an error and use the _array index_ as a key by default.\n          - It is problematic when trying to re-order a list’s items or inserting/removing list items\n        - Keys do not need to be globally unique; they only need to be unique between components and their siblings.\n  - Define button function to update `currentMove`\n    - keep track of which step the user is currently viewing\n      - `const [currentMove, setCurrentMove] = useState(0);`\n    - `<button onClick={() => jumpTo(move)}>{description}</button>`\n    - Add _jumpTo_ function inside `Game`\n      - update that `currentMove`\n        - `setCurrentMove(nextMove);`\n      - set `xIsNext` to true if the number that you’re changing `currentMove` to is even (偶数)\n        - 🛠️`setXIsNext(nextMove % 2 === 0);`\n        - ✅`const xIsNext = currentMove % 2 === 0;`\n- ✅Modify _handlePlay_ function\n  - If you “go back in time” and then make a new move from that point, you only want to keep the history up to that point.\n    - add it after all items in `history.slice(0, currentMove + 1)` so that you’re only keeping that portion of the old history.\n      - `const nextHistory = [...history.slice(0, currentMove + 1), nextSquares];`\n  - Each time a move is made, you need to update `currentMove` to point to the latest history entry.\n    - `setHistory(nextHistory);`\n    - `setCurrentMove(nextHistory.length - 1);`\n- ✅Render the currently selected move\n  - modify the `Game` component\n    - `const currentSquares = history[currentMove];`\n\n\n\n'}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"tic-tac-toe",text:"Tic-Tac-Toe#"},{depth:2,slug:"build-tic-tac-toe",text:"Build Tic-Tac-Toe#"},{depth:3,slug:"",text:""},{depth:2,slug:"square",text:"📌Square#"},{depth:3,slug:"display-the-value-of-each-square",text:"Display the value of each square#"},{depth:3,slug:"respond-to-click-event",text:"Respond to Click event#"},{depth:2,slug:"board",text:"📌Board#"},{depth:3,slug:"️store-array-in-usestate",text:"🛠️Store Array in useState#"},{depth:3,slug:"update-the-squares-array-with-handleclicki-function",text:"✅Update the squares array with handleClick(i) function#"},{depth:3,slug:"declare-winners",text:"✅⭐Declare winners#"},{depth:3,slug:"render-board-value",text:"Render Board value#"},{depth:2,slug:"game--indexjs",text:"📌Game > Index.js#"},{depth:3,slug:"add-time-travel",text:"Add time travel#"}]}const Content=createComponent(((e,t,n)=>{const{layout:a,...o}=frontmatter;return o.file=file,o.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),ticTacToe=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,slug,ticTacToe};