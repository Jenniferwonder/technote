import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/component-basics/class-component-类组件.md",collection="posts",slug="front-end-frameworks/react/component-basics/class-component-类组件",body="\n# Class Component-类组件\n\n## Constructor & super()\nreact 中的 class 是基于 es6 的规范实现的, 继承是使用 extends 关键字实现继承的，子类必须在 constructor()中调用 super() 方法否则新建实例  \n就会报错，报错的原因是 子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工，而 super()就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象。  \n如果你使用了 constructor 就必须写 super() 这个是用来初始化 this 的，可以绑定事件到 this 上  \n如果你想要在 constructor 中使用 this.props,就必须给 super 添加参数 super(props)  \n注意，无论有没有 constructor，在 render 中的 this.props 都是可以使用的，这是 react 自动附带的  \n如果没有用到 constructor 是可以不写的，react 会默认添加一个空的 constroctor.\n\n如果只调用了`super()`，那么`this.props`在`super()`和构造函数结束之间仍是`undefined`。\n\n```js\nclass Button extends React.Component {\n\tconstructor(props) {\n\t\tsuper(); // 没有传 props\n\t\tconsole.log(props); // {}\n\t\tconsole.log(this.props); // undefined\n\t}\n\t// ...\n}\n```\n\nsuper() 可以让我们使用 this 来调用各种东西，  \n而 super(props)可以让我们在 this 的基础上使用构造函数里面的东西， 或者从父元素那边传过来的一些属性\n## [component-life-cycle-组件声明周期](component-life-cycle-组件声明周期.md)\n## Questions\n#### [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n在 React 中，有两种主要的组件类型：函数式组件（Functional Component）和类组件（Class Component）。下面分别介绍它们的特点和区别。  \n##### 函数式组件\n1. 通过定义一个纯 JavaScript 函数来创建的，接收 props 作为参数并返回 React 元素。\n2. 在 React 16.8 之前，函数式组件仅支持接收 props，不支持 state 和生命周期方法。\n3. 自 React 16.8 引入 Hooks 后，函数式组件可以使用`useState`和`useEffect`等 Hooks 来实现状态管理和生命周期方法的功能。\n4. 函数式组件通常更简洁，易于阅读和测试。\n5. 在性能方面，由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。  \n##### 类组件\n6. 是通过定义一个继承自`React.Component`的 JavaScript 类来创建的，该类包含一个`render`方法，接收 props 和 state 作为输入，并返回 React 元素。\n7. 支持 state 和生命周期方法，如`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`等。\n8. 需要通过`this`关键字来访问 props 和 state。\n9. 类组件通常相对复杂，可能难以理解和测试。\n10. 在性能方面，由于有生命周期方法和实例化过程，类组件在某些情况下可能比函数式组件稍慢。  \n两者之间的主要区别：\n11. 定义方式：函数式组件是纯函数，而类组件是继承自`React.Component`的类。\n12. 状态管理：在 React 16.8 之前，只有类组件可以使用 state。自 React 16.8 引入 Hooks 后，函数式组件也可以使用`useState`来管理状态。\n13. 生命周期方法：在 React 16.8 之前，只有类组件支持生命周期方法。自 React 16.8 引入 Hooks 后，函数式组件可以使用`useEffect`等 Hooks 来实现生命周期方法的功能。\n14. 语法和结构：函数式组件通常更简洁，而类组件可能相对复杂。\n15. 性能：由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。  \n总的来说，随着 React Hooks 的引入，函数式组件的功能已经基本与类组件相当。在实际开发中，建议优先使用函数式组件，以保持代码简洁和易于维护。当然，在一些特定场景下，例如需要使用到生命周期方法或者需要访问组件实例（如使用 refs）时，类组件仍然具有一定的优势。\n\n#### [什么是 React 的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n\n#### [React.createClass 和 extends Component 的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n\n#### [React 组件的构造函数有什么作用？](https://github.com/haizlin/fe-interview/issues/930)\n\n#### [React 组件的构造函数是必须的吗？](https://github.com/haizlin/fe-interview/issues/929)\n\n#### [`super()`和`super(props)`有什么区别？](https://github.com/haizlin/fe-interview/issues/898)\n\n#### [constructor 和 getInitialState 有不同？](https://github.com/haizlin/fe-interview/issues/866)\n\n#### [React 中除了在构造函数中绑定 this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n\n#### [使用 ES6 的 class 定义的组件不支持 mixins 了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n#### [装饰器(Decorator)在 React 中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n#### [React 声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n#### [React 的 mixins 有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n\n#### [React 有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n\n#### [在 React 中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n",data={title:"Class Component-类组件",DateStarted:new Date(17096832e5),draft:!0,tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/class-component-类组件.md",rawData:void 0},html='<h1 id="class-component-类组件">Class Component-类组件<a class="anchor" href="#class-component-类组件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="constructor--super">Constructor &#x26; super()<a class="anchor" href="#constructor--super"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>react 中的 class 是基于 es6 的规范实现的, 继承是使用 extends 关键字实现继承的，子类必须在 constructor()中调用 super() 方法否则新建实例<br>\n就会报错，报错的原因是 子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工，而 super()就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象。<br>\n如果你使用了 constructor 就必须写 super() 这个是用来初始化 this 的，可以绑定事件到 this 上<br>\n如果你想要在 constructor 中使用 this.props,就必须给 super 添加参数 super(props)<br>\n注意，无论有没有 constructor，在 render 中的 this.props 都是可以使用的，这是 react 自动附带的<br>\n如果没有用到 constructor 是可以不写的，react 会默认添加一个空的 constroctor.</p>\n<p>如果只调用了<code>super()</code>，那么<code>this.props</code>在<code>super()</code>和构造函数结束之间仍是<code>undefined</code>。</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">class</span><span style="color:#B392F0"> Button</span><span style="color:#F97583"> extends</span><span style="color:#B392F0"> React</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">Component</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\tconstructor</span><span style="color:#E1E4E8">(</span><span style="color:#FFAB70">props</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#79B8FF">\t\tsuper</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// 没有传 props</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(props); </span><span style="color:#6A737D">// {}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.props); </span><span style="color:#6A737D">// undefined</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#6A737D">\t// ...</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"></span></code></pre>\n<p>super() 可以让我们使用 this 来调用各种东西，<br>\n而 super(props)可以让我们在 this 的基础上使用构造函数里面的东西， 或者从父元素那边传过来的一些属性</p>\n<h2 id="component-life-cycle-组件声明周期"><a href="component-life-cycle-%E7%BB%84%E4%BB%B6%E5%A3%B0%E6%98%8E%E5%91%A8%E6%9C%9F.md">component-life-cycle-组件声明周期</a><a class="anchor" href="#component-life-cycle-组件声明周期"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="类组件和函数式组件有什么区别"><a href="https://github.com/haizlin/fe-interview/issues/647">类组件和函数式组件有什么区别？</a><a class="anchor" href="#类组件和函数式组件有什么区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>在 React 中，有两种主要的组件类型：函数式组件（Functional Component）和类组件（Class Component）。下面分别介绍它们的特点和区别。</p>\n<h5 id="函数式组件">函数式组件<a class="anchor" href="#函数式组件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ol>\n<li>通过定义一个纯 JavaScript 函数来创建的，接收 props 作为参数并返回 React 元素。</li>\n<li>在 React 16.8 之前，函数式组件仅支持接收 props，不支持 state 和生命周期方法。</li>\n<li>自 React 16.8 引入 Hooks 后，函数式组件可以使用<code>useState</code>和<code>useEffect</code>等 Hooks 来实现状态管理和生命周期方法的功能。</li>\n<li>函数式组件通常更简洁，易于阅读和测试。</li>\n<li>在性能方面，由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。</li>\n</ol>\n<h5 id="类组件">类组件<a class="anchor" href="#类组件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<ol start="6">\n<li>是通过定义一个继承自<code>React.Component</code>的 JavaScript 类来创建的，该类包含一个<code>render</code>方法，接收 props 和 state 作为输入，并返回 React 元素。</li>\n<li>支持 state 和生命周期方法，如<code>componentDidMount</code>、<code>componentDidUpdate</code>和<code>componentWillUnmount</code>等。</li>\n<li>需要通过<code>this</code>关键字来访问 props 和 state。</li>\n<li>类组件通常相对复杂，可能难以理解和测试。</li>\n<li>在性能方面，由于有生命周期方法和实例化过程，类组件在某些情况下可能比函数式组件稍慢。<br>\n两者之间的主要区别：</li>\n<li>定义方式：函数式组件是纯函数，而类组件是继承自<code>React.Component</code>的类。</li>\n<li>状态管理：在 React 16.8 之前，只有类组件可以使用 state。自 React 16.8 引入 Hooks 后，函数式组件也可以使用<code>useState</code>来管理状态。</li>\n<li>生命周期方法：在 React 16.8 之前，只有类组件支持生命周期方法。自 React 16.8 引入 Hooks 后，函数式组件可以使用<code>useEffect</code>等 Hooks 来实现生命周期方法的功能。</li>\n<li>语法和结构：函数式组件通常更简洁，而类组件可能相对复杂。</li>\n<li>性能：由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。<br>\n总的来说，随着 React Hooks 的引入，函数式组件的功能已经基本与类组件相当。在实际开发中，建议优先使用函数式组件，以保持代码简洁和易于维护。当然，在一些特定场景下，例如需要使用到生命周期方法或者需要访问组件实例（如使用 refs）时，类组件仍然具有一定的优势。</li>\n</ol>\n<h4 id="什么是-react-的实例函数式组件有没有实例"><a href="https://github.com/haizlin/fe-interview/issues/806">什么是 React 的实例？函数式组件有没有实例？</a><a class="anchor" href="#什么是-react-的实例函数式组件有没有实例"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="reactcreateclass-和-extends-component-的区别有哪些"><a href="https://github.com/haizlin/fe-interview/issues/786">React.createClass 和 extends Component 的区别有哪些？</a><a class="anchor" href="#reactcreateclass-和-extends-component-的区别有哪些"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-组件的构造函数有什么作用"><a href="https://github.com/haizlin/fe-interview/issues/930">React 组件的构造函数有什么作用？</a><a class="anchor" href="#react-组件的构造函数有什么作用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-组件的构造函数是必须的吗"><a href="https://github.com/haizlin/fe-interview/issues/929">React 组件的构造函数是必须的吗？</a><a class="anchor" href="#react-组件的构造函数是必须的吗"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="super和superprops有什么区别"><a href="https://github.com/haizlin/fe-interview/issues/898"><code>super()</code>和<code>super(props)</code>有什么区别？</a><a class="anchor" href="#super和superprops有什么区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="constructor-和-getinitialstate-有不同"><a href="https://github.com/haizlin/fe-interview/issues/866">constructor 和 getInitialState 有不同？</a><a class="anchor" href="#constructor-和-getinitialstate-有不同"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-中除了在构造函数中绑定-this还有别的方式吗"><a href="https://github.com/haizlin/fe-interview/issues/641">React 中除了在构造函数中绑定 this,还有别的方式吗？</a><a class="anchor" href="#react-中除了在构造函数中绑定-this还有别的方式吗"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="使用-es6-的-class-定义的组件不支持-mixins-了那用什么可以替代呢"><a href="https://github.com/haizlin/fe-interview/issues/722">使用 ES6 的 class 定义的组件不支持 mixins 了，那用什么可以替代呢？</a><a class="anchor" href="#使用-es6-的-class-定义的组件不支持-mixins-了那用什么可以替代呢"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="装饰器decorator在-react-中有什么应用"><a href="https://github.com/haizlin/fe-interview/issues/855">装饰器(Decorator)在 React 中有什么应用？</a><a class="anchor" href="#装饰器decorator在-react-中有什么应用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-声明组件有哪几种方法各有什么不同"><a href="https://github.com/haizlin/fe-interview/issues/604">React 声明组件有哪几种方法，各有什么不同？</a><a class="anchor" href="#react-声明组件有哪几种方法各有什么不同"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-的-mixins-有什么作用适用于什么场景"><a href="https://github.com/haizlin/fe-interview/issues/664">React 的 mixins 有什么作用？适用于什么场景？</a><a class="anchor" href="#react-的-mixins-有什么作用适用于什么场景"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-有几种构建组件的方式可以写出来吗"><a href="https://github.com/haizlin/fe-interview/issues/644">React 有几种构建组件的方式？可以写出来吗？</a><a class="anchor" href="#react-有几种构建组件的方式可以写出来吗"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="在-react-中如何判断点击元素属于哪一个组件"><a href="https://github.com/haizlin/fe-interview/issues/805">在 React 中如何判断点击元素属于哪一个组件？</a><a class="anchor" href="#在-react-中如何判断点击元素属于哪一个组件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>',frontmatter={title:"Class Component-类组件",topic:["Component-Basics"],type:"D",tags:["React"],DateStarted:"2024-03-06T00:00:00.000Z",DateModified:"2024-06-17T00:00:00.000Z",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,aliases:["Class Component-类组件","Class Component"],"linter-yaml-title-alias":"Class Component-类组件",category:"Front-End Frameworks",draft:!0,minutes:6,words:1166},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/class-component-类组件.md",url=void 0;function rawContent(){return"\n# Class Component-类组件\n\n## Constructor & super()\nreact 中的 class 是基于 es6 的规范实现的, 继承是使用 extends 关键字实现继承的，子类必须在 constructor()中调用 super() 方法否则新建实例  \n就会报错，报错的原因是 子类是没有自己的 this 对象的，它只能继承父类的 this 对象，然后对其进行加工，而 super()就是将父类中的 this 对象继承给子类的，没有 super() 子类就得不到 this 对象。  \n如果你使用了 constructor 就必须写 super() 这个是用来初始化 this 的，可以绑定事件到 this 上  \n如果你想要在 constructor 中使用 this.props,就必须给 super 添加参数 super(props)  \n注意，无论有没有 constructor，在 render 中的 this.props 都是可以使用的，这是 react 自动附带的  \n如果没有用到 constructor 是可以不写的，react 会默认添加一个空的 constroctor.\n\n如果只调用了`super()`，那么`this.props`在`super()`和构造函数结束之间仍是`undefined`。\n\n```js\nclass Button extends React.Component {\n\tconstructor(props) {\n\t\tsuper(); // 没有传 props\n\t\tconsole.log(props); // {}\n\t\tconsole.log(this.props); // undefined\n\t}\n\t// ...\n}\n```\n\nsuper() 可以让我们使用 this 来调用各种东西，  \n而 super(props)可以让我们在 this 的基础上使用构造函数里面的东西， 或者从父元素那边传过来的一些属性\n## [component-life-cycle-组件声明周期](component-life-cycle-组件声明周期.md)\n## Questions\n#### [类组件和函数式组件有什么区别？](https://github.com/haizlin/fe-interview/issues/647)\n在 React 中，有两种主要的组件类型：函数式组件（Functional Component）和类组件（Class Component）。下面分别介绍它们的特点和区别。  \n##### 函数式组件\n1. 通过定义一个纯 JavaScript 函数来创建的，接收 props 作为参数并返回 React 元素。\n2. 在 React 16.8 之前，函数式组件仅支持接收 props，不支持 state 和生命周期方法。\n3. 自 React 16.8 引入 Hooks 后，函数式组件可以使用`useState`和`useEffect`等 Hooks 来实现状态管理和生命周期方法的功能。\n4. 函数式组件通常更简洁，易于阅读和测试。\n5. 在性能方面，由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。  \n##### 类组件\n6. 是通过定义一个继承自`React.Component`的 JavaScript 类来创建的，该类包含一个`render`方法，接收 props 和 state 作为输入，并返回 React 元素。\n7. 支持 state 和生命周期方法，如`componentDidMount`、`componentDidUpdate`和`componentWillUnmount`等。\n8. 需要通过`this`关键字来访问 props 和 state。\n9. 类组件通常相对复杂，可能难以理解和测试。\n10. 在性能方面，由于有生命周期方法和实例化过程，类组件在某些情况下可能比函数式组件稍慢。  \n两者之间的主要区别：\n11. 定义方式：函数式组件是纯函数，而类组件是继承自`React.Component`的类。\n12. 状态管理：在 React 16.8 之前，只有类组件可以使用 state。自 React 16.8 引入 Hooks 后，函数式组件也可以使用`useState`来管理状态。\n13. 生命周期方法：在 React 16.8 之前，只有类组件支持生命周期方法。自 React 16.8 引入 Hooks 后，函数式组件可以使用`useEffect`等 Hooks 来实现生命周期方法的功能。\n14. 语法和结构：函数式组件通常更简洁，而类组件可能相对复杂。\n15. 性能：由于没有生命周期方法和实例化过程，函数式组件在某些情况下可能比类组件更快。  \n总的来说，随着 React Hooks 的引入，函数式组件的功能已经基本与类组件相当。在实际开发中，建议优先使用函数式组件，以保持代码简洁和易于维护。当然，在一些特定场景下，例如需要使用到生命周期方法或者需要访问组件实例（如使用 refs）时，类组件仍然具有一定的优势。\n\n#### [什么是 React 的实例？函数式组件有没有实例？](https://github.com/haizlin/fe-interview/issues/806)\n\n#### [React.createClass 和 extends Component 的区别有哪些？](https://github.com/haizlin/fe-interview/issues/786)\n\n#### [React 组件的构造函数有什么作用？](https://github.com/haizlin/fe-interview/issues/930)\n\n#### [React 组件的构造函数是必须的吗？](https://github.com/haizlin/fe-interview/issues/929)\n\n#### [`super()`和`super(props)`有什么区别？](https://github.com/haizlin/fe-interview/issues/898)\n\n#### [constructor 和 getInitialState 有不同？](https://github.com/haizlin/fe-interview/issues/866)\n\n#### [React 中除了在构造函数中绑定 this,还有别的方式吗？](https://github.com/haizlin/fe-interview/issues/641)\n\n#### [使用 ES6 的 class 定义的组件不支持 mixins 了，那用什么可以替代呢？](https://github.com/haizlin/fe-interview/issues/722)\n#### [装饰器(Decorator)在 React 中有什么应用？](https://github.com/haizlin/fe-interview/issues/855)\n#### [React 声明组件有哪几种方法，各有什么不同？](https://github.com/haizlin/fe-interview/issues/604)\n#### [React 的 mixins 有什么作用？适用于什么场景？](https://github.com/haizlin/fe-interview/issues/664)\n\n#### [React 有几种构建组件的方式？可以写出来吗？](https://github.com/haizlin/fe-interview/issues/644)\n\n#### [在 React 中如何判断点击元素属于哪一个组件？](https://github.com/haizlin/fe-interview/issues/805)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"class-component-类组件",text:"Class Component-类组件#"},{depth:2,slug:"constructor--super",text:"Constructor & super()#"},{depth:2,slug:"component-life-cycle-组件声明周期",text:"component-life-cycle-组件声明周期#"},{depth:2,slug:"questions",text:"Questions#"},{depth:4,slug:"类组件和函数式组件有什么区别",text:"类组件和函数式组件有什么区别？#"},{depth:5,slug:"函数式组件",text:"函数式组件#"},{depth:5,slug:"类组件",text:"类组件#"},{depth:4,slug:"什么是-react-的实例函数式组件有没有实例",text:"什么是 React 的实例？函数式组件有没有实例？#"},{depth:4,slug:"reactcreateclass-和-extends-component-的区别有哪些",text:"React.createClass 和 extends Component 的区别有哪些？#"},{depth:4,slug:"react-组件的构造函数有什么作用",text:"React 组件的构造函数有什么作用？#"},{depth:4,slug:"react-组件的构造函数是必须的吗",text:"React 组件的构造函数是必须的吗？#"},{depth:4,slug:"super和superprops有什么区别",text:"super()和super(props)有什么区别？#"},{depth:4,slug:"constructor-和-getinitialstate-有不同",text:"constructor 和 getInitialState 有不同？#"},{depth:4,slug:"react-中除了在构造函数中绑定-this还有别的方式吗",text:"React 中除了在构造函数中绑定 this,还有别的方式吗？#"},{depth:4,slug:"使用-es6-的-class-定义的组件不支持-mixins-了那用什么可以替代呢",text:"使用 ES6 的 class 定义的组件不支持 mixins 了，那用什么可以替代呢？#"},{depth:4,slug:"装饰器decorator在-react-中有什么应用",text:"装饰器(Decorator)在 React 中有什么应用？#"},{depth:4,slug:"react-声明组件有哪几种方法各有什么不同",text:"React 声明组件有哪几种方法，各有什么不同？#"},{depth:4,slug:"react-的-mixins-有什么作用适用于什么场景",text:"React 的 mixins 有什么作用？适用于什么场景？#"},{depth:4,slug:"react-有几种构建组件的方式可以写出来吗",text:"React 有几种构建组件的方式？可以写出来吗？#"},{depth:4,slug:"在-react-中如何判断点击元素属于哪一个组件",text:"在 React 中如何判断点击元素属于哪一个组件？#"}]}const Content=createComponent(((e,n,t)=>{const{layout:s,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),classComponent____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,classComponent____,collection,data,id,slug};