import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/component-basics/react-event-事件机制.md",collection="posts",slug="front-end-frameworks/react/component-basics/react-event-事件机制",body="# React Event-事件机制\n## 合成事件机制 (SyntheticEvent)\n#### 什么是合成事件\n>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象\n\nReact 的合成事件系统（Synthetic Event）是 React 对原生浏览器事件进行的一层封装，与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。主要是为了\n\n#### 实现合成事件的目的：\n- 兼容所有浏览器，更好的跨平台；保证在所有浏览器中事件的行为是一致的，解决了浏览器之间对事件处理的差异问题。  \n- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n- 方便 react 统一管理和事务机制；\n- 减少了内存消耗：对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的 **内存分配** 问题。但是对于合成事件来说，有一个 **事件池** 专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。\n#### 具体细节\n在React底层，主要对合成事件做了两件事：\n- **事件委派：** React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n- **自动绑定：** React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\nJSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 `document` 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 `document` 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 `event.stopPropagation` 是无效的，而应该调用 `event.preventDefault`。\n事件的执行顺序为**原生事件先执行，合成事件后执行**，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n\n\n以下是我对 React 合成事件的一些理解：\n1. **跨浏览器的一致性**：不同的浏览器可能有不同的事件模型，对同一事件可能有不同的行为。React 合成事件为所有的事件提供了一套统一的接口，保证了在所有浏览器中事件行为的一致性。例如，所有的 React 事件处理函数都会接收到一个合成事件对象，你可以通过这个对象的`event.preventDefault()`和`event.stopPropagation()`等方法来控制事件的行为。\n2. **事件委派**：React 使用事件委派来提高性能。在 React 中，不是直接把事件处理函数绑定到真实的节点上，而是所有的事件都被绑定到文档的根节点上。当事件发生并冒泡到根节点时，React 会根据事件的信息找到对应的组件并执行相应的事件处理函数。\n3. **池化**：React 为了提高性能，会复用合成事件对象。事件回调被调用后，所有的事件属性都会被清空并放入事件池中。这就意味着你无法异步访问事件对象。如果你需要异步访问事件对象，你必须调用`event.persist()`来从池中移除合成事件对象，这样 React 就不会清空这个对象的属性。\n4. **合成事件和原生事件的交互**：虽然 React 事件被封装在合成事件中，但你仍然可以通过`event.nativeEvent`访问到浏览器的原生事件。\n5. **完全的事件支持**：React 合成事件提供了对所有常见的 DOM 事件的支持，包括鼠标、键盘、剪贴板、触摸等事件。  \n总的来说，React 的合成事件系统提供了一种处理浏览器事件的高效、一致且跨浏览器的方式，它是 React 中一项非常重要的特性。\n\n## Basics\n> [Reacting to Input with State • React](https://beta.reactjs.org/learn/reacting-to-input-with-state)\n- _Identify_ your component's different visual states\n- _Determine_ what triggers those state changes (Human/ computer input)\n- _Represent_ the state in memory using `useState`\n- _Remove_ any non-essential state variables\n- _Connect_ the event handlers to set the state\n### `onClick={handleClick}`\n- 📌[Click](DB-React-Components/Click)\n- 📌[UpdateClick](DB-React-Components/UpdateClick)\n- 📌[RemoveBg](DB-React-Components/RemoveBg)\n- 📌[Gallery](DB-React-Components/Gallery)\n  - Store Boolean as state\n  - Conditional rendering\n  - `handleNextClick(){}`\n  - `handleMoreClick(){}`\n### `onSubmit` (Form Handling)\n- 📌[Quiz](DB-React-Components/Quiz)\n  - `async function`\n    - `try {await...} catch (err) {...}`\n  - `new Promise((resolve, reject) =>{ })`\n    - `setTimeout()`\n    - `new Error()`\n- 📌[EditProfile](DB-React-Components/EditProfile)\n### `onChange` (input text & checkbox)\n- `onChange={(e) => onFilterTextChange(e.target.value)}`\n- `onChange={(e) => onInStockOnlyChange(e.target.checked)}`\n- 🏷️Table\n  - 📌[ProductTableApp](DB-React-Components/ProductTableApp)\n  - 📌[FilterList](DB-React-Components/FilterList)\n- 📌[MailSelect](DB-React-Components/MailSelect)\n### `onFocus` & `onPointerMove`\n- 📌[MailHighlight](DB-React-Components/MailHighlight) (Highlight & Star)\n## Questions\n#### React 事件绑定原理\n#### React 组件中怎么做事件代理？它的原理是什么？\n#### [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\njsx 事件 = 函数，会调用函数并把函数的返回值记录，在每次 render 时调用  \n因此，handleClick 会随事件触发调用，handleClick() 只会调用一次\n#### [在 React 中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n#### [举例说明如何在 React 创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n#### [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n#### [在 React 中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n#### [React 的事件和普通的 HTML 事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n#### [在 React 中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n#### [组件卸载前，加在 DOM 元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n#### [React 的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n#### [请描述下事件在 React 中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n",data={title:"React Event-事件机制",DateStarted:new Date(171288e7),draft:!1,tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/react-event-事件机制.md",rawData:void 0},html='<h1 id="react-event-事件机制">React Event-事件机制<a class="anchor" href="#react-event-事件机制"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="合成事件机制-syntheticevent">合成事件机制 (SyntheticEvent)<a class="anchor" href="#合成事件机制-syntheticevent"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="什么是合成事件">什么是合成事件<a class="anchor" href="#什么是合成事件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<blockquote>\n<p>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象</p>\n</blockquote>\n<p>React 的合成事件系统（Synthetic Event）是 React 对原生浏览器事件进行的一层封装，与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。主要是为了</p>\n<h4 id="实现合成事件的目的">实现合成事件的目的：<a class="anchor" href="#实现合成事件的目的"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>兼容所有浏览器，更好的跨平台；保证在所有浏览器中事件的行为是一致的，解决了浏览器之间对事件处理的差异问题。</li>\n<li>将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。</li>\n<li>方便 react 统一管理和事务机制；</li>\n<li>减少了内存消耗：对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的 <strong>内存分配</strong> 问题。但是对于合成事件来说，有一个 <strong>事件池</strong> 专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。</li>\n</ul>\n<h4 id="具体细节">具体细节<a class="anchor" href="#具体细节"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>在React底层，主要对合成事件做了两件事：</p>\n<ul>\n<li><strong>事件委派：</strong> React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。</li>\n<li><strong>自动绑定：</strong> React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\nJSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 <code>document</code> 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 <code>document</code> 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 <code>event.stopPropagation</code> 是无效的，而应该调用 <code>event.preventDefault</code>。\n事件的执行顺序为<strong>原生事件先执行，合成事件后执行</strong>，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。</li>\n</ul>\n<p>以下是我对 React 合成事件的一些理解：</p>\n<ol>\n<li><strong>跨浏览器的一致性</strong>：不同的浏览器可能有不同的事件模型，对同一事件可能有不同的行为。React 合成事件为所有的事件提供了一套统一的接口，保证了在所有浏览器中事件行为的一致性。例如，所有的 React 事件处理函数都会接收到一个合成事件对象，你可以通过这个对象的<code>event.preventDefault()</code>和<code>event.stopPropagation()</code>等方法来控制事件的行为。</li>\n<li><strong>事件委派</strong>：React 使用事件委派来提高性能。在 React 中，不是直接把事件处理函数绑定到真实的节点上，而是所有的事件都被绑定到文档的根节点上。当事件发生并冒泡到根节点时，React 会根据事件的信息找到对应的组件并执行相应的事件处理函数。</li>\n<li><strong>池化</strong>：React 为了提高性能，会复用合成事件对象。事件回调被调用后，所有的事件属性都会被清空并放入事件池中。这就意味着你无法异步访问事件对象。如果你需要异步访问事件对象，你必须调用<code>event.persist()</code>来从池中移除合成事件对象，这样 React 就不会清空这个对象的属性。</li>\n<li><strong>合成事件和原生事件的交互</strong>：虽然 React 事件被封装在合成事件中，但你仍然可以通过<code>event.nativeEvent</code>访问到浏览器的原生事件。</li>\n<li><strong>完全的事件支持</strong>：React 合成事件提供了对所有常见的 DOM 事件的支持，包括鼠标、键盘、剪贴板、触摸等事件。<br>\n总的来说，React 的合成事件系统提供了一种处理浏览器事件的高效、一致且跨浏览器的方式，它是 React 中一项非常重要的特性。</li>\n</ol>\n<h2 id="basics">Basics<a class="anchor" href="#basics"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<blockquote>\n<p><a href="https://beta.reactjs.org/learn/reacting-to-input-with-state">Reacting to Input with State • React</a></p>\n</blockquote>\n<ul>\n<li><em>Identify</em> your component’s different visual states</li>\n<li><em>Determine</em> what triggers those state changes (Human/ computer input)</li>\n<li><em>Represent</em> the state in memory using <code>useState</code></li>\n<li><em>Remove</em> any non-essential state variables</li>\n<li><em>Connect</em> the event handlers to set the state</li>\n</ul>\n<h3 id="onclickhandleclick"><code>onClick={handleClick}</code><a class="anchor" href="#onclickhandleclick"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>📌<a href="DB-React-Components/Click">Click</a></li>\n<li>📌<a href="DB-React-Components/UpdateClick">UpdateClick</a></li>\n<li>📌<a href="DB-React-Components/RemoveBg">RemoveBg</a></li>\n<li>📌<a href="DB-React-Components/Gallery">Gallery</a>\n<ul>\n<li>Store Boolean as state</li>\n<li>Conditional rendering</li>\n<li><code>handleNextClick(){}</code></li>\n<li><code>handleMoreClick(){}</code></li>\n</ul>\n</li>\n</ul>\n<h3 id="onsubmit-form-handling"><code>onSubmit</code> (Form Handling)<a class="anchor" href="#onsubmit-form-handling"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>📌<a href="DB-React-Components/Quiz">Quiz</a>\n<ul>\n<li><code>async function</code>\n<ul>\n<li><code>try {await...} catch (err) {...}</code></li>\n</ul>\n</li>\n<li><code>new Promise((resolve, reject) =>{ })</code>\n<ul>\n<li><code>setTimeout()</code></li>\n<li><code>new Error()</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>📌<a href="DB-React-Components/EditProfile">EditProfile</a></li>\n</ul>\n<h3 id="onchange-input-text--checkbox"><code>onChange</code> (input text &#x26; checkbox)<a class="anchor" href="#onchange-input-text--checkbox"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><code>onChange={(e) => onFilterTextChange(e.target.value)}</code></li>\n<li><code>onChange={(e) => onInStockOnlyChange(e.target.checked)}</code></li>\n<li>🏷️Table\n<ul>\n<li>📌<a href="DB-React-Components/ProductTableApp">ProductTableApp</a></li>\n<li>📌<a href="DB-React-Components/FilterList">FilterList</a></li>\n</ul>\n</li>\n<li>📌<a href="DB-React-Components/MailSelect">MailSelect</a></li>\n</ul>\n<h3 id="onfocus--onpointermove"><code>onFocus</code> &#x26; <code>onPointerMove</code><a class="anchor" href="#onfocus--onpointermove"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>📌<a href="DB-React-Components/MailHighlight">MailHighlight</a> (Highlight &#x26; Star)</li>\n</ul>\n<h2 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h4 id="react-事件绑定原理">React 事件绑定原理<a class="anchor" href="#react-事件绑定原理"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-组件中怎么做事件代理它的原理是什么">React 组件中怎么做事件代理？它的原理是什么？<a class="anchor" href="#react-组件中怎么做事件代理它的原理是什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="div-onclickhandlerclick单击div和div-onclickhandlerclick1单击div有什么区别"><a href="https://github.com/haizlin/fe-interview/issues/830"><code>&#x3C;div onClick={handlerClick}>单击&#x3C;/div></code>和<code>&#x3C;div onClick={handlerClick(1)}>单击&#x3C;/div></code>有什么区别？</a><a class="anchor" href="#div-onclickhandlerclick单击div和div-onclickhandlerclick1单击div有什么区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>jsx 事件 = 函数，会调用函数并把函数的返回值记录，在每次 render 时调用<br>\n因此，handleClick 会随事件触发调用，handleClick() 只会调用一次</p>\n<h4 id="在-react-中什么是合成事件有什么用"><a href="https://github.com/haizlin/fe-interview/issues/713">在 React 中什么是合成事件？有什么用？</a><a class="anchor" href="#在-react-中什么是合成事件有什么用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="举例说明如何在-react-创建一个事件"><a href="https://github.com/haizlin/fe-interview/issues/850">举例说明如何在 React 创建一个事件</a><a class="anchor" href="#举例说明如何在-react-创建一个事件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="怎样将事件传递给子组件"><a href="https://github.com/haizlin/fe-interview/issues/892">怎样将事件传递给子组件？</a><a class="anchor" href="#怎样将事件传递给子组件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="在-react-中怎么将参数传递给事件"><a href="https://github.com/haizlin/fe-interview/issues/876">在 React 中怎么将参数传递给事件？</a><a class="anchor" href="#在-react-中怎么将参数传递给事件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-的事件和普通的-html-事件有什么不同"><a href="https://github.com/haizlin/fe-interview/issues/875">React 的事件和普通的 HTML 事件有什么不同？</a><a class="anchor" href="#react-的事件和普通的-html-事件有什么不同"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="在-react-中怎么阻止事件的默认行为"><a href="https://github.com/haizlin/fe-interview/issues/874">在 React 中怎么阻止事件的默认行为？</a><a class="anchor" href="#在-react-中怎么阻止事件的默认行为"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="组件卸载前加在-dom-元素的监听事件和定时器要不要手动清除为什么"><a href="https://github.com/haizlin/fe-interview/issues/840">组件卸载前，加在 DOM 元素的监听事件和定时器要不要手动清除？为什么？</a><a class="anchor" href="#组件卸载前加在-dom-元素的监听事件和定时器要不要手动清除为什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-的触摸事件有哪几种"><a href="https://github.com/haizlin/fe-interview/issues/834">React 的触摸事件有哪几种？</a><a class="anchor" href="#react-的触摸事件有哪几种"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="请描述下事件在-react-中的处理方式是什么"><a href="https://github.com/haizlin/fe-interview/issues/662">请描述下事件在 React 中的处理方式是什么？</a><a class="anchor" href="#请描述下事件在-react-中的处理方式是什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>',frontmatter={draft:!1,aliases:["React Event-事件机制"],title:"React Event-事件机制",topic:["Component-Basics"],type:"D",tags:["React"],DateStarted:"2024-04-12T00:00:00.000Z",DateModified:"2024-06-16T00:00:00.000Z",Datereviewed:"2024-04-12T00:00:00.000Z",reviewed:1,difficulty:null,status:null,comment:null,"linter-yaml-title-alias":"React Event-事件机制",category:"Front-End Frameworks",minutes:7,words:1480},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/react-event-事件机制.md",url=void 0;function rawContent(){return"# React Event-事件机制\n## 合成事件机制 (SyntheticEvent)\n#### 什么是合成事件\n>合成事件是 react 模拟原生 DOM 事件所有能力的一个事件对象\n\nReact 的合成事件系统（Synthetic Event）是 React 对原生浏览器事件进行的一层封装，与原生的浏览器事件拥有同样的接口，支持冒泡机制，所有的事件都自动绑定在最外层上。主要是为了\n\n#### 实现合成事件的目的：\n- 兼容所有浏览器，更好的跨平台；保证在所有浏览器中事件的行为是一致的，解决了浏览器之间对事件处理的差异问题。  \n- 将事件统一存放在一个数组，避免频繁的新增与删除（垃圾回收）。\n- 方便 react 统一管理和事务机制；\n- 减少了内存消耗：对于原生浏览器事件来说，浏览器会给监听器创建一个事件对象。如果你有很多的事件监听，那么就需要分配很多的事件对象，造成高额的 **内存分配** 问题。但是对于合成事件来说，有一个 **事件池** 专门来管理它们的创建和销毁，当事件需要被使用时，就会从池子中复用对象，事件回调结束后，就会销毁事件对象上的属性，从而便于下次复用事件对象。\n#### 具体细节\n在React底层，主要对合成事件做了两件事：\n- **事件委派：** React会把所有的事件绑定到结构的最外层，使用统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部事件监听和处理函数。\n- **自动绑定：** React组件中，每个方法的上下文都会指向该组件的实例，即自动绑定this为当前组件。\nJSX 上写的事件并没有绑定在对应的真实 DOM 上，而是通过事件代理的方式，将所有的事件都统一绑定在了 `document` 上。这样的方式不仅减少了内存消耗，还能在组件挂载销毁时统一订阅和移除事件。\n另外冒泡到 `document` 上的事件也不是原生浏览器事件，而是 React 自己实现的合成事件（SyntheticEvent）。因此我们如果不想要事件冒泡的话，调用 `event.stopPropagation` 是无效的，而应该调用 `event.preventDefault`。\n事件的执行顺序为**原生事件先执行，合成事件后执行**，合成事件会冒泡绑定到 document 上，所以尽量避免原生事件与合成事件混用，如果原生事件阻止冒泡，可能会导致合成事件不执行，因为需要冒泡到document 上合成事件才会执行。\n\n\n以下是我对 React 合成事件的一些理解：\n1. **跨浏览器的一致性**：不同的浏览器可能有不同的事件模型，对同一事件可能有不同的行为。React 合成事件为所有的事件提供了一套统一的接口，保证了在所有浏览器中事件行为的一致性。例如，所有的 React 事件处理函数都会接收到一个合成事件对象，你可以通过这个对象的`event.preventDefault()`和`event.stopPropagation()`等方法来控制事件的行为。\n2. **事件委派**：React 使用事件委派来提高性能。在 React 中，不是直接把事件处理函数绑定到真实的节点上，而是所有的事件都被绑定到文档的根节点上。当事件发生并冒泡到根节点时，React 会根据事件的信息找到对应的组件并执行相应的事件处理函数。\n3. **池化**：React 为了提高性能，会复用合成事件对象。事件回调被调用后，所有的事件属性都会被清空并放入事件池中。这就意味着你无法异步访问事件对象。如果你需要异步访问事件对象，你必须调用`event.persist()`来从池中移除合成事件对象，这样 React 就不会清空这个对象的属性。\n4. **合成事件和原生事件的交互**：虽然 React 事件被封装在合成事件中，但你仍然可以通过`event.nativeEvent`访问到浏览器的原生事件。\n5. **完全的事件支持**：React 合成事件提供了对所有常见的 DOM 事件的支持，包括鼠标、键盘、剪贴板、触摸等事件。  \n总的来说，React 的合成事件系统提供了一种处理浏览器事件的高效、一致且跨浏览器的方式，它是 React 中一项非常重要的特性。\n\n## Basics\n> [Reacting to Input with State • React](https://beta.reactjs.org/learn/reacting-to-input-with-state)\n- _Identify_ your component's different visual states\n- _Determine_ what triggers those state changes (Human/ computer input)\n- _Represent_ the state in memory using `useState`\n- _Remove_ any non-essential state variables\n- _Connect_ the event handlers to set the state\n### `onClick={handleClick}`\n- 📌[Click](DB-React-Components/Click)\n- 📌[UpdateClick](DB-React-Components/UpdateClick)\n- 📌[RemoveBg](DB-React-Components/RemoveBg)\n- 📌[Gallery](DB-React-Components/Gallery)\n  - Store Boolean as state\n  - Conditional rendering\n  - `handleNextClick(){}`\n  - `handleMoreClick(){}`\n### `onSubmit` (Form Handling)\n- 📌[Quiz](DB-React-Components/Quiz)\n  - `async function`\n    - `try {await...} catch (err) {...}`\n  - `new Promise((resolve, reject) =>{ })`\n    - `setTimeout()`\n    - `new Error()`\n- 📌[EditProfile](DB-React-Components/EditProfile)\n### `onChange` (input text & checkbox)\n- `onChange={(e) => onFilterTextChange(e.target.value)}`\n- `onChange={(e) => onInStockOnlyChange(e.target.checked)}`\n- 🏷️Table\n  - 📌[ProductTableApp](DB-React-Components/ProductTableApp)\n  - 📌[FilterList](DB-React-Components/FilterList)\n- 📌[MailSelect](DB-React-Components/MailSelect)\n### `onFocus` & `onPointerMove`\n- 📌[MailHighlight](DB-React-Components/MailHighlight) (Highlight & Star)\n## Questions\n#### React 事件绑定原理\n#### React 组件中怎么做事件代理？它的原理是什么？\n#### [`<div onClick={handlerClick}>单击</div>`和`<div onClick={handlerClick(1)}>单击</div>`有什么区别？](https://github.com/haizlin/fe-interview/issues/830)\njsx 事件 = 函数，会调用函数并把函数的返回值记录，在每次 render 时调用  \n因此，handleClick 会随事件触发调用，handleClick() 只会调用一次\n#### [在 React 中什么是合成事件？有什么用？](https://github.com/haizlin/fe-interview/issues/713)\n#### [举例说明如何在 React 创建一个事件](https://github.com/haizlin/fe-interview/issues/850)\n#### [怎样将事件传递给子组件？](https://github.com/haizlin/fe-interview/issues/892)\n#### [在 React 中怎么将参数传递给事件？](https://github.com/haizlin/fe-interview/issues/876)\n#### [React 的事件和普通的 HTML 事件有什么不同？](https://github.com/haizlin/fe-interview/issues/875)\n#### [在 React 中怎么阻止事件的默认行为？](https://github.com/haizlin/fe-interview/issues/874)\n#### [组件卸载前，加在 DOM 元素的监听事件和定时器要不要手动清除？为什么？](https://github.com/haizlin/fe-interview/issues/840)\n#### [React 的触摸事件有哪几种？](https://github.com/haizlin/fe-interview/issues/834)\n#### [请描述下事件在 React 中的处理方式是什么？](https://github.com/haizlin/fe-interview/issues/662)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"react-event-事件机制",text:"React Event-事件机制#"},{depth:2,slug:"合成事件机制-syntheticevent",text:"合成事件机制 (SyntheticEvent)#"},{depth:4,slug:"什么是合成事件",text:"什么是合成事件#"},{depth:4,slug:"实现合成事件的目的",text:"实现合成事件的目的：#"},{depth:4,slug:"具体细节",text:"具体细节#"},{depth:2,slug:"basics",text:"Basics#"},{depth:3,slug:"onclickhandleclick",text:"onClick={handleClick}#"},{depth:3,slug:"onsubmit-form-handling",text:"onSubmit (Form Handling)#"},{depth:3,slug:"onchange-input-text--checkbox",text:"onChange (input text & checkbox)#"},{depth:3,slug:"onfocus--onpointermove",text:"onFocus & onPointerMove#"},{depth:2,slug:"questions",text:"Questions#"},{depth:4,slug:"react-事件绑定原理",text:"React 事件绑定原理#"},{depth:4,slug:"react-组件中怎么做事件代理它的原理是什么",text:"React 组件中怎么做事件代理？它的原理是什么？#"},{depth:4,slug:"div-onclickhandlerclick单击div和div-onclickhandlerclick1单击div有什么区别",text:"<div onClick={handlerClick}>单击</div>和<div onClick={handlerClick(1)}>单击</div>有什么区别？#"},{depth:4,slug:"在-react-中什么是合成事件有什么用",text:"在 React 中什么是合成事件？有什么用？#"},{depth:4,slug:"举例说明如何在-react-创建一个事件",text:"举例说明如何在 React 创建一个事件#"},{depth:4,slug:"怎样将事件传递给子组件",text:"怎样将事件传递给子组件？#"},{depth:4,slug:"在-react-中怎么将参数传递给事件",text:"在 React 中怎么将参数传递给事件？#"},{depth:4,slug:"react-的事件和普通的-html-事件有什么不同",text:"React 的事件和普通的 HTML 事件有什么不同？#"},{depth:4,slug:"在-react-中怎么阻止事件的默认行为",text:"在 React 中怎么阻止事件的默认行为？#"},{depth:4,slug:"组件卸载前加在-dom-元素的监听事件和定时器要不要手动清除为什么",text:"组件卸载前，加在 DOM 元素的监听事件和定时器要不要手动清除？为什么？#"},{depth:4,slug:"react-的触摸事件有哪几种",text:"React 的触摸事件有哪几种？#"},{depth:4,slug:"请描述下事件在-react-中的处理方式是什么",text:"请描述下事件在 React 中的处理方式是什么？#"}]}const Content=createComponent(((e,n,t)=>{const{layout:a,...i}=frontmatter;return i.file=file,i.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),reactEvent_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,reactEvent_____,slug};