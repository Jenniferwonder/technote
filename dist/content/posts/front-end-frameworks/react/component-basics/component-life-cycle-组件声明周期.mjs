import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="front-end-frameworks/react/component-basics/component-life-cycle-组件声明周期.md",collection="posts",slug="front-end-frameworks/react/component-basics/component-life-cycle-组件声明周期",body="# Component Life Cycle\nReact 的生命周期方法可分为三个主要阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。以下是 React 的类组件生命周期方法。需要注意的是，React 16.3 版本后引入了新的生命周期方法，废弃了一些旧的方法。\n### 挂载阶段（Mounting）\n这个阶段涉及到组件在 DOM 中创建和插入的过程。\n- constructor：构造函数，用于初始化组件的状态（state）和绑定事件处理器。\n- static getDerivedStateFromProps：在组件实例创建后和渲染前调用。根据传入的 props 计算出新的状态，返回一个用于更新状态的对象。这是一个静态方法，不能在其中使用 `this`\n- render：用于创建虚拟 DOM，并返回要渲染的 JSX 结构。这是一个纯函数，不应在其中执行任何副作用操作。\n- componentDidMount：在组件挂载到 DOM 后立即调用。常用于触发 AJAX 请求、DOM 操作、添加事件监听等副作用操作。\n### 更新阶段（Updating）\n当组件的状态（state）或属性（props）发生变化时，组件将重新渲染。这个阶段涉及到组件的更新过程。\n- static getDerivedStateFromProps：与挂载阶段中的相同，当组件接收到新的属性时调用。\n- shouldComponentUpdate：在重新渲染之前调用，可以根据变化的状态和属性来决定是否需要重新渲染。返回一个布尔值，如果为 false，则阻止组件更新。\n- render：与挂载阶段中的相同，重新渲染组件。\n- getSnapshotBeforeUpdate：在 DOM 更新之前获取快照，用于在 componentDidUpdate 中比较新旧 DOM。返回一个值或 null，作为 componentDidUpdate 的第三个参数。\n- componentDidUpdate：在组件更新并重新渲染后调用。常用于触发 AJAX 请求、DOM 操作、更新事件监听等副作用操作。\n### 卸载阶段（Unmounting）\n- 当组件从 DOM 中移除时，进入卸载阶段。\n- componentWillUnmount：在组件卸载前调用。\n- 用于清理组件产生的副作用，如取消 AJAX 请求、移除事件监听等。  \n需要注意的是，React 16.8 引入了 Hooks，它允许在函数组件中使用状态和生命周期特性。使用 `useState`、`useEffect` 和其他 Hooks 可以在函数组件中实现类似的生命周期行为。\n### Questions\n#### [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n#### [React16 废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n#### [React 的 isMounted 有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n#### [React 中修改 prop 引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n#### [React 中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n#### [说说 React 的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)",data={title:"Component Life Cycle",DateStarted:new Date(1718496e6),draft:!1,tags:["React"],category:"Front-End Frameworks"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/component-life-cycle-组件声明周期.md",rawData:void 0},html='<h1 id="component-life-cycle">Component Life Cycle<a class="anchor" href="#component-life-cycle"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<p>React 的生命周期方法可分为三个主要阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。以下是 React 的类组件生命周期方法。需要注意的是，React 16.3 版本后引入了新的生命周期方法，废弃了一些旧的方法。</p>\n<h3 id="挂载阶段mounting">挂载阶段（Mounting）<a class="anchor" href="#挂载阶段mounting"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>这个阶段涉及到组件在 DOM 中创建和插入的过程。</p>\n<ul>\n<li>constructor：构造函数，用于初始化组件的状态（state）和绑定事件处理器。</li>\n<li>static getDerivedStateFromProps：在组件实例创建后和渲染前调用。根据传入的 props 计算出新的状态，返回一个用于更新状态的对象。这是一个静态方法，不能在其中使用 <code>this</code></li>\n<li>render：用于创建虚拟 DOM，并返回要渲染的 JSX 结构。这是一个纯函数，不应在其中执行任何副作用操作。</li>\n<li>componentDidMount：在组件挂载到 DOM 后立即调用。常用于触发 AJAX 请求、DOM 操作、添加事件监听等副作用操作。</li>\n</ul>\n<h3 id="更新阶段updating">更新阶段（Updating）<a class="anchor" href="#更新阶段updating"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>当组件的状态（state）或属性（props）发生变化时，组件将重新渲染。这个阶段涉及到组件的更新过程。</p>\n<ul>\n<li>static getDerivedStateFromProps：与挂载阶段中的相同，当组件接收到新的属性时调用。</li>\n<li>shouldComponentUpdate：在重新渲染之前调用，可以根据变化的状态和属性来决定是否需要重新渲染。返回一个布尔值，如果为 false，则阻止组件更新。</li>\n<li>render：与挂载阶段中的相同，重新渲染组件。</li>\n<li>getSnapshotBeforeUpdate：在 DOM 更新之前获取快照，用于在 componentDidUpdate 中比较新旧 DOM。返回一个值或 null，作为 componentDidUpdate 的第三个参数。</li>\n<li>componentDidUpdate：在组件更新并重新渲染后调用。常用于触发 AJAX 请求、DOM 操作、更新事件监听等副作用操作。</li>\n</ul>\n<h3 id="卸载阶段unmounting">卸载阶段（Unmounting）<a class="anchor" href="#卸载阶段unmounting"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>当组件从 DOM 中移除时，进入卸载阶段。</li>\n<li>componentWillUnmount：在组件卸载前调用。</li>\n<li>用于清理组件产生的副作用，如取消 AJAX 请求、移除事件监听等。<br>\n需要注意的是，React 16.8 引入了 Hooks，它允许在函数组件中使用状态和生命周期特性。使用 <code>useState</code>、<code>useEffect</code> 和其他 Hooks 可以在函数组件中实现类似的生命周期行为。</li>\n</ul>\n<h3 id="questions">Questions<a class="anchor" href="#questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="函数式组件有没有生命周期为什么"><a href="https://github.com/haizlin/fe-interview/issues/836">函数式组件有没有生命周期？为什么？</a><a class="anchor" href="#函数式组件有没有生命周期为什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react16-废弃了哪些生命周期为什么"><a href="https://github.com/haizlin/fe-interview/issues/794">React16 废弃了哪些生命周期？为什么？</a><a class="anchor" href="#react16-废弃了哪些生命周期为什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-的-ismounted-有什么作用"><a href="https://github.com/haizlin/fe-interview/issues/799">React 的 isMounted 有什么作用？</a><a class="anchor" href="#react-的-ismounted-有什么作用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-中修改-prop-引发的生命周期有哪几个"><a href="https://github.com/haizlin/fe-interview/issues/686">React 中修改 prop 引发的生命周期有哪几个？</a><a class="anchor" href="#react-中修改-prop-引发的生命周期有哪几个"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="react-中发起网络请求应该在哪个生命周期中进行为什么"><a href="https://github.com/haizlin/fe-interview/issues/628">React 中发起网络请求应该在哪个生命周期中进行？为什么？</a><a class="anchor" href="#react-中发起网络请求应该在哪个生命周期中进行为什么"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<h4 id="说说-react-的生命周期有哪些"><a href="https://github.com/haizlin/fe-interview/issues/627">说说 React 的生命周期有哪些？</a><a class="anchor" href="#说说-react-的生命周期有哪些"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>',frontmatter={aliases:["Component Life Cycle"],title:"Component Life Cycle",topic:null,type:"D",tags:["React"],category:"Front-End Frameworks",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,draft:!1,DateStarted:"2024-06-16T00:00:00.000Z",DateModified:"2024-06-16T00:00:00.000Z","linter-yaml-title-alias":"Component Life Cycle",minutes:3,words:667},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/front-end-frameworks/react/component-basics/component-life-cycle-组件声明周期.md",url=void 0;function rawContent(){return"# Component Life Cycle\nReact 的生命周期方法可分为三个主要阶段：挂载阶段（Mounting）、更新阶段（Updating）和卸载阶段（Unmounting）。以下是 React 的类组件生命周期方法。需要注意的是，React 16.3 版本后引入了新的生命周期方法，废弃了一些旧的方法。\n### 挂载阶段（Mounting）\n这个阶段涉及到组件在 DOM 中创建和插入的过程。\n- constructor：构造函数，用于初始化组件的状态（state）和绑定事件处理器。\n- static getDerivedStateFromProps：在组件实例创建后和渲染前调用。根据传入的 props 计算出新的状态，返回一个用于更新状态的对象。这是一个静态方法，不能在其中使用 `this`\n- render：用于创建虚拟 DOM，并返回要渲染的 JSX 结构。这是一个纯函数，不应在其中执行任何副作用操作。\n- componentDidMount：在组件挂载到 DOM 后立即调用。常用于触发 AJAX 请求、DOM 操作、添加事件监听等副作用操作。\n### 更新阶段（Updating）\n当组件的状态（state）或属性（props）发生变化时，组件将重新渲染。这个阶段涉及到组件的更新过程。\n- static getDerivedStateFromProps：与挂载阶段中的相同，当组件接收到新的属性时调用。\n- shouldComponentUpdate：在重新渲染之前调用，可以根据变化的状态和属性来决定是否需要重新渲染。返回一个布尔值，如果为 false，则阻止组件更新。\n- render：与挂载阶段中的相同，重新渲染组件。\n- getSnapshotBeforeUpdate：在 DOM 更新之前获取快照，用于在 componentDidUpdate 中比较新旧 DOM。返回一个值或 null，作为 componentDidUpdate 的第三个参数。\n- componentDidUpdate：在组件更新并重新渲染后调用。常用于触发 AJAX 请求、DOM 操作、更新事件监听等副作用操作。\n### 卸载阶段（Unmounting）\n- 当组件从 DOM 中移除时，进入卸载阶段。\n- componentWillUnmount：在组件卸载前调用。\n- 用于清理组件产生的副作用，如取消 AJAX 请求、移除事件监听等。  \n需要注意的是，React 16.8 引入了 Hooks，它允许在函数组件中使用状态和生命周期特性。使用 `useState`、`useEffect` 和其他 Hooks 可以在函数组件中实现类似的生命周期行为。\n### Questions\n#### [函数式组件有没有生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/836)\n#### [React16 废弃了哪些生命周期？为什么？](https://github.com/haizlin/fe-interview/issues/794)\n#### [React 的 isMounted 有什么作用？](https://github.com/haizlin/fe-interview/issues/799)\n#### [React 中修改 prop 引发的生命周期有哪几个？](https://github.com/haizlin/fe-interview/issues/686)\n#### [React 中发起网络请求应该在哪个生命周期中进行？为什么？](https://github.com/haizlin/fe-interview/issues/628)\n#### [说说 React 的生命周期有哪些？](https://github.com/haizlin/fe-interview/issues/627)"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"component-life-cycle",text:"Component Life Cycle#"},{depth:3,slug:"挂载阶段mounting",text:"挂载阶段（Mounting）#"},{depth:3,slug:"更新阶段updating",text:"更新阶段（Updating）#"},{depth:3,slug:"卸载阶段unmounting",text:"卸载阶段（Unmounting）#"},{depth:3,slug:"questions",text:"Questions#"},{depth:4,slug:"函数式组件有没有生命周期为什么",text:"函数式组件有没有生命周期？为什么？#"},{depth:4,slug:"react16-废弃了哪些生命周期为什么",text:"React16 废弃了哪些生命周期？为什么？#"},{depth:4,slug:"react-的-ismounted-有什么作用",text:"React 的 isMounted 有什么作用？#"},{depth:4,slug:"react-中修改-prop-引发的生命周期有哪几个",text:"React 中修改 prop 引发的生命周期有哪几个？#"},{depth:4,slug:"react-中发起网络请求应该在哪个生命周期中进行为什么",text:"React 中发起网络请求应该在哪个生命周期中进行？为什么？#"},{depth:4,slug:"说说-react-的生命周期有哪些",text:"说说 React 的生命周期有哪些？#"}]}const Content=createComponent(((e,t,n)=>{const{layout:o,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),componentLifeCycle_______=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,componentLifeCycle_______,data,id,slug};