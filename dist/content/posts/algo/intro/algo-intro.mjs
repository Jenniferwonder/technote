import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="algo/intro/algo-intro.md",collection="posts",slug="algo/intro/algo-intro",body="\n# Algo Intro\n\n## 2.4 　算法定义\n\n### 算法是描述解决问题的方法\n\n### 算法是解决特定问题求解步骤的描述，在计算机中表现为指令 的有限序列，并且每条指令表示一个或多个操作\n\n## 2.5 　算法的特性\n\n### 2.5.1 　输入输出\n\n- 此算法的输入可 以是零个。算法至少有一个或多个输出\n\n### 2.5.2 　有穷性\n\n### 2.5.3 　确定性\n\n### 2.5.4 　可行性\n\n## 2.6 　算法设计的要求\n\n### 2.6.1 　正确性\n\n### 2.6.2 　可读性\n\n### 2.6.3 　健壮性\n\n### 2.6.4 　时间效率高和存储量低\n\n## 2.7 　算法效率的度量方法\n\n### 2.7.1 　事后统计方法\n\n### 2.7.2 　事前分析估算方法\n\n## 2.8 　函数的渐近增长\n\n## ⭐2.9 　算法时间复杂度\n\n### 2.9.1 　算法时间复杂度定义\n\n- 表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同\n\n### 2.9.2 　推导大 O 阶方法\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693563772552.png)\n\n### 2.9.3 　常数阶 O(1)\n\n- 与问题的大小无关（n 的多少），执行时间恒定的算法\n\n### 2.9.4 　线性阶 O(n)\n\n- 单循环 O(1)\n\n### 2.9.5 　对数阶 O(logn)\n\n- 单循环中包含 `count = count * 2`\n\n### 2.9.6 　平方阶 O(n^2)\n\n- 循环嵌套 O(1)\n\n### 2.10 　常见的时间复杂度\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560064778.png)\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560075885.png)\n\n## ⭐2.12 　算法空间复杂度\n\n### 可以用空间来换取时间\n\n### 当不用限定词地使用“复杂度”时，通常都是指时间复杂 度\n",data={title:"Algo Intro",DateStarted:new Date(16940448e5),draft:!0,tags:["Algo"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/intro/algo-intro.md",rawData:void 0},html='<h1 id="algo-intro">Algo Intro<a class="anchor" href="#algo-intro"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="24-算法定义">2.4 　算法定义<a class="anchor" href="#24-算法定义"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="算法是描述解决问题的方法">算法是描述解决问题的方法<a class="anchor" href="#算法是描述解决问题的方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="算法是解决特定问题求解步骤的描述在计算机中表现为指令-的有限序列并且每条指令表示一个或多个操作">算法是解决特定问题求解步骤的描述，在计算机中表现为指令 的有限序列，并且每条指令表示一个或多个操作<a class="anchor" href="#算法是解决特定问题求解步骤的描述在计算机中表现为指令-的有限序列并且每条指令表示一个或多个操作"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="25-算法的特性">2.5 　算法的特性<a class="anchor" href="#25-算法的特性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="251-输入输出">2.5.1 　输入输出<a class="anchor" href="#251-输入输出"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>此算法的输入可 以是零个。算法至少有一个或多个输出</li>\n</ul>\n<h3 id="252-有穷性">2.5.2 　有穷性<a class="anchor" href="#252-有穷性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="253-确定性">2.5.3 　确定性<a class="anchor" href="#253-确定性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="254-可行性">2.5.4 　可行性<a class="anchor" href="#254-可行性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="26-算法设计的要求">2.6 　算法设计的要求<a class="anchor" href="#26-算法设计的要求"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="261-正确性">2.6.1 　正确性<a class="anchor" href="#261-正确性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="262-可读性">2.6.2 　可读性<a class="anchor" href="#262-可读性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="263-健壮性">2.6.3 　健壮性<a class="anchor" href="#263-健壮性"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="264-时间效率高和存储量低">2.6.4 　时间效率高和存储量低<a class="anchor" href="#264-时间效率高和存储量低"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="27-算法效率的度量方法">2.7 　算法效率的度量方法<a class="anchor" href="#27-算法效率的度量方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="271-事后统计方法">2.7.1 　事后统计方法<a class="anchor" href="#271-事后统计方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="272-事前分析估算方法">2.7.2 　事前分析估算方法<a class="anchor" href="#272-事前分析估算方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="28-函数的渐近增长">2.8 　函数的渐近增长<a class="anchor" href="#28-函数的渐近增长"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="29-算法时间复杂度">⭐2.9 　算法时间复杂度<a class="anchor" href="#29-算法时间复杂度"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="291-算法时间复杂度定义">2.9.1 　算法时间复杂度定义<a class="anchor" href="#291-算法时间复杂度定义"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同</li>\n</ul>\n<h3 id="292-推导大-o-阶方法">2.9.2 　推导大 O 阶方法<a class="anchor" href="#292-推导大-o-阶方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693563772552.png" alt=""></li>\n</ul>\n<h3 id="293-常数阶-o1">2.9.3 　常数阶 O(1)<a class="anchor" href="#293-常数阶-o1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>与问题的大小无关（n 的多少），执行时间恒定的算法</li>\n</ul>\n<h3 id="294-线性阶-on">2.9.4 　线性阶 O(n)<a class="anchor" href="#294-线性阶-on"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>单循环 O(1)</li>\n</ul>\n<h3 id="295-对数阶-ologn">2.9.5 　对数阶 O(logn)<a class="anchor" href="#295-对数阶-ologn"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>单循环中包含 <code>count = count * 2</code></li>\n</ul>\n<h3 id="296-平方阶-on2">2.9.6 　平方阶 O(n^2)<a class="anchor" href="#296-平方阶-on2"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>循环嵌套 O(1)</li>\n</ul>\n<h3 id="210-常见的时间复杂度">2.10 　常见的时间复杂度<a class="anchor" href="#210-常见的时间复杂度"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560064778.png" alt=""></li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560075885.png" alt=""></li>\n</ul>\n<h2 id="212-算法空间复杂度">⭐2.12 　算法空间复杂度<a class="anchor" href="#212-算法空间复杂度"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="可以用空间来换取时间">可以用空间来换取时间<a class="anchor" href="#可以用空间来换取时间"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h3 id="当不用限定词地使用复杂度时通常都是指时间复杂-度">当不用限定词地使用“复杂度”时，通常都是指时间复杂 度<a class="anchor" href="#当不用限定词地使用复杂度时通常都是指时间复杂-度"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>',frontmatter={Datereviewed:null,reviewed:null,difficulty:null,comment:null,aliases:["Algo Intro"],draft:!0,title:"Algo Intro",type:"D",topic:["Algo"],DateStarted:"2023-09-07T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",status:null,category:"Programming",tags:["Algo"],"linter-yaml-title-alias":"Algo Intro",minutes:2,words:364},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/intro/algo-intro.md",url=void 0;function rawContent(){return"\n# Algo Intro\n\n## 2.4 　算法定义\n\n### 算法是描述解决问题的方法\n\n### 算法是解决特定问题求解步骤的描述，在计算机中表现为指令 的有限序列，并且每条指令表示一个或多个操作\n\n## 2.5 　算法的特性\n\n### 2.5.1 　输入输出\n\n- 此算法的输入可 以是零个。算法至少有一个或多个输出\n\n### 2.5.2 　有穷性\n\n### 2.5.3 　确定性\n\n### 2.5.4 　可行性\n\n## 2.6 　算法设计的要求\n\n### 2.6.1 　正确性\n\n### 2.6.2 　可读性\n\n### 2.6.3 　健壮性\n\n### 2.6.4 　时间效率高和存储量低\n\n## 2.7 　算法效率的度量方法\n\n### 2.7.1 　事后统计方法\n\n### 2.7.2 　事前分析估算方法\n\n## 2.8 　函数的渐近增长\n\n## ⭐2.9 　算法时间复杂度\n\n### 2.9.1 　算法时间复杂度定义\n\n- 表示随问题规模 n 的增大，算法执行时间的增长率和 f(n)的增长率相同\n\n### 2.9.2 　推导大 O 阶方法\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693563772552.png)\n\n### 2.9.3 　常数阶 O(1)\n\n- 与问题的大小无关（n 的多少），执行时间恒定的算法\n\n### 2.9.4 　线性阶 O(n)\n\n- 单循环 O(1)\n\n### 2.9.5 　对数阶 O(logn)\n\n- 单循环中包含 `count = count * 2`\n\n### 2.9.6 　平方阶 O(n^2)\n\n- 循环嵌套 O(1)\n\n### 2.10 　常见的时间复杂度\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560064778.png)\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1693560075885.png)\n\n## ⭐2.12 　算法空间复杂度\n\n### 可以用空间来换取时间\n\n### 当不用限定词地使用“复杂度”时，通常都是指时间复杂 度\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"algo-intro",text:"Algo Intro#"},{depth:2,slug:"24-算法定义",text:"2.4 　算法定义#"},{depth:3,slug:"算法是描述解决问题的方法",text:"算法是描述解决问题的方法#"},{depth:3,slug:"算法是解决特定问题求解步骤的描述在计算机中表现为指令-的有限序列并且每条指令表示一个或多个操作",text:"算法是解决特定问题求解步骤的描述，在计算机中表现为指令 的有限序列，并且每条指令表示一个或多个操作#"},{depth:2,slug:"25-算法的特性",text:"2.5 　算法的特性#"},{depth:3,slug:"251-输入输出",text:"2.5.1 　输入输出#"},{depth:3,slug:"252-有穷性",text:"2.5.2 　有穷性#"},{depth:3,slug:"253-确定性",text:"2.5.3 　确定性#"},{depth:3,slug:"254-可行性",text:"2.5.4 　可行性#"},{depth:2,slug:"26-算法设计的要求",text:"2.6 　算法设计的要求#"},{depth:3,slug:"261-正确性",text:"2.6.1 　正确性#"},{depth:3,slug:"262-可读性",text:"2.6.2 　可读性#"},{depth:3,slug:"263-健壮性",text:"2.6.3 　健壮性#"},{depth:3,slug:"264-时间效率高和存储量低",text:"2.6.4 　时间效率高和存储量低#"},{depth:2,slug:"27-算法效率的度量方法",text:"2.7 　算法效率的度量方法#"},{depth:3,slug:"271-事后统计方法",text:"2.7.1 　事后统计方法#"},{depth:3,slug:"272-事前分析估算方法",text:"2.7.2 　事前分析估算方法#"},{depth:2,slug:"28-函数的渐近增长",text:"2.8 　函数的渐近增长#"},{depth:2,slug:"29-算法时间复杂度",text:"⭐2.9 　算法时间复杂度#"},{depth:3,slug:"291-算法时间复杂度定义",text:"2.9.1 　算法时间复杂度定义#"},{depth:3,slug:"292-推导大-o-阶方法",text:"2.9.2 　推导大 O 阶方法#"},{depth:3,slug:"293-常数阶-o1",text:"2.9.3 　常数阶 O(1)#"},{depth:3,slug:"294-线性阶-on",text:"2.9.4 　线性阶 O(n)#"},{depth:3,slug:"295-对数阶-ologn",text:"2.9.5 　对数阶 O(logn)#"},{depth:3,slug:"296-平方阶-on2",text:"2.9.6 　平方阶 O(n^2)#"},{depth:3,slug:"210-常见的时间复杂度",text:"2.10 　常见的时间复杂度#"},{depth:2,slug:"212-算法空间复杂度",text:"⭐2.12 　算法空间复杂度#"},{depth:3,slug:"可以用空间来换取时间",text:"可以用空间来换取时间#"},{depth:3,slug:"当不用限定词地使用复杂度时通常都是指时间复杂-度",text:"当不用限定词地使用“复杂度”时，通常都是指时间复杂 度#"}]}const Content=createComponent(((n,a,e)=>{const{layout:t,...o}=frontmatter;return o.file=file,o.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),algoIntro=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,algoIntro,body,collection,data,id,slug};