import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="algo/searching-(ds)/hash-table/1.两数之和 (Two-Sums).md",collection="posts",slug="algo/searching-ds/hash-table/1两数之和-two-sums",body="\n# 1.两数之和 (Two-Sums)\n\n## 解题思路与知识提炼\n\n本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组\n\n### [核心方法](核心方法)\n\n- [核心方法 > 嵌套循环](核心方法#嵌套循环)：不重复元素\n- [核心方法 > Hash Table 哈希表](核心方法#Hash-Table-哈希表)\n- [核心方法 > 求和](核心方法#求和)\n\n### [代码优化考虑](代码优化考虑)\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 `O(n)`，空间复杂度 `O(n)`，用 JavaScript 实现如下：\n\n```js\n\n```\n\n## 实现过程说明\n\n### 一、确定变量\n\n1. 思考给定变量或已知变量:\n   - 未排序的区间数组 `intervals`\n2. 定义其他需要的输入、输出变量:\n   - $ 按照左端点升序排序后的区间数组 `intervals.sort((a, b) => a[0] - b[0])`\n   - $ 待返回的新区间数组 `merged`\n   - 待加入的区间 `prev`\n   - 当前对比区间 `cur` 或 `currentInterval`\n\n### 二、确定循环条件\n\n1. 依次比较区间数组中的每个区间：\n   - 一版：`for (i = 0; i < intervals.length; i++)`\n   - 二版：`for (const currentInterval of Intervals)`\n2. 判断<font color=#F36208>当前区间的首位</font>是否大于<font color=#F36208>待加入区间末位</font>\n   - 若是，则两区间无重合可能\n     - $\n   - 若否，对比两区间末位\n     - $\n\n### 三、测试、绘图可视化\n\n> 这一步可用 VS Code Debugger (Node) + DrawIO 绘图：\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-56.svg)\n",data={title:"1.两数之和 (Two-Sums)",DateStarted:new Date(16941312e5),draft:!1,tags:["Algo"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/searching-(ds)/hash-table/1.两数之和 (Two-Sums).md",rawData:void 0},html='<h1 id="1两数之和-two-sums">1.两数之和 (Two-Sums)<a class="anchor" href="#1两数之和-two-sums"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="解题思路与知识提炼">解题思路与知识提炼<a class="anchor" href="#解题思路与知识提炼"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组</p>\n<h3 id="核心方法"><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">核心方法</a><a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF">核心方法 > 嵌套循环</a>：不重复元素</li>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#Hash-Table-%E5%93%88%E5%B8%8C%E8%A1%A8">核心方法 > Hash Table 哈希表</a></li>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E6%B1%82%E5%92%8C">核心方法 > 求和</a></li>\n</ul>\n<h3 id="代码优化考虑"><a href="%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%E8%80%83%E8%99%91">代码优化考虑</a><a class="anchor" href="#代码优化考虑"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h2 id="代码实现-js">代码实现 (JS)<a class="anchor" href="#代码实现-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本方案可满足时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(n)</code>，用 JavaScript 实现如下：</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"></span></code></pre>\n<h2 id="实现过程说明">实现过程说明<a class="anchor" href="#实现过程说明"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="一确定变量">一、确定变量<a class="anchor" href="#一确定变量"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>思考给定变量或已知变量:\n<ul>\n<li>未排序的区间数组 <code>intervals</code></li>\n</ul>\n</li>\n<li>定义其他需要的输入、输出变量:\n<ul>\n<li>$ 按照左端点升序排序后的区间数组 <code>intervals.sort((a, b) => a[0] - b[0])</code></li>\n<li>$ 待返回的新区间数组 <code>merged</code></li>\n<li>待加入的区间 <code>prev</code></li>\n<li>当前对比区间 <code>cur</code> 或 <code>currentInterval</code></li>\n</ul>\n</li>\n</ol>\n<h3 id="二确定循环条件">二、确定循环条件<a class="anchor" href="#二确定循环条件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>依次比较区间数组中的每个区间：\n<ul>\n<li>一版：<code>for (i = 0; i &#x3C; intervals.length; i++)</code></li>\n<li>二版：<code>for (const currentInterval of Intervals)</code></li>\n</ul>\n</li>\n<li>判断<font color="#F36208">当前区间的首位</font>是否大于<font color="#F36208">待加入区间末位</font>\n<ul>\n<li>若是，则两区间无重合可能\n<ul>\n<li>$</li>\n</ul>\n</li>\n<li>若否，对比两区间末位\n<ul>\n<li>$</li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id="三测试绘图可视化">三、测试、绘图可视化<a class="anchor" href="#三测试绘图可视化"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>这一步可用 VS Code Debugger (Node) + DrawIO 绘图：</p>\n</blockquote>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-56.svg" alt=""></li>\n</ul>',frontmatter={tags:["Algo"],category:"Programming",draft:!1,LCID:"LC-01",title:"1.两数之和 (Two-Sums)",type:"A",Similar:[[["217.存在重复元素(Includes Duplicates)|LC-217"]]],topic:["Array","HashTable","NestedLoop"],difficulty:"Easy",Time:"O(n)",Space:"O(n)",Like:!0,Solution:"哈希表与嵌套循环",SourceLink:"https://leetcode.cn/problems/two-sums",DateStarted:"2023-09-08T00:00:00.000Z",DateDone:"2023-09-08T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",status:null,aliases:["LC-01"],Datereviewed:"2024-02-16T16:00:00.000Z",reviewed:5,TimeNeed:"Good",comment:"哈希对象定义、查值、赋值",minutes:2,words:312},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/searching-(ds)/hash-table/1.两数之和 (Two-Sums).md",url=void 0;function rawContent(){return"\n# 1.两数之和 (Two-Sums)\n\n## 解题思路与知识提炼\n\n本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组\n\n### [核心方法](核心方法)\n\n- [核心方法 > 嵌套循环](核心方法#嵌套循环)：不重复元素\n- [核心方法 > Hash Table 哈希表](核心方法#Hash-Table-哈希表)\n- [核心方法 > 求和](核心方法#求和)\n\n### [代码优化考虑](代码优化考虑)\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 `O(n)`，空间复杂度 `O(n)`，用 JavaScript 实现如下：\n\n```js\n\n```\n\n## 实现过程说明\n\n### 一、确定变量\n\n1. 思考给定变量或已知变量:\n   - 未排序的区间数组 `intervals`\n2. 定义其他需要的输入、输出变量:\n   - $ 按照左端点升序排序后的区间数组 `intervals.sort((a, b) => a[0] - b[0])`\n   - $ 待返回的新区间数组 `merged`\n   - 待加入的区间 `prev`\n   - 当前对比区间 `cur` 或 `currentInterval`\n\n### 二、确定循环条件\n\n1. 依次比较区间数组中的每个区间：\n   - 一版：`for (i = 0; i < intervals.length; i++)`\n   - 二版：`for (const currentInterval of Intervals)`\n2. 判断<font color=#F36208>当前区间的首位</font>是否大于<font color=#F36208>待加入区间末位</font>\n   - 若是，则两区间无重合可能\n     - $\n   - 若否，对比两区间末位\n     - $\n\n### 三、测试、绘图可视化\n\n> 这一步可用 VS Code Debugger (Node) + DrawIO 绘图：\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-56.svg)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"1两数之和-two-sums",text:"1.两数之和 (Two-Sums)#"},{depth:2,slug:"解题思路与知识提炼",text:"解题思路与知识提炼#"},{depth:3,slug:"核心方法",text:"核心方法#"},{depth:3,slug:"代码优化考虑",text:"代码优化考虑#"},{depth:2,slug:"代码实现-js",text:"代码实现 (JS)#"},{depth:2,slug:"实现过程说明",text:"实现过程说明#"},{depth:3,slug:"一确定变量",text:"一、确定变量#"},{depth:3,slug:"二确定循环条件",text:"二、确定循环条件#"},{depth:3,slug:"三测试绘图可视化",text:"三、测试、绘图可视化#"}]}const Content=createComponent(((n,e,a)=>{const{layout:o,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),_1_______TwoSums_=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_1_______TwoSums_,_internal,body,collection,data,id,slug};