import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1713773016041/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="algo/recursive-algorithm/dp/121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock).md",collection="posts",slug="algo/recursive-algorithm/dp/121买卖股票最佳时机-best-time-to-buy-and-sell-stock",body="\n# 121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)\n\n## 题目要求\n\n本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组\n\n## [核心方法](核心方法)\n\n- [核心方法 > 取数组中最大值](核心方法#取数组中最大值)\n\n## 关键步骤\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 `O(n)`，空间复杂度 `O(1)`，用 JavaScript 实现如下：\n\n```js\n// 一版：用 if 判断最低价格，也可用 min\nvar maxProfit = function (prices) {\n\tif (prices.length < 2) {\n\t\treturn 0;\n\t} // 初始化最低价格和最大利润\n\tlet cost = prices[0],\n\t\tmaxProfit = 0; // 遍历价格数组\n\tfor (let i = 1; i < prices.length; i++) {\n\t\t// 如果当前价格比之前记录的最低价格还低，更新最低价格\n\t\tif (prices[i] < cost) {\n\t\t\tcost = prices[i];\n\t\t} else {\n\t\t\t// 否则，计算当前卖出时的利润，并更新最大利润\n\t\t\tmaxProfit = Math.max(maxProfit, prices[i] - cost);\n\t\t}\n\t}\n\treturn maxProfit;\n};\n```\n",data={title:"121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)",DateStarted:new Date(16942176e5),draft:!1,tags:["Algo"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/recursive-algorithm/dp/121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock).md",rawData:void 0},html='<h1 id="121买卖股票最佳时机-best-time-to-buy-and-sell-stock">121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)<a class="anchor" href="#121买卖股票最佳时机-best-time-to-buy-and-sell-stock"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="题目要求">题目要求<a class="anchor" href="#题目要求"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组</p>\n<h2 id="核心方法"><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">核心方法</a><a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E5%A4%A7%E5%80%BC">核心方法 > 取数组中最大值</a></li>\n</ul>\n<h2 id="关键步骤">关键步骤<a class="anchor" href="#关键步骤"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="代码实现-js">代码实现 (JS)<a class="anchor" href="#代码实现-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本方案可满足时间复杂度 <code>O(n)</code>，空间复杂度 <code>O(1)</code>，用 JavaScript 实现如下：</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#6A737D">// 一版：用 if 判断最低价格，也可用 min</span></span>\n<span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> maxProfit</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">prices</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (prices.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> &#x3C;</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t} </span><span style="color:#6A737D">// 初始化最低价格和最大利润</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> cost </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> prices[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">],</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tmaxProfit </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// 遍历价格数组</span></span>\n<span class="line"><span style="color:#F97583">\tfor</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> prices.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t// 如果当前价格比之前记录的最低价格还低，更新最低价格</span></span>\n<span class="line"><span style="color:#F97583">\t\tif</span><span style="color:#E1E4E8"> (prices[i] </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> cost) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tcost </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> prices[i];</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// 否则，计算当前卖出时的利润，并更新最大利润</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tmaxProfit </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">max</span><span style="color:#E1E4E8">(maxProfit, prices[i] </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> cost);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> maxProfit;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>',frontmatter={tags:["Algo"],category:"Programming",draft:!1,LCID:"LC-121",title:"121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)",type:"A",Similar:[[["56.合并区间 (Merge Intervals)|LC-56"]]],topic:["Array","DP"],difficulty:"Easy",Time:"O(n)",Space:"O(1)",Like:null,Solution:"取最大值",SourceLink:"https://leetcode.cn/problems/search-insert-position",DateStarted:"2023-09-09T00:00:00.000Z",DateDone:"2023-09-09T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",status:null,aliases:["LC-121"],reviewed:7,Datereviewed:"2024-02-16T16:00:00.000Z",comment:"Min, Max",TimeNeed:"Good",minutes:1,words:228},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/recursive-algorithm/dp/121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock).md",url=void 0;function rawContent(){return"\n# 121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)\n\n## 题目要求\n\n本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组\n\n## [核心方法](核心方法)\n\n- [核心方法 > 取数组中最大值](核心方法#取数组中最大值)\n\n## 关键步骤\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 `O(n)`，空间复杂度 `O(1)`，用 JavaScript 实现如下：\n\n```js\n// 一版：用 if 判断最低价格，也可用 min\nvar maxProfit = function (prices) {\n\tif (prices.length < 2) {\n\t\treturn 0;\n\t} // 初始化最低价格和最大利润\n\tlet cost = prices[0],\n\t\tmaxProfit = 0; // 遍历价格数组\n\tfor (let i = 1; i < prices.length; i++) {\n\t\t// 如果当前价格比之前记录的最低价格还低，更新最低价格\n\t\tif (prices[i] < cost) {\n\t\t\tcost = prices[i];\n\t\t} else {\n\t\t\t// 否则，计算当前卖出时的利润，并更新最大利润\n\t\t\tmaxProfit = Math.max(maxProfit, prices[i] - cost);\n\t\t}\n\t}\n\treturn maxProfit;\n};\n```\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"121买卖股票最佳时机-best-time-to-buy-and-sell-stock",text:"121.买卖股票最佳时机 (best-time-to-buy-and-sell-stock)#"},{depth:2,slug:"题目要求",text:"题目要求#"},{depth:2,slug:"核心方法",text:"核心方法#"},{depth:2,slug:"关键步骤",text:"关键步骤#"},{depth:2,slug:"代码实现-js",text:"代码实现 (JS)#"}]}const Content=createComponent(((n,s,t)=>{const{layout:a,...e}=frontmatter;return e.file=file,e.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),_121___________bestTimeToBuyAndSellStock_=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_121___________bestTimeToBuyAndSellStock_,_internal,body,collection,data,id,slug};