import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="algo/recursive-algorithm/two-pointers/209.长度最小的子数组 (minSubArrayLen).md",collection="posts",slug="algo/recursive-algorithm/two-pointers/209长度最小的子数组-minsubarraylen",body="\n# 209.长度最小的子数组 (minSubArrayLen)\n\n## 题目要求\n\n给定一个含有  `n`  个正整数的数组和一个正整数  `target` **。**  \n找出该数组中满足其总和大于等于  `target`  的长度最小的连续子数组`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回  `0` 。\n\n## [核心方法](../../核心方法)\n## 关键步骤\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 **O(n)**，空间复杂度 **O(1)**\n\n```js\n\n```\n",data={title:"209.长度最小的子数组 (minSubArrayLen)",DateStarted:new Date(16956864e5),draft:!1,tags:["Algo"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/recursive-algorithm/two-pointers/209.长度最小的子数组 (minSubArrayLen).md",rawData:void 0},html='<h1 id="209长度最小的子数组-minsubarraylen">209.长度最小的子数组 (minSubArrayLen)<a class="anchor" href="#209长度最小的子数组-minsubarraylen"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="题目要求">题目要求<a class="anchor" href="#题目要求"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>给定一个含有  <code>n</code>  个正整数的数组和一个正整数  <code>target</code> <strong>。</strong><br>\n找出该数组中满足其总和大于等于  <code>target</code>  的长度最小的连续子数组<code>[numsl, numsl+1, ..., numsr-1, numsr]</code> ，并返回其长度。如果不存在符合条件的子数组，返回  <code>0</code> 。</p>\n<h2 id="核心方法"><a href="../../%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">核心方法</a><a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="关键步骤">关键步骤<a class="anchor" href="#关键步骤"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="代码实现-js">代码实现 (JS)<a class="anchor" href="#代码实现-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本方案可满足时间复杂度 <strong>O(n)</strong>，空间复杂度 <strong>O(1)</strong></p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"></span></code></pre>',frontmatter={tags:["Algo"],category:"Programming",draft:!1,LCID:"LC-209",title:"209.长度最小的子数组 (minSubArrayLen)",type:"A",Similar:null,topic:["Two-Pointers","Sliding-Window"],difficulty:"Medium",Time:"O(n)",Space:"O(1)",Like:null,Solution:null,SourceLink:null,DateStarted:"2023-09-26T00:00:00.000Z",DateDone:"2023-09-26T00:00:00.000Z",DateModified:"2024-04-19T00:00:00.000Z",status:null,aliases:["LC-209"],TimeNeed:"Good",comment:"起始指针，求和, 长度初始赋值Infinity",reviewed:8,Datereviewed:"2024-02-16T16:00:00.000Z",minutes:1,words:120},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/recursive-algorithm/two-pointers/209.长度最小的子数组 (minSubArrayLen).md",url=void 0;function rawContent(){return"\n# 209.长度最小的子数组 (minSubArrayLen)\n\n## 题目要求\n\n给定一个含有  `n`  个正整数的数组和一个正整数  `target` **。**  \n找出该数组中满足其总和大于等于  `target`  的长度最小的连续子数组`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度。如果不存在符合条件的子数组，返回  `0` 。\n\n## [核心方法](../../核心方法)\n## 关键步骤\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 **O(n)**，空间复杂度 **O(1)**\n\n```js\n\n```\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"209长度最小的子数组-minsubarraylen",text:"209.长度最小的子数组 (minSubArrayLen)#"},{depth:2,slug:"题目要求",text:"题目要求#"},{depth:2,slug:"核心方法",text:"核心方法#"},{depth:2,slug:"关键步骤",text:"关键步骤#"},{depth:2,slug:"代码实现-js",text:"代码实现 (JS)#"}]}const Content=createComponent(((n,e,t)=>{const{layout:r,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),_209___________minSubArrayLen_=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_209___________minSubArrayLen_,_internal,body,collection,data,id,slug};