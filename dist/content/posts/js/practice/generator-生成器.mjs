import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/practice/generator-生成器.md",collection="posts",slug="js/practice/generator-生成器",body="\n# Generator-生成器\n\n- 形式\n  - 生成器的形式是一个函数，函数 **名称前面加一个星号`（*）`**表示它是一个生成器\n  - 标识生成器函数的星号 **不受** 两侧空格的影响\n- 功能\n  - 拥有在一个函数块内 **暂停和恢复代码执行** 的能力\n  - 使用生成器可以自定义 **迭代器和实现协程**\n- 特点\n  - 只要是可以定义函数的地方，就可以定义生成器\n  - 箭头函数不能用来定义生成器函数。\n- 定义方式\n  - // 生成器函数声明\n    - function\\* generatorFn() {}\n  - // 生成器函数表达式\n    - let generatorFn = function\\* () {}\n  - // 作为对象字面量方法的生成器函数\n    - let foo = { \\* generatorFn() {} }\n  - // 作为类实例方法的生成器函数\n    - class Foo { \\* generatorFn() {} }\n  - // 作为类静态方法的生成器函数\n    - class Bar { static \\* generatorFn() {} }\n- 生成器对象\n  - 一开始处于暂停执行（suspended）的 状 态\n  - 生成器对象也实现了 Iterator 接口，因此具有 next()方法\n    - 调用这个方法会让生成器 开始或恢复执行。\n    - 生成器函数只会在初次调用 **`next()`方法**后开始执行\n    - next()方法的返回值\n      - done 属性\n        - 函数体为空的生成器 函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态\n      - value 属性\n        - value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定\n  - 生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的\n- 通过 yield 中断执行-Interrupting Execution\n  - 特点\n    - yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方\n    - yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误\n    - 出现在嵌套的非生成器函数中会抛出语法错误\n  - 生成器对象作为可迭代对象 (Iterable)\n    - 在生成器对象上显式调用 next()方法的用处并不大\n    - 如果把生成器对象当成可迭代对象， 那么使用起来会更方便\n  - 使用 yield 实现输入和输出\n  - 产生可迭代对象-Yielding an Iterable\n  - 使用 `yield*`实现递归算法\n- 生成器作为默认迭代器-Using a Generator as the Default Iterator\n- 提前终止生成器-Early Termination of Generators - The return() Method - The throw() Method\n",data={title:"Generator-生成器",DateStarted:new Date(16918848e5),draft:!0,tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/practice/generator-生成器.md",rawData:void 0},html='<h1 id="generator-生成器">Generator-生成器<a class="anchor" href="#generator-生成器"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<ul>\n<li>形式\n<ul>\n<li>生成器的形式是一个函数，函数 **名称前面加一个星号<code>（*）</code>**表示它是一个生成器</li>\n<li>标识生成器函数的星号 <strong>不受</strong> 两侧空格的影响</li>\n</ul>\n</li>\n<li>功能\n<ul>\n<li>拥有在一个函数块内 <strong>暂停和恢复代码执行</strong> 的能力</li>\n<li>使用生成器可以自定义 <strong>迭代器和实现协程</strong></li>\n</ul>\n</li>\n<li>特点\n<ul>\n<li>只要是可以定义函数的地方，就可以定义生成器</li>\n<li>箭头函数不能用来定义生成器函数。</li>\n</ul>\n</li>\n<li>定义方式\n<ul>\n<li>// 生成器函数声明\n<ul>\n<li>function* generatorFn() {}</li>\n</ul>\n</li>\n<li>// 生成器函数表达式\n<ul>\n<li>let generatorFn = function* () {}</li>\n</ul>\n</li>\n<li>// 作为对象字面量方法的生成器函数\n<ul>\n<li>let foo = { * generatorFn() {} }</li>\n</ul>\n</li>\n<li>// 作为类实例方法的生成器函数\n<ul>\n<li>class Foo { * generatorFn() {} }</li>\n</ul>\n</li>\n<li>// 作为类静态方法的生成器函数\n<ul>\n<li>class Bar { static * generatorFn() {} }</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生成器对象\n<ul>\n<li>一开始处于暂停执行（suspended）的 状 态</li>\n<li>生成器对象也实现了 Iterator 接口，因此具有 next()方法\n<ul>\n<li>调用这个方法会让生成器 开始或恢复执行。</li>\n<li>生成器函数只会在初次调用 <strong><code>next()</code>方法</strong>后开始执行</li>\n<li>next()方法的返回值\n<ul>\n<li>done 属性\n<ul>\n<li>函数体为空的生成器 函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态</li>\n</ul>\n</li>\n<li>value 属性\n<ul>\n<li>value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的</li>\n</ul>\n</li>\n<li>通过 yield 中断执行-Interrupting Execution\n<ul>\n<li>特点\n<ul>\n<li>yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方</li>\n<li>yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误</li>\n<li>出现在嵌套的非生成器函数中会抛出语法错误</li>\n</ul>\n</li>\n<li>生成器对象作为可迭代对象 (Iterable)\n<ul>\n<li>在生成器对象上显式调用 next()方法的用处并不大</li>\n<li>如果把生成器对象当成可迭代对象， 那么使用起来会更方便</li>\n</ul>\n</li>\n<li>使用 yield 实现输入和输出</li>\n<li>产生可迭代对象-Yielding an Iterable</li>\n<li>使用 <code>yield*</code>实现递归算法</li>\n</ul>\n</li>\n<li>生成器作为默认迭代器-Using a Generator as the Default Iterator</li>\n<li>提前终止生成器-Early Termination of Generators - The return() Method - The throw() Method</li>\n</ul>',frontmatter={Datereviewed:null,reviewed:null,difficulty:null,comment:null,title:"Generator-生成器",type:"D",DateStarted:"2023-08-13T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:["Young"],aliases:["Generator-生成器","Generator","生成器"],topic:["Practice"],category:"Programming",tags:["JavaScript"],draft:!0,"linter-yaml-title-alias":"Generator-生成器",minutes:3,words:614},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/practice/generator-生成器.md",url=void 0;function rawContent(){return"\n# Generator-生成器\n\n- 形式\n  - 生成器的形式是一个函数，函数 **名称前面加一个星号`（*）`**表示它是一个生成器\n  - 标识生成器函数的星号 **不受** 两侧空格的影响\n- 功能\n  - 拥有在一个函数块内 **暂停和恢复代码执行** 的能力\n  - 使用生成器可以自定义 **迭代器和实现协程**\n- 特点\n  - 只要是可以定义函数的地方，就可以定义生成器\n  - 箭头函数不能用来定义生成器函数。\n- 定义方式\n  - // 生成器函数声明\n    - function\\* generatorFn() {}\n  - // 生成器函数表达式\n    - let generatorFn = function\\* () {}\n  - // 作为对象字面量方法的生成器函数\n    - let foo = { \\* generatorFn() {} }\n  - // 作为类实例方法的生成器函数\n    - class Foo { \\* generatorFn() {} }\n  - // 作为类静态方法的生成器函数\n    - class Bar { static \\* generatorFn() {} }\n- 生成器对象\n  - 一开始处于暂停执行（suspended）的 状 态\n  - 生成器对象也实现了 Iterator 接口，因此具有 next()方法\n    - 调用这个方法会让生成器 开始或恢复执行。\n    - 生成器函数只会在初次调用 **`next()`方法**后开始执行\n    - next()方法的返回值\n      - done 属性\n        - 函数体为空的生成器 函数中间不会停留，调用一次 next()就会让生成器到达 done: true 状态\n      - value 属性\n        - value 属性是生成器函数的返回值，默认值为 undefined，可以通过生成器函数的返回值指定\n  - 生成器对象实现了 Iterable 接口，它们默认的迭代器是自引用的\n- 通过 yield 中断执行-Interrupting Execution\n  - 特点\n    - yield 关键字可以让生成器停止和开始执行，也是生成器最有用的地方\n    - yield 关键字只能在生成器函数内部使用，用在其他地方会抛出错误\n    - 出现在嵌套的非生成器函数中会抛出语法错误\n  - 生成器对象作为可迭代对象 (Iterable)\n    - 在生成器对象上显式调用 next()方法的用处并不大\n    - 如果把生成器对象当成可迭代对象， 那么使用起来会更方便\n  - 使用 yield 实现输入和输出\n  - 产生可迭代对象-Yielding an Iterable\n  - 使用 `yield*`实现递归算法\n- 生成器作为默认迭代器-Using a Generator as the Default Iterator\n- 提前终止生成器-Early Termination of Generators - The return() Method - The throw() Method\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"generator-生成器",text:"Generator-生成器#"}]}const Content=createComponent(((n,e,t)=>{const{layout:l,...r}=frontmatter;return r.file=file,r.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),generator____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,generator____,id,slug};