import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/class/inheritance.md",collection="posts",slug="js/class/inheritance",body="\n# Inheritance-继承\n\n### OOP 语言支持的继承\n\n- 接口继承\n  - 继承方法签名（不支持）\n- 实现继承\n  - 继承实际的方法\n  - 实现继承是 ECMAScript 唯一支持的继承方式\n  - 通过原型链实现\n\n### 原型链继承\n\n> [prototype-chain-inheritance-原型链继承](../object/prototype-chain-inheritance-原型链继承)\n\n### 盗用构造函数继承\n\n> [constructor-function-构造函数模式](../object/constructor-function-构造函数模式)\n\n### 组合继承 (常用)\n\n- 也叫伪经典继承\n- ![image|375](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png)\n  - `SuperType.call(this, name);`\n    - 通过盗用构造函数继承实例属性\n  - `SubType.prototype = new SuperType();`\n    - 使用原型链继承原型上的属性和方法，\n\n#### 优点\n\n- 综合了原型链和盗用构造函数，结合了二者优点，传参和复用\n- 每个新实例引入的构造函数属性是私有的。\n- 保留了`instanceof`操作符和`isPrototypeOf()`方法识别合成对象的能力\n\n#### 效率问题\n\n- 父类构造函数始终会被调用两次（耗内存）\n  - 一次在是创建子类原型时调用\n  - 另一次是在子类构造函数中调用\n- 子类的构造函数会代替原型上的那个父类构造函数。\n- 解决方案：\n  - 🏷️ 寄生式组合继承\n\n### ❓ 寄生式组合继承\n\n- 使用寄生式继承来继承父类原型，但使用混合式原型链继承方法\n- ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png)\n\n#### 优点\n\n- 寄生式组合继承可以算是引用类型继承的最佳模式\n- 避免了`SubType.prototype`上不必要也用不到的属性\n\n### 原型式继承\n\n> [prototype-pattern-原型模式](../object/prototype-pattern-原型模式)\n\n### ❓ 寄生式继承\n\n重点： 就是给原型式继承外面套了个壳子。  \n优点： 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。  \n缺点： 没用到原型，无法复用。\n\n- 寄生构造函数和工厂模式\n  - 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象\n\n#### 缺点\n\n- 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似\n\n### Class 类实现继承\n\n> [Class-ES6-类](class-es6-类)\n\n通过 extends 和 super 实现继承\n\n### Reference\n\n- [Object-oriented programming - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)\n- [Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube](https://www.youtube.com/watch?v=PFmuCDHHpwk)\n\n### ❓Use Case\n",data={title:"Inheritance-继承",DateStarted:new Date(16701984e5),draft:!1,tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/class/inheritance.md",rawData:void 0},html='<h1 id="inheritance-继承">Inheritance-继承<a class="anchor" href="#inheritance-继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="oop-语言支持的继承">OOP 语言支持的继承<a class="anchor" href="#oop-语言支持的继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>接口继承\n<ul>\n<li>继承方法签名（不支持）</li>\n</ul>\n</li>\n<li>实现继承\n<ul>\n<li>继承实际的方法</li>\n<li>实现继承是 ECMAScript 唯一支持的继承方式</li>\n<li>通过原型链实现</li>\n</ul>\n</li>\n</ul>\n<h3 id="原型链继承">原型链继承<a class="anchor" href="#原型链继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p><a href="../object/prototype-chain-inheritance-%E5%8E%9F%E5%9E%8B%E9%93%BE%E7%BB%A7%E6%89%BF">prototype-chain-inheritance-原型链继承</a></p>\n</blockquote>\n<h3 id="盗用构造函数继承">盗用构造函数继承<a class="anchor" href="#盗用构造函数继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p><a href="../object/constructor-function-%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%A8%A1%E5%BC%8F">constructor-function-构造函数模式</a></p>\n</blockquote>\n<h3 id="组合继承-常用">组合继承 (常用)<a class="anchor" href="#组合继承-常用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>也叫伪经典继承</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png" alt="image|375">\n<ul>\n<li><code>SuperType.call(this, name);</code>\n<ul>\n<li>通过盗用构造函数继承实例属性</li>\n</ul>\n</li>\n<li><code>SubType.prototype = new SuperType();</code>\n<ul>\n<li>使用原型链继承原型上的属性和方法，</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h4 id="优点">优点<a class="anchor" href="#优点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>综合了原型链和盗用构造函数，结合了二者优点，传参和复用</li>\n<li>每个新实例引入的构造函数属性是私有的。</li>\n<li>保留了<code>instanceof</code>操作符和<code>isPrototypeOf()</code>方法识别合成对象的能力</li>\n</ul>\n<h4 id="效率问题">效率问题<a class="anchor" href="#效率问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>父类构造函数始终会被调用两次（耗内存）\n<ul>\n<li>一次在是创建子类原型时调用</li>\n<li>另一次是在子类构造函数中调用</li>\n</ul>\n</li>\n<li>子类的构造函数会代替原型上的那个父类构造函数。</li>\n<li>解决方案：\n<ul>\n<li>🏷️ 寄生式组合继承</li>\n</ul>\n</li>\n</ul>\n<h3 id="-寄生式组合继承">❓ 寄生式组合继承<a class="anchor" href="#-寄生式组合继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>使用寄生式继承来继承父类原型，但使用混合式原型链继承方法</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png" alt="image"></li>\n</ul>\n<h4 id="优点-1">优点<a class="anchor" href="#优点-1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>寄生式组合继承可以算是引用类型继承的最佳模式</li>\n<li>避免了<code>SubType.prototype</code>上不必要也用不到的属性</li>\n</ul>\n<h3 id="原型式继承">原型式继承<a class="anchor" href="#原型式继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p><a href="../object/prototype-pattern-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">prototype-pattern-原型模式</a></p>\n</blockquote>\n<h3 id="-寄生式继承">❓ 寄生式继承<a class="anchor" href="#-寄生式继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>重点： 就是给原型式继承外面套了个壳子。<br>\n优点： 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。<br>\n缺点： 没用到原型，无法复用。</p>\n<ul>\n<li>寄生构造函数和工厂模式\n<ul>\n<li>创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象</li>\n</ul>\n</li>\n</ul>\n<h4 id="缺点">缺点<a class="anchor" href="#缺点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似</li>\n</ul>\n<h3 id="class-类实现继承">Class 类实现继承<a class="anchor" href="#class-类实现继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p><a href="class-es6-%E7%B1%BB">Class-ES6-类</a></p>\n</blockquote>\n<p>通过 extends 和 super 实现继承</p>\n<h3 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming">Object-oriented programming - Learn web development | MDN</a></li>\n<li><a href="https://www.youtube.com/watch?v=PFmuCDHHpwk">Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube</a></li>\n</ul>\n<h3 id="use-case">❓Use Case<a class="anchor" href="#use-case"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>',frontmatter={draft:!1,title:"Inheritance-继承",topic:["Classes","OOP"],type:"D",tags:["JavaScript"],DateStarted:"2022-12-05T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",Datereviewed:"2024-02-03T00:00:00.000Z",reviewed:0,difficulty:"Hard",status:["ToUse"],comment:null,"linter-yaml-title-alias":"Inheritance-继承",aliases:["Inheritance-继承"],category:"Programming",minutes:3,words:550},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/class/inheritance.md",url=void 0;function rawContent(){return"\n# Inheritance-继承\n\n### OOP 语言支持的继承\n\n- 接口继承\n  - 继承方法签名（不支持）\n- 实现继承\n  - 继承实际的方法\n  - 实现继承是 ECMAScript 唯一支持的继承方式\n  - 通过原型链实现\n\n### 原型链继承\n\n> [prototype-chain-inheritance-原型链继承](../object/prototype-chain-inheritance-原型链继承)\n\n### 盗用构造函数继承\n\n> [constructor-function-构造函数模式](../object/constructor-function-构造函数模式)\n\n### 组合继承 (常用)\n\n- 也叫伪经典继承\n- ![image|375](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/c785cd107320990eed55400fb1ff58cf.png)\n  - `SuperType.call(this, name);`\n    - 通过盗用构造函数继承实例属性\n  - `SubType.prototype = new SuperType();`\n    - 使用原型链继承原型上的属性和方法，\n\n#### 优点\n\n- 综合了原型链和盗用构造函数，结合了二者优点，传参和复用\n- 每个新实例引入的构造函数属性是私有的。\n- 保留了`instanceof`操作符和`isPrototypeOf()`方法识别合成对象的能力\n\n#### 效率问题\n\n- 父类构造函数始终会被调用两次（耗内存）\n  - 一次在是创建子类原型时调用\n  - 另一次是在子类构造函数中调用\n- 子类的构造函数会代替原型上的那个父类构造函数。\n- 解决方案：\n  - 🏷️ 寄生式组合继承\n\n### ❓ 寄生式组合继承\n\n- 使用寄生式继承来继承父类原型，但使用混合式原型链继承方法\n- ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/4d3ce511f14579e6cbdb3a723b1bcfb9.png)\n\n#### 优点\n\n- 寄生式组合继承可以算是引用类型继承的最佳模式\n- 避免了`SubType.prototype`上不必要也用不到的属性\n\n### 原型式继承\n\n> [prototype-pattern-原型模式](../object/prototype-pattern-原型模式)\n\n### ❓ 寄生式继承\n\n重点： 就是给原型式继承外面套了个壳子。  \n优点： 没有创建自定义类型，因为只是套了个壳子返回对象（这个），这个函数顺理成章就成了创建的新对象。  \n缺点： 没用到原型，无法复用。\n\n- 寄生构造函数和工厂模式\n  - 创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象\n\n#### 缺点\n\n- 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似\n\n### Class 类实现继承\n\n> [Class-ES6-类](class-es6-类)\n\n通过 extends 和 super 实现继承\n\n### Reference\n\n- [Object-oriented programming - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_programming)\n- [Object-oriented Programming in JavaScript: Made Super Simple | Mosh - YouTube](https://www.youtube.com/watch?v=PFmuCDHHpwk)\n\n### ❓Use Case\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"inheritance-继承",text:"Inheritance-继承#"},{depth:3,slug:"oop-语言支持的继承",text:"OOP 语言支持的继承#"},{depth:3,slug:"原型链继承",text:"原型链继承#"},{depth:3,slug:"盗用构造函数继承",text:"盗用构造函数继承#"},{depth:3,slug:"组合继承-常用",text:"组合继承 (常用)#"},{depth:4,slug:"优点",text:"优点#"},{depth:4,slug:"效率问题",text:"效率问题#"},{depth:3,slug:"-寄生式组合继承",text:"❓ 寄生式组合继承#"},{depth:4,slug:"优点-1",text:"优点#"},{depth:3,slug:"原型式继承",text:"原型式继承#"},{depth:3,slug:"-寄生式继承",text:"❓ 寄生式继承#"},{depth:4,slug:"缺点",text:"缺点#"},{depth:3,slug:"class-类实现继承",text:"Class 类实现继承#"},{depth:3,slug:"reference",text:"Reference#"},{depth:3,slug:"use-case",text:"❓Use Case#"}]}const Content=createComponent(((n,e,t)=>{const{layout:a,...r}=frontmatter;return r.file=file,r.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),inheritance=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,id,inheritance,slug};