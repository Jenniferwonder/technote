import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../chunks/1726300354279/astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const id="js/function/function-creation-创建函数.md",collection="posts",slug="js/function/function-creation-创建函数",body='\n---\n\nBasic\n\n### 创建函数的方法\n\nBack:\n\n#### 函数声明\n\n- `function sum (num1, num2) {`\n\n#### 函数表达式\n\n- `let sum = function (num1, num2) {`\n- 这样创建的函数叫作匿名函数（anonymous funtion）\n  - 兰姆达函数\n  - 未赋值给其他变量的匿名函数的 name 属性是空字符串\n\n#### 箭头函数（arrow function）\n\n- `let sum = (num1, num2) => {`\n- 没有参数，或者多个参数的情况下，才需要使用括号\n- 不使用大括号\n  - 箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式\n  - 会隐式返回这行代码的值\n- 使用大括号\n  - 包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样\n\n#### 构造函数\n\n- `let sum = new Function(num1, num2, return num1 + num2);  // 不推荐`\n- 最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数  \n📌: JS::JS-Function  \n🏷️: JS-Function\n\x3c!--ID: 1708054155507--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数声明与函数表达式区别\n\nBack:\n\n- 函数声明提升（function declaration hoisting）\n\t- 即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部\n- 函数表达式要先赋值再使用 \n\t- 函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义\n\x3c!--ID: 1708054155517--\x3e\n\n---\n\n\n### 箭头函数与普通函数区别？\n\n箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、`this` 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：\n1. `this` 关键字绑定：\n   - 箭头函数没有自己的 `this`，它从包围它的普通函数或全局作用域继承 `this`。这使得 **在事件处理器或回调函数中使用箭头函数** 非常方便，因为它们自动捕获外部的 `this`。\n   - 普通函数有自己的 `this`，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），`this` 的值可能会有所不同。\n2. `arguments` 对象：\n   - 箭头函数没有自己的 `arguments` 对象。它们可以访问包围它们的普通函数的 `arguments` 对象。\n   - 普通函数有自己的 `arguments` 对象，这是一个类数组对象，包含了传递给函数的参数。\n3. 构造函数行为：\n   - 箭头函数不能作为构造函数使用，因此不能使用 `new` 关键字调用。它们也没有 `prototype` 属性。\n   - 普通函数可以作为构造函数使用，通过 `new` 关键字创建新的对象实例。\n4. 原型链：\n   - 由于箭头函数没有 `prototype` 属性，它们不能作为其他对象的原型。\n   - 普通函数有 `prototype` 属性，可以作为其他对象的原型。\n5. 生成器：\n   - 箭头函数不能使用`yield`关键字。\n   - 普通函数可以使用`yield`关键字变成生成器函数。\n\n### 箭头函数的 this 是声明时确定还是调用时确定？\n箭头函数的 `this` 是根据其被声明的位置来确定的，而不是它被调用的位置。这个特性称为"词法作用域"或者"静态作用域"。箭头函数不会创建自己的 `this`，它会从自己的作用域链上一层继承 `this`。\n\n\n\n\n',data={title:"function-creation-创建函数",DateStarted:new Date(17071776e5),draft:!1,tags:["JavaScript"],category:"Programming"},_internal={type:"content",filePath:"E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/function/function-creation-创建函数.md",rawData:void 0},html='<hr>\n<p>Basic</p>\n<h3 id="创建函数的方法">创建函数的方法<a class="anchor" href="#创建函数的方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<h4 id="函数声明">函数声明<a class="anchor" href="#函数声明"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>function sum (num1, num2) {</code></li>\n</ul>\n<h4 id="函数表达式">函数表达式<a class="anchor" href="#函数表达式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = function (num1, num2) {</code></li>\n<li>这样创建的函数叫作匿名函数（anonymous funtion）\n<ul>\n<li>兰姆达函数</li>\n<li>未赋值给其他变量的匿名函数的 name 属性是空字符串</li>\n</ul>\n</li>\n</ul>\n<h4 id="箭头函数arrow-function">箭头函数（arrow function）<a class="anchor" href="#箭头函数arrow-function"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = (num1, num2) => {</code></li>\n<li>没有参数，或者多个参数的情况下，才需要使用括号</li>\n<li>不使用大括号\n<ul>\n<li>箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式</li>\n<li>会隐式返回这行代码的值</li>\n</ul>\n</li>\n<li>使用大括号\n<ul>\n<li>包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样</li>\n</ul>\n</li>\n</ul>\n<h4 id="构造函数">构造函数<a class="anchor" href="#构造函数"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><code>let sum = new Function(num1, num2, return num1 + num2);  // 不推荐</code></li>\n<li>最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数<br>\n📌: JS::JS-Function<br>\n🏷️: JS-Function</li>\n</ul>\n\x3c!--ID: 1708054155507--\x3e\n<hr>\n<hr>\n<p>Basic</p>\n<h3 id="函数声明与函数表达式区别">函数声明与函数表达式区别<a class="anchor" href="#函数声明与函数表达式区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<ul>\n<li>函数声明提升（function declaration hoisting）\n<ul>\n<li>即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部</li>\n</ul>\n</li>\n<li>函数表达式要先赋值再使用\n<ul>\n<li>函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义</li>\n</ul>\n</li>\n</ul>\n\x3c!--ID: 1708054155517--\x3e\n<hr>\n<h3 id="箭头函数与普通函数区别">箭头函数与普通函数区别？<a class="anchor" href="#箭头函数与普通函数区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、<code>this</code> 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：</p>\n<ol>\n<li><code>this</code> 关键字绑定：\n<ul>\n<li>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得 <strong>在事件处理器或回调函数中使用箭头函数</strong> 非常方便，因为它们自动捕获外部的 <code>this</code>。</li>\n<li>普通函数有自己的 <code>this</code>，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），<code>this</code> 的值可能会有所不同。</li>\n</ul>\n</li>\n<li><code>arguments</code> 对象：\n<ul>\n<li>箭头函数没有自己的 <code>arguments</code> 对象。它们可以访问包围它们的普通函数的 <code>arguments</code> 对象。</li>\n<li>普通函数有自己的 <code>arguments</code> 对象，这是一个类数组对象，包含了传递给函数的参数。</li>\n</ul>\n</li>\n<li>构造函数行为：\n<ul>\n<li>箭头函数不能作为构造函数使用，因此不能使用 <code>new</code> 关键字调用。它们也没有 <code>prototype</code> 属性。</li>\n<li>普通函数可以作为构造函数使用，通过 <code>new</code> 关键字创建新的对象实例。</li>\n</ul>\n</li>\n<li>原型链：\n<ul>\n<li>由于箭头函数没有 <code>prototype</code> 属性，它们不能作为其他对象的原型。</li>\n<li>普通函数有 <code>prototype</code> 属性，可以作为其他对象的原型。</li>\n</ul>\n</li>\n<li>生成器：\n<ul>\n<li>箭头函数不能使用<code>yield</code>关键字。</li>\n<li>普通函数可以使用<code>yield</code>关键字变成生成器函数。</li>\n</ul>\n</li>\n</ol>\n<h3 id="箭头函数的-this-是声明时确定还是调用时确定">箭头函数的 this 是声明时确定还是调用时确定？<a class="anchor" href="#箭头函数的-this-是声明时确定还是调用时确定"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>箭头函数的 <code>this</code> 是根据其被声明的位置来确定的，而不是它被调用的位置。这个特性称为”词法作用域”或者”静态作用域”。箭头函数不会创建自己的 <code>this</code>，它会从自己的作用域链上一层继承 <code>this</code>。</p>',frontmatter={draft:!1,title:"function-creation-创建函数",topic:["Function"],type:"D",tags:["JavaScript"],DateStarted:"2024-02-06T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",Datereviewed:"2024-02-16T00:00:00.000Z",reviewed:3,difficulty:null,status:null,comment:null,category:"Programming",minutes:4,words:886},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/function/function-creation-创建函数.md",url=void 0;function rawContent(){return'\n---\n\nBasic\n\n### 创建函数的方法\n\nBack:\n\n#### 函数声明\n\n- `function sum (num1, num2) {`\n\n#### 函数表达式\n\n- `let sum = function (num1, num2) {`\n- 这样创建的函数叫作匿名函数（anonymous funtion）\n  - 兰姆达函数\n  - 未赋值给其他变量的匿名函数的 name 属性是空字符串\n\n#### 箭头函数（arrow function）\n\n- `let sum = (num1, num2) => {`\n- 没有参数，或者多个参数的情况下，才需要使用括号\n- 不使用大括号\n  - 箭头后面就只能有一行代码，比如一个赋值操作，或者一个表达式\n  - 会隐式返回这行代码的值\n- 使用大括号\n  - 包含“函数体”，可以在一个函数中包含多条语句，跟常规的函数一样\n\n#### 构造函数\n\n- `let sum = new Function(num1, num2, return num1 + num2);  // 不推荐`\n- 最后一个参数始终会被当成函数体，而之前的参数都是新函数的参数  \n📌: JS::JS-Function  \n🏷️: JS-Function\n\x3c!--ID: 1708054155507--\x3e\n\n---\n\n---\n\nBasic\n\n### 函数声明与函数表达式区别\n\nBack:\n\n- 函数声明提升（function declaration hoisting）\n\t- 即使函数定义出现在调用它们的代码之后，引擎也会把函数声明提升到顶部\n- 函数表达式要先赋值再使用 \n\t- 函数表达式跟 JavaScript 中的其他表达式一样，须等到代码执行到它那一行，才会在执行上下文中生成函数定义\n\x3c!--ID: 1708054155517--\x3e\n\n---\n\n\n### 箭头函数与普通函数区别？\n\n箭头函数（Arrow Functions）与普通函数（常被称为函数声明或函数表达式）在 JavaScript 中有一些重要的区别。这些区别包括语法、`this` 关键字的绑定、arguments 对象的使用、构造函数行为以及原型链。以下是箭头函数和普通函数之间的主要区别：\n1. `this` 关键字绑定：\n   - 箭头函数没有自己的 `this`，它从包围它的普通函数或全局作用域继承 `this`。这使得 **在事件处理器或回调函数中使用箭头函数** 非常方便，因为它们自动捕获外部的 `this`。\n   - 普通函数有自己的 `this`，它的值在函数调用时确定。根据函数调用的方式（如通过对象方法调用、直接调用、构造函数调用等），`this` 的值可能会有所不同。\n2. `arguments` 对象：\n   - 箭头函数没有自己的 `arguments` 对象。它们可以访问包围它们的普通函数的 `arguments` 对象。\n   - 普通函数有自己的 `arguments` 对象，这是一个类数组对象，包含了传递给函数的参数。\n3. 构造函数行为：\n   - 箭头函数不能作为构造函数使用，因此不能使用 `new` 关键字调用。它们也没有 `prototype` 属性。\n   - 普通函数可以作为构造函数使用，通过 `new` 关键字创建新的对象实例。\n4. 原型链：\n   - 由于箭头函数没有 `prototype` 属性，它们不能作为其他对象的原型。\n   - 普通函数有 `prototype` 属性，可以作为其他对象的原型。\n5. 生成器：\n   - 箭头函数不能使用`yield`关键字。\n   - 普通函数可以使用`yield`关键字变成生成器函数。\n\n### 箭头函数的 this 是声明时确定还是调用时确定？\n箭头函数的 `this` 是根据其被声明的位置来确定的，而不是它被调用的位置。这个特性称为"词法作用域"或者"静态作用域"。箭头函数不会创建自己的 `this`，它会从自己的作用域链上一层继承 `this`。\n\n\n\n\n'}function compiledContent(){return html}function getHeadings(){return[{depth:3,slug:"创建函数的方法",text:"创建函数的方法#"},{depth:4,slug:"函数声明",text:"函数声明#"},{depth:4,slug:"函数表达式",text:"函数表达式#"},{depth:4,slug:"箭头函数arrow-function",text:"箭头函数（arrow function）#"},{depth:4,slug:"构造函数",text:"构造函数#"},{depth:3,slug:"函数声明与函数表达式区别",text:"函数声明与函数表达式区别#"},{depth:3,slug:"箭头函数与普通函数区别",text:"箭头函数与普通函数区别？#"},{depth:3,slug:"箭头函数的-this-是声明时确定还是调用时确定",text:"箭头函数的 this 是声明时确定还是调用时确定？#"}]}const Content=createComponent(((n,t,e)=>{const{layout:i,...o}=frontmatter;return o.file=file,o.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`})),functionCreation_____=Object.freeze(Object.defineProperty({__proto__:null,Content:Content,compiledContent:compiledContent,default:Content,file:file,frontmatter:frontmatter,getHeadings:getHeadings,rawContent:rawContent,url:url},Symbol.toStringTag,{value:"Module"}));export{_internal,body,collection,data,functionCreation_____,id,slug};