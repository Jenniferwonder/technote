import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h3 id="domcontentloaded-与-load-的区别-">DOMContentLoaded 与 load 的区别 ?<a class="anchor" href="#domcontentloaded-与-load-的区别-"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p><code>DOMContentLoaded</code> 和 <code>load</code> 都是浏览器中的事件，它们表示页面加载过程中的不同阶段。这两个事件的主要区别在于它们触发的时间和关注的内容。</p>\n<ol>\n<li><strong>DOMContentLoaded</strong>：当 HTML 文档被完全加载和解析完成后，<code>DOMContentLoaded</code> 事件就会触发，而此时无需等待样式表、图像和子框架的完成加载。换句话说，<code>DOMContentLoaded</code> 主要关注 HTML 文档结构的加载，以便 JavaScript 代码可以在 DOM 树准备就绪后立即运行。这使得你可以尽早地开始操作 DOM，而无需等待其他资源加载完成。</li>\n<li><strong>load</strong>：当页面上的所有资源（包括样式表、图像、子框架等）都完成加载后，<code>load</code> 事件会触发。这意味着在 <code>load</code> 事件触发时，你可以确保页面上的所有资源都可用，这对于需要操作图像尺寸或其他依赖外部资源的功能来说非常有用。<br>\n总之，<code>DOMContentLoaded</code> 和 <code>load</code> 事件的区别在于它们关注的内容和触发时间：</li>\n</ol>\n<ul>\n<li><code>DOMContentLoaded</code>：在 HTML 文档结构加载和解析完成后触发，不等待外部资源（如样式表和图像）加载完成。</li>\n<li><code>load</code>：在页面上的所有资源（包括样式表、图像等）加载完成后触发。<br>\n通常，如果你的 JavaScript 代码仅依赖于 DOM 结构，那么使用 <code>DOMContentLoaded</code> 事件会更快、更有效。如果你的代码依赖于外部资源，那么使用 <code>load</code> 事件可能更合适。</li>\n</ul>\n<h3 id="谈谈你对-dom-事件机制的理解">谈谈你对 dom 事件机制的理解<a class="anchor" href="#谈谈你对-dom-事件机制的理解"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>DOM（文档对象模型，Document Object Model）事件机制是 Web 浏览器中实现交互的重要组成部分。在 JavaScript 中，DOM 事件机制使得开发者可以在特定情况下响应用户的操作，如点击、滚动、键盘输入等。以下是对 DOM 事件机制的一些理解：</p>\n<ol>\n<li>事件流：DOM 事件机制分为三个阶段，分别是捕获阶段（capturing phase）、目标阶段（target phase）和冒泡阶段（bubbling phase）。事件首先会经过捕获阶段，沿着 DOM 树从上至下传递，直到到达事件的目标元素。然后进入目标阶段，触发目标元素上的事件处理程序。最后是冒泡阶段，事件沿着 DOM 树从下往上回传。</li>\n<li>事件处理程序：开发者可以为 DOM 元素添加事件处理程序，用以响应特定的事件。事件处理程序可以使用两种方式进行绑定：一种是通过 HTML 属性直接在元素上绑定，如<code>onclick</code>；另一种是通过 JavaScript 为元素添加事件处理程序，如<code>addEventListener()</code>方法。</li>\n<li>事件对象：当事件触发时，浏览器会自动创建一个事件对象，该对象包含了有关事件的详细信息，例如事件类型、目标元素、触发时间等。事件对象通常作为事件处理程序的第一个参数传递。</li>\n<li>事件委托：事件委托是一种事件处理机制，通过将事件处理程序绑定到父元素，可以实现对子元素的事件监听。这样可以减少事件处理程序的数量，提高性能。事件委托利用了事件冒泡机制，使得在父元素上可以捕捉到子元素触发的事件。</li>\n<li>阻止默认行为和阻止事件传播：在某些情况下，我们希望阻止事件的默认行为或阻止事件的传播。可以通过调用事件对象的<code>preventDefault()</code>方法来阻止默认行为，调用<code>stopPropagation()</code>方法来阻止事件的传播。<br>\n了解 DOM 事件机制对于前端开发者非常重要，因为它涉及到网页交互、用户体验等关键方面。掌握 DOM 事件机制有助于编写更高效、可维护的代码。</li>\n</ol>\n<h3 id="什么是默认行为哪些事件有默认行为">什么是默认行为，哪些事件有默认行为<a class="anchor" href="#什么是默认行为哪些事件有默认行为"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>默认行为是指浏览器在某些事件触发时自动执行的内置行为。在处理这些事件时，如果不希望触发默认行为，可以使用<code>preventDefault()</code>方法来阻止它。以下是一些具有默认行为的常见事件：</p>\n<ol>\n<li><code>click</code>：当点击某些元素（如链接）时，浏览器会执行默认行为，如导航到指定的 URL。</li>\n<li><code>submit</code>：当表单元素触发提交事件时，浏览器的默认行为是向服务器发送表单数据。</li>\n<li><code>keydown</code>：在输入框内按下某些特定键（如 Enter 键）时，可能会触发浏览器的默认行为，如提交表单。</li>\n<li><code>contextmenu</code>：当用户右击网页时，浏览器会显示上下文菜单。这是<code>contextmenu</code>事件的默认行为。</li>\n<li><code>dragstart</code>和<code>drop</code>：当对某些元素进行拖放操作时，浏览器会执行默认的拖放行为。</li>\n<li><code>mousedown</code>：在文本区域内按下鼠标，浏览器默认会选中文本。</li>\n<li><code>wheel</code>：当用户滚动鼠标滚轮时，浏览器的默认行为是滚动页面。</li>\n<li><code>touchstart</code>、<code>touchmove</code>、<code>touchend</code>：在触摸设备上，这些触摸事件的默认行为可能包括滚动、缩放等。<br>\n这些事件的默认行为取决于浏览器及其版本。在某些情况下，为了实现自定义行为或提高用户体验，开发者可能需要阻止这些默认行为。在事件处理程序中调用<code>event.preventDefault()</code>方法可以实现这一目的。但请注意，不是所有事件的默认行为都可以被阻止，部分事件可能由于浏览器安全策略等原因无法阻止默认行为。</li>\n</ol>\n<h3 id="谈谈你对-shadow-dom-的理解">谈谈你对 Shadow DOM 的理解<a class="anchor" href="#谈谈你对-shadow-dom-的理解"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Shadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。<br>\nShadow DOM 的关键特点如下：</p>\n<ol>\n<li><strong>封装</strong>：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。</li>\n<li><strong>隔离</strong>：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。</li>\n<li><strong>附件阴影树</strong>：通过 <code>attachShadow</code> 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 “Shadow Host”，而创建的 Shadow DOM 被称为 “Shadow Tree”。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。</li>\n<li><strong>插槽（Slot）</strong>：Shadow DOM 支持使用 <code>&#x3C;slot></code> 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。</li>\n<li><strong>样式隔离</strong>：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。<br>\n总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。</li>\n</ol>',frontmatter={title:"dom-interview",topic:null,type:null,tags:["JavaScript"],category:"Programming",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,draft:!0,DateStarted:"2024-04-25T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",minutes:10,words:1964},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/dom/dom-interview.md",url=void 0;function rawContent(){return'### DOMContentLoaded 与 load 的区别 ?\n`DOMContentLoaded` 和 `load` 都是浏览器中的事件，它们表示页面加载过程中的不同阶段。这两个事件的主要区别在于它们触发的时间和关注的内容。\n1. **DOMContentLoaded**：当 HTML 文档被完全加载和解析完成后，`DOMContentLoaded` 事件就会触发，而此时无需等待样式表、图像和子框架的完成加载。换句话说，`DOMContentLoaded` 主要关注 HTML 文档结构的加载，以便 JavaScript 代码可以在 DOM 树准备就绪后立即运行。这使得你可以尽早地开始操作 DOM，而无需等待其他资源加载完成。\n2. **load**：当页面上的所有资源（包括样式表、图像、子框架等）都完成加载后，`load` 事件会触发。这意味着在 `load` 事件触发时，你可以确保页面上的所有资源都可用，这对于需要操作图像尺寸或其他依赖外部资源的功能来说非常有用。  \n总之，`DOMContentLoaded` 和 `load` 事件的区别在于它们关注的内容和触发时间：\n- `DOMContentLoaded`：在 HTML 文档结构加载和解析完成后触发，不等待外部资源（如样式表和图像）加载完成。\n- `load`：在页面上的所有资源（包括样式表、图像等）加载完成后触发。  \n通常，如果你的 JavaScript 代码仅依赖于 DOM 结构，那么使用 `DOMContentLoaded` 事件会更快、更有效。如果你的代码依赖于外部资源，那么使用 `load` 事件可能更合适。\n### 谈谈你对 dom 事件机制的理解\nDOM（文档对象模型，Document Object Model）事件机制是 Web 浏览器中实现交互的重要组成部分。在 JavaScript 中，DOM 事件机制使得开发者可以在特定情况下响应用户的操作，如点击、滚动、键盘输入等。以下是对 DOM 事件机制的一些理解：\n1. 事件流：DOM 事件机制分为三个阶段，分别是捕获阶段（capturing phase）、目标阶段（target phase）和冒泡阶段（bubbling phase）。事件首先会经过捕获阶段，沿着 DOM 树从上至下传递，直到到达事件的目标元素。然后进入目标阶段，触发目标元素上的事件处理程序。最后是冒泡阶段，事件沿着 DOM 树从下往上回传。\n2. 事件处理程序：开发者可以为 DOM 元素添加事件处理程序，用以响应特定的事件。事件处理程序可以使用两种方式进行绑定：一种是通过 HTML 属性直接在元素上绑定，如`onclick`；另一种是通过 JavaScript 为元素添加事件处理程序，如`addEventListener()`方法。\n3. 事件对象：当事件触发时，浏览器会自动创建一个事件对象，该对象包含了有关事件的详细信息，例如事件类型、目标元素、触发时间等。事件对象通常作为事件处理程序的第一个参数传递。\n4. 事件委托：事件委托是一种事件处理机制，通过将事件处理程序绑定到父元素，可以实现对子元素的事件监听。这样可以减少事件处理程序的数量，提高性能。事件委托利用了事件冒泡机制，使得在父元素上可以捕捉到子元素触发的事件。\n5. 阻止默认行为和阻止事件传播：在某些情况下，我们希望阻止事件的默认行为或阻止事件的传播。可以通过调用事件对象的`preventDefault()`方法来阻止默认行为，调用`stopPropagation()`方法来阻止事件的传播。  \n了解 DOM 事件机制对于前端开发者非常重要，因为它涉及到网页交互、用户体验等关键方面。掌握 DOM 事件机制有助于编写更高效、可维护的代码。\n### 什么是默认行为，哪些事件有默认行为\n默认行为是指浏览器在某些事件触发时自动执行的内置行为。在处理这些事件时，如果不希望触发默认行为，可以使用`preventDefault()`方法来阻止它。以下是一些具有默认行为的常见事件：\n1. `click`：当点击某些元素（如链接）时，浏览器会执行默认行为，如导航到指定的 URL。\n2. `submit`：当表单元素触发提交事件时，浏览器的默认行为是向服务器发送表单数据。\n3. `keydown`：在输入框内按下某些特定键（如 Enter 键）时，可能会触发浏览器的默认行为，如提交表单。\n4. `contextmenu`：当用户右击网页时，浏览器会显示上下文菜单。这是`contextmenu`事件的默认行为。\n5. `dragstart`和`drop`：当对某些元素进行拖放操作时，浏览器会执行默认的拖放行为。\n6. `mousedown`：在文本区域内按下鼠标，浏览器默认会选中文本。\n7. `wheel`：当用户滚动鼠标滚轮时，浏览器的默认行为是滚动页面。\n8. `touchstart`、`touchmove`、`touchend`：在触摸设备上，这些触摸事件的默认行为可能包括滚动、缩放等。  \n这些事件的默认行为取决于浏览器及其版本。在某些情况下，为了实现自定义行为或提高用户体验，开发者可能需要阻止这些默认行为。在事件处理程序中调用`event.preventDefault()`方法可以实现这一目的。但请注意，不是所有事件的默认行为都可以被阻止，部分事件可能由于浏览器安全策略等原因无法阻止默认行为。\n### 谈谈你对 Shadow DOM 的理解\nShadow DOM 是 Web Components 规范的一个重要组成部分，它提供了一种将 HTML、CSS 和 JavaScript 封装在独立、隔离的 DOM 结构中的方法，从而实现组件的样式和行为的封装。Shadow DOM 解决了全局样式污染的问题，使得开发者可以创建具有独立样式和逻辑的可重用组件。  \nShadow DOM 的关键特点如下：\n1. **封装**：Shadow DOM 允许将一组 DOM 元素和相关样式封装在一个独立的、隔离的 DOM 树中。这样，组件的样式不会影响到主文档，同样主文档的样式也不会影响到组件。通过这种封装，组件可以在不同的应用中重用，而无需担心样式污染和冲突。\n2. **隔离**：Shadow DOM 的树结构是隔离的，意味着组件内的 DOM 元素和 JavaScript 逻辑与主文档是分开的。这有助于保护组件内的数据和方法，避免被外部访问和修改。\n3. **附件阴影树**：通过 `attachShadow` 方法，可以在一个普通的 DOM 元素上创建一个 Shadow DOM。这个普通元素被称为 "Shadow Host"，而创建的 Shadow DOM 被称为 "Shadow Tree"。Shadow Tree 与主文档的 DOM 树是并列的，互不干扰。\n4. **插槽（Slot）**：Shadow DOM 支持使用 `<slot>` 元素来分发（或投影）主文档中的内容。这使得组件可以定义可自定义的内容区域，让使用者在引入组件时提供所需的内容。\n5. **样式隔离**：组件内的 CSS 样式只对 Shadow Tree 中的元素生效，不会影响到主文档。同时，主文档的 CSS 样式（除了 CSS 变量）也不会影响到组件。这样，组件的样式能够完全独立，避免了全局样式污染。  \n总之，Shadow DOM 提供了一种在 Web 开发中实现组件封装和样式隔离的机制。通过使用 Shadow DOM，开发者可以创建具有独立样式和行为的可重用组件，简化开发过程，提高组件的可维护性。'}function compiledContent(){return html}function getHeadings(){return[{depth:3,slug:"domcontentloaded-与-load-的区别-",text:"DOMContentLoaded 与 load 的区别 ?#"},{depth:3,slug:"谈谈你对-dom-事件机制的理解",text:"谈谈你对 dom 事件机制的理解#"},{depth:3,slug:"什么是默认行为哪些事件有默认行为",text:"什么是默认行为，哪些事件有默认行为#"},{depth:3,slug:"谈谈你对-shadow-dom-的理解",text:"谈谈你对 Shadow DOM 的理解#"}]}const Content=createComponent(((o,e,n)=>{const{layout:t,...d}=frontmatter;return d.file=file,d.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};