import"kleur/colors";import{clsx}from"clsx";import{escape}from"html-escaper";import"cssesc";const MissingMediaQueryDirective={name:"MissingMediaQueryDirective",title:"Missing value for `client:media` directive.",message:'Media query not provided for `client:media` directive. A media query similar to `client:media="(max-width: 600px)"` must be provided'},NoMatchingRenderer={name:"NoMatchingRenderer",title:"No matching renderer found.",message:(e,t,r,n)=>`Unable to render \`${e}\`.\n\n${n>0?`There ${r?"are":"is"} ${n} renderer${r?"s":""} configured in your \`astro.config.mjs\` file,\nbut ${r?"none were":"it was not"} able to server-side render \`${e}\`.`:"No valid renderer was found "+(t?`for the \`.${t}\` file extension.`:"for this file extension.")}`,hint:e=>`Did you mean to enable the ${e} integration?\n\nSee https://docs.astro.build/en/guides/framework-components/ for more information on how to install and configure integrations.`},NoClientEntrypoint={name:"NoClientEntrypoint",title:"No client entrypoint specified in renderer.",message:(e,t,r)=>`\`${e}\` component has a \`client:${t}\` directive, but no client entrypoint was provided by \`${r}\`.`,hint:"See https://docs.astro.build/en/reference/integrations-reference/#addrenderer-option for more information on how to configure your renderer."},NoClientOnlyHint={name:"NoClientOnlyHint",title:"Missing hint on client:only directive.",message:e=>`Unable to render \`${e}\`. When using the \`client:only\` hydration strategy, Astro needs a hint to use the correct renderer.`,hint:e=>`Did you mean to pass \`client:only="${e}"\`? See https://docs.astro.build/en/reference/directives-reference/#clientonly for more information on client:only`},NoMatchingImport={name:"NoMatchingImport",title:"No import found for component.",message:e=>`Could not render \`${e}\`. No matching import has been found for \`${e}\`.`,hint:"Please make sure the component is properly imported."},InvalidComponentArgs={name:"InvalidComponentArgs",title:"Invalid component arguments.",message:e=>`Invalid arguments passed to${e?` <${e}>`:""} component.`,hint:"Astro components cannot be rendered directly via function call, such as `Component()` or `{items.map(Component)}`."},ImageMissingAlt={name:"ImageMissingAlt",title:'Image missing required "alt" property.',message:'Image missing "alt" property. "alt" text is required to describe important images on the page.',hint:'Use an empty string ("") for decorative images.'},InvalidImageService={name:"InvalidImageService",title:"Error while loading image service.",message:"There was an error loading the configured image service. Please see the stack trace for more information."},MissingImageDimension={name:"MissingImageDimension",title:"Missing image dimensions",message:(e,t)=>`Missing ${"both"===e?"width and height attributes":`${e} attribute`} for ${t}. When using remote images, both dimensions are required unless in order to avoid CLS.`,hint:"If your image is inside your `src` folder, you probably meant to import it instead. See [the Imports guide for more information](https://docs.astro.build/en/guides/imports/#other-assets). You can also use `inferSize={true}` for remote images to get the original dimensions."},FailedToFetchRemoteImageDimensions={name:"FailedToFetchRemoteImageDimensions",title:"Failed to retrieve remote image dimensions",message:e=>`Failed to get the dimensions for ${e}.`,hint:"Verify your remote image URL is accurate, and that you are not using `inferSize` with a file located in your `public/` folder."},UnsupportedImageFormat={name:"UnsupportedImageFormat",title:"Unsupported image format",message:(e,t,r)=>`Received unsupported format \`${e}\` from \`${t}\`. Currently only ${r.join(", ")} are supported by our image services.`,hint:"Using an `img` tag directly instead of the `Image` component might be what you're looking for."},UnsupportedImageConversion={name:"UnsupportedImageConversion",title:"Unsupported image conversion",message:"Converting between vector (such as SVGs) and raster (such as PNGs and JPEGs) images is not currently supported."},ExpectedImage={name:"ExpectedImage",title:"Expected src to be an image.",message:(e,t,r)=>`Expected \`src\` property for \`getImage\` or \`<Image />\` to be either an ESM imported image or a string with the path of a remote image. Received \`${e}\` (type: \`${t}\`).\n\nFull serialized options received: \`${r}\`.`,hint:"This error can often happen because of a wrong path. Make sure the path to your image is correct. If you're passing an async function, make sure to call and await it."},ExpectedImageOptions={name:"ExpectedImageOptions",title:"Expected image options.",message:e=>`Expected getImage() parameter to be an object. Received \`${e}\`.`},IncompatibleDescriptorOptions={name:"IncompatibleDescriptorOptions",title:"Cannot set both `densities` and `widths`",message:"Only one of `densities` or `widths` can be specified. In most cases, you'll probably want to use only `widths` if you require specific widths.",hint:"Those attributes are used to construct a `srcset` attribute, which cannot have both `x` and `w` descriptors."},LocalImageUsedWrongly={name:"LocalImageUsedWrongly",title:"Local images must be imported.",message:e=>`\`Image\`'s and \`getImage\`'s \`src\` parameter must be an imported image or an URL, it cannot be a string filepath. Received \`${e}\`.`,hint:"If you want to use an image from your `src` folder, you need to either import it or if the image is coming from a content collection, use the [image() schema helper](https://docs.astro.build/en/guides/images/#images-in-content-collections). See https://docs.astro.build/en/guides/images/#src-required for more information on the `src` property."},AstroGlobUsedOutside={name:"AstroGlobUsedOutside",title:"Astro.glob() used outside of an Astro file.",message:e=>`\`Astro.glob(${e})\` can only be used in \`.astro\` files. \`import.meta.glob(${e})\` can be used instead to achieve a similar result.`,hint:"See Vite's documentation on `import.meta.glob` for more information: https://vitejs.dev/guide/features.html#glob-import"},AstroGlobNoMatch={name:"AstroGlobNoMatch",title:"Astro.glob() did not match any files.",message:e=>`\`Astro.glob(${e})\` did not return any matching files.`,hint:"Check the pattern for typos."},MissingSharp={name:"MissingSharp",title:"Could not find Sharp.",message:"Could not find Sharp. Please install Sharp (`sharp`) manually into your project or migrate to another image service.",hint:"See Sharp's installation instructions for more information: https://sharp.pixelplumbing.com/install. If you are not relying on `astro:assets` to optimize, transform, or process any images, you can configure a passthrough image service instead of installing Sharp. See https://docs.astro.build/en/reference/errors/missing-sharp for more information.\n\nSee https://docs.astro.build/en/guides/images/#default-image-service for more information on how to migrate to another image service."};function normalizeLF(e){return e.replace(/\r\n|\r(?!\n)|\n/g,"\n")}function codeFrame(e,t){if(!t||void 0===t.line||void 0===t.column)return"";const r=normalizeLF(e).split("\n").map((e=>e.replace(/\t/g,"  "))),n=[];for(let e=-2;e<=2;e++)r[t.line+e]&&n.push(t.line+e);let o=0;for(const e of n){let t=`> ${e}`;t.length>o&&(o=t.length)}let i="";for(const e of n){const n=e===t.line-1;i+=n?"> ":"  ",i+=`${e+1} | ${r[e]}\n`,n&&(i+=`${Array.from({length:o}).join(" ")}  | ${Array.from({length:t.column}).join(" ")}^\n`)}return i}class AstroError extends Error{loc;title;hint;frame;type="AstroError";constructor(e,t){const{name:r,title:n,message:o,stack:i,location:s,hint:a,frame:c}=e;super(o,t),this.title=n,this.name=r,o&&(this.message=o),this.stack=i||this.stack,this.loc=s,this.hint=a,this.frame=c}setLocation(e){this.loc=e}setName(e){this.name=e}setMessage(e){this.message=e}setHint(e){this.hint=e}setFrame(e,t){this.frame=codeFrame(e,t)}static is(e){return"AstroError"===e.type}}const ASTRO_VERSION="4.5.12";function validateArgs(e){return 3===e.length&&!(!e[0]||"object"!=typeof e[0])}function baseCreateComponent(e,t,r){const n=t?.split("/").pop()?.replace(".astro","")??"",o=(...t)=>{if(!validateArgs(t))throw new AstroError({...InvalidComponentArgs,message:InvalidComponentArgs.message(n)});return e(...t)};return Object.defineProperty(o,"name",{value:n,writable:!1}),o.isAstroComponentFactory=!0,o.moduleId=t,o.propagation=r,o}function createComponentWithOptions(e){return baseCreateComponent(e.factory,e.moduleId,e.propagation)}function createComponent(e,t,r){return"function"==typeof e?baseCreateComponent(e,t,r):createComponentWithOptions(e)}function createAstroGlobFn(){return e=>{if("string"==typeof e)throw new AstroError({...AstroGlobUsedOutside,message:AstroGlobUsedOutside.message(JSON.stringify(e))});let t=[...Object.values(e)];if(0===t.length)throw new AstroError({...AstroGlobNoMatch,message:AstroGlobNoMatch.message(JSON.stringify(e))});return Promise.all(t.map((e=>e())))}}function createAstro(e){return{site:e?new URL(e):void 0,generator:"Astro v4.5.12",glob:createAstroGlobFn()}}function isPromise(e){return!!e&&"object"==typeof e&&"function"==typeof e.then}async function*streamAsyncIterator(e){const t=e.getReader();try{for(;;){const{done:e,value:r}=await t.read();if(e)return;yield r}}finally{t.releaseLock()}}const escapeHTML=escape;class HTMLBytes extends Uint8Array{}Object.defineProperty(HTMLBytes.prototype,Symbol.toStringTag,{get:()=>"HTMLBytes"});class HTMLString extends String{get[Symbol.toStringTag](){return"HTMLString"}}const markHTMLString=e=>e instanceof HTMLString?e:"string"==typeof e?new HTMLString(e):e;function isHTMLString(e){return"[object HTMLString]"===Object.prototype.toString.call(e)}function markHTMLBytes(e){return new HTMLBytes(e)}function hasGetReader(e){return"function"==typeof e.getReader}async function*unescapeChunksAsync(e){if(hasGetReader(e))for await(const t of streamAsyncIterator(e))yield unescapeHTML(t);else for await(const t of e)yield unescapeHTML(t)}function*unescapeChunks(e){for(const t of e)yield unescapeHTML(t)}function unescapeHTML(e){if(e&&"object"==typeof e){if(e instanceof Uint8Array)return markHTMLBytes(e);if(e instanceof Response&&e.body){return unescapeChunksAsync(e.body)}if("function"==typeof e.then)return Promise.resolve(e).then((e=>unescapeHTML(e)));if(e[Symbol.for("astro:slot-string")])return e;if(Symbol.iterator in e)return unescapeChunks(e);if(Symbol.asyncIterator in e||hasGetReader(e))return unescapeChunksAsync(e)}return markHTMLString(e)}const RenderInstructionSymbol=Symbol.for("astro:render");function createRenderInstruction(e){return Object.defineProperty(e,RenderInstructionSymbol,{value:!0})}function isRenderInstruction(e){return e&&"object"==typeof e&&e[RenderInstructionSymbol]}const PROP_TYPE={Value:0,JSON:1,RegExp:2,Date:3,Map:4,Set:5,BigInt:6,URL:7,Uint8Array:8,Uint16Array:9,Uint32Array:10};function serializeArray(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=e.map((e=>convertToSerializedForm(e,t,r)));return r.delete(e),n}function serializeObject(e,t={},r=new WeakSet){if(r.has(e))throw new Error(`Cyclic reference detected while serializing props for <${t.displayName} client:${t.hydrate}>!\n\nCyclic references cannot be safely serialized for client-side usage. Please remove the cyclic reference.`);r.add(e);const n=Object.fromEntries(Object.entries(e).map((([e,n])=>[e,convertToSerializedForm(n,t,r)])));return r.delete(e),n}function convertToSerializedForm(e,t={},r=new WeakSet){switch(Object.prototype.toString.call(e)){case"[object Date]":return[PROP_TYPE.Date,e.toISOString()];case"[object RegExp]":return[PROP_TYPE.RegExp,e.source];case"[object Map]":return[PROP_TYPE.Map,serializeArray(Array.from(e),t,r)];case"[object Set]":return[PROP_TYPE.Set,serializeArray(Array.from(e),t,r)];case"[object BigInt]":return[PROP_TYPE.BigInt,e.toString()];case"[object URL]":return[PROP_TYPE.URL,e.toString()];case"[object Array]":return[PROP_TYPE.JSON,serializeArray(e,t,r)];case"[object Uint8Array]":return[PROP_TYPE.Uint8Array,Array.from(e)];case"[object Uint16Array]":return[PROP_TYPE.Uint16Array,Array.from(e)];case"[object Uint32Array]":return[PROP_TYPE.Uint32Array,Array.from(e)];default:return null!==e&&"object"==typeof e?[PROP_TYPE.Value,serializeObject(e,t,r)]:void 0===e?[PROP_TYPE.Value]:[PROP_TYPE.Value,e]}}function serializeProps(e,t){return JSON.stringify(serializeObject(e,t))}const transitionDirectivesToCopyOnIsland=Object.freeze(["data-astro-transition-scope","data-astro-transition-persist","data-astro-transition-persist-props"]);function extractDirectives(e,t){let r={isPage:!1,hydration:null,props:{},propsWithoutTransitionAttributes:{}};for(const[n,o]of Object.entries(e))if(n.startsWith("server:")&&"server:root"===n&&(r.isPage=!0),n.startsWith("client:"))switch(r.hydration||(r.hydration={directive:"",value:"",componentUrl:"",componentExport:{value:""}}),n){case"client:component-path":r.hydration.componentUrl=o;break;case"client:component-export":r.hydration.componentExport.value=o;break;case"client:component-hydration":case"client:display-name":break;default:if(r.hydration.directive=n.split(":")[1],r.hydration.value=o,!t.has(r.hydration.directive)){const e=Array.from(t.keys()).map((e=>`client:${e}`)).join(", ");throw new Error(`Error: invalid hydration directive "${n}". Supported hydration methods: ${e}`)}if("media"===r.hydration.directive&&"string"!=typeof r.hydration.value)throw new AstroError(MissingMediaQueryDirective)}else r.props[n]=o,transitionDirectivesToCopyOnIsland.includes(n)||(r.propsWithoutTransitionAttributes[n]=o);for(const t of Object.getOwnPropertySymbols(e))r.props[t]=e[t],r.propsWithoutTransitionAttributes[t]=e[t];return r}async function generateHydrateScript(e,t){const{renderer:r,result:n,astroId:o,props:i,attrs:s}=e,{hydrate:a,componentUrl:c,componentExport:l}=t;if(!l.value)throw new AstroError({...NoMatchingImport,message:NoMatchingImport.message(t.displayName)});const d={children:"",props:{uid:o}};if(s)for(const[e,t]of Object.entries(s))d.props[e]=escapeHTML(t);d.props["component-url"]=await n.resolve(decodeURI(c)),r.clientEntrypoint&&(d.props["component-export"]=l.value,d.props["renderer-url"]=await n.resolve(decodeURI(r.clientEntrypoint)),d.props.props=escapeHTML(serializeProps(i,t))),d.props.ssr="",d.props.client=a;let u=await n.resolve("astro:scripts/before-hydration.js");return u.length&&(d.props["before-hydration-url"]=u),d.props.opts=escapeHTML(JSON.stringify({name:t.displayName,value:t.hydrateArgs||""})),transitionDirectivesToCopyOnIsland.forEach((e=>{void 0!==i[e]&&(d.props[e]=i[e])})),d}const dictionary="0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXY",binary=dictionary.length;function bitwise(e){let t=0;if(0===e.length)return t;for(let r=0;r<e.length;r++){t=(t<<5)-t+e.charCodeAt(r),t|=0}return t}function shorthash(e){let t,r="",n=bitwise(e);const o=n<0?"Z":"";for(n=Math.abs(n);n>=binary;)t=n%binary,n=Math.floor(n/binary),r=dictionary[t]+r;return n>0&&(r=dictionary[n]+r),o+r}function isAstroComponentFactory(e){return null!=e&&!0===e.isAstroComponentFactory}function isAPropagatingComponent(e,t){let r=t.propagation||"none";return t.moduleId&&e.componentMetadata.has(t.moduleId)&&"none"===r&&(r=e.componentMetadata.get(t.moduleId).propagation),"in-tree"===r||"self"===r}const headAndContentSym=Symbol.for("astro.headAndContent");function isHeadAndContent(e){return"object"==typeof e&&!!e[headAndContentSym]}var astro_island_prebuilt_dev_default='(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var l=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var m;{let c={0:t=>y(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),y=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(m=class extends HTMLElement{constructor(){super(...arguments);l(this,"Component");l(this,"hydrator");l(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},h=this.querySelectorAll("template[data-astro-template]");for(let o of h){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let p;try{p=this.hasAttribute("props")?y(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let d,u=this.hydrator(this);d=performance.now(),await u(this.Component,p,r,{client:this.getAttribute("client")}),d&&this.setAttribute("client-render-time",(performance.now()-d).toString()),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});l(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[h,{default:p}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),d=this.getAttribute("component-export")||"default";if(!d.includes("."))this.Component=h[d];else{this.Component=h;for(let u of d.split("."))this.Component=this.Component[u]}return this.hydrator=p,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},l(m,"observedAttributes",["props"]),m))}})();',astro_island_prebuilt_default='(()=>{var v=Object.defineProperty;var A=(c,s,a)=>s in c?v(c,s,{enumerable:!0,configurable:!0,writable:!0,value:a}):c[s]=a;var d=(c,s,a)=>(A(c,typeof s!="symbol"?s+"":s,a),a);var u;{let c={0:t=>m(t),1:t=>a(t),2:t=>new RegExp(t),3:t=>new Date(t),4:t=>new Map(a(t)),5:t=>new Set(a(t)),6:t=>BigInt(t),7:t=>new URL(t),8:t=>new Uint8Array(t),9:t=>new Uint16Array(t),10:t=>new Uint32Array(t)},s=t=>{let[e,n]=t;return e in c?c[e](n):void 0},a=t=>t.map(s),m=t=>typeof t!="object"||t===null?t:Object.fromEntries(Object.entries(t).map(([e,n])=>[e,s(n)]));customElements.get("astro-island")||customElements.define("astro-island",(u=class extends HTMLElement{constructor(){super(...arguments);d(this,"Component");d(this,"hydrator");d(this,"hydrate",async()=>{var f;if(!this.hydrator||!this.isConnected)return;let e=(f=this.parentElement)==null?void 0:f.closest("astro-island[ssr]");if(e){e.addEventListener("astro:hydrate",this.hydrate,{once:!0});return}let n=this.querySelectorAll("astro-slot"),r={},l=this.querySelectorAll("template[data-astro-template]");for(let o of l){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("data-astro-template")||"default"]=o.innerHTML,o.remove())}for(let o of n){let i=o.closest(this.tagName);i!=null&&i.isSameNode(this)&&(r[o.getAttribute("name")||"default"]=o.innerHTML)}let h;try{h=this.hasAttribute("props")?m(JSON.parse(this.getAttribute("props"))):{}}catch(o){let i=this.getAttribute("component-url")||"<unknown>",b=this.getAttribute("component-export");throw b&&(i+=` (export ${b})`),console.error(`[hydrate] Error parsing props for component ${i}`,this.getAttribute("props"),o),o}let p;await this.hydrator(this)(this.Component,h,r,{client:this.getAttribute("client")}),this.removeAttribute("ssr"),this.dispatchEvent(new CustomEvent("astro:hydrate"))});d(this,"unmount",()=>{this.isConnected||this.dispatchEvent(new CustomEvent("astro:unmount"))})}disconnectedCallback(){document.removeEventListener("astro:after-swap",this.unmount),document.addEventListener("astro:after-swap",this.unmount,{once:!0})}connectedCallback(){if(!this.hasAttribute("await-children")||document.readyState==="interactive"||document.readyState==="complete")this.childrenConnectedCallback();else{let e=()=>{document.removeEventListener("DOMContentLoaded",e),n.disconnect(),this.childrenConnectedCallback()},n=new MutationObserver(()=>{var r;((r=this.lastChild)==null?void 0:r.nodeType)===Node.COMMENT_NODE&&this.lastChild.nodeValue==="astro:end"&&(this.lastChild.remove(),e())});n.observe(this,{childList:!0}),document.addEventListener("DOMContentLoaded",e)}}async childrenConnectedCallback(){let e=this.getAttribute("before-hydration-url");e&&await import(e),this.start()}async start(){let e=JSON.parse(this.getAttribute("opts")),n=this.getAttribute("client");if(Astro[n]===void 0){window.addEventListener(`astro:${n}`,()=>this.start(),{once:!0});return}try{await Astro[n](async()=>{let r=this.getAttribute("renderer-url"),[l,{default:h}]=await Promise.all([import(this.getAttribute("component-url")),r?import(r):()=>()=>{}]),p=this.getAttribute("component-export")||"default";if(!p.includes("."))this.Component=l[p];else{this.Component=l;for(let y of p.split("."))this.Component=this.Component[y]}return this.hydrator=h,this.hydrate},e,this)}catch(r){console.error(`[astro-island] Error hydrating ${this.getAttribute("component-url")}`,r)}}attributeChangedCallback(){this.hydrate()}},d(u,"observedAttributes",["props"]),u))}})();';const ISLAND_STYLES="<style>astro-island,astro-slot,astro-static-slot{display:contents}</style>";function determineIfNeedsHydrationScript(e){return!e._metadata.hasHydrationScript&&(e._metadata.hasHydrationScript=!0)}function determinesIfNeedsDirectiveScript(e,t){return!e._metadata.hasDirectives.has(t)&&(e._metadata.hasDirectives.add(t),!0)}function getDirectiveScriptText(e,t){const r=e.clientDirectives.get(t);if(!r)throw new Error(`Unknown directive: ${t}`);return r}function getPrescripts(e,t,r){switch(t){case"both":return`${ISLAND_STYLES}<script>${getDirectiveScriptText(e,r)};${"development"===process.env.NODE_ENV?astro_island_prebuilt_dev_default:astro_island_prebuilt_default}<\/script>`;case"directive":return`<script>${getDirectiveScriptText(e,r)}<\/script>`}return""}const voidElementNames=/^(area|base|br|col|command|embed|hr|img|input|keygen|link|meta|param|source|track|wbr)$/i,htmlBooleanAttributes=/^(?:allowfullscreen|async|autofocus|autoplay|controls|default|defer|disabled|disablepictureinpicture|disableremoteplayback|formnovalidate|hidden|loop|nomodule|novalidate|open|playsinline|readonly|required|reversed|scoped|seamless|itemscope)$/i,htmlEnumAttributes=/^(?:contenteditable|draggable|spellcheck|value)$/i,svgEnumAttributes=/^(?:autoReverse|externalResourcesRequired|focusable|preserveAlpha)$/i,STATIC_DIRECTIVES=new Set(["set:html","set:text"]),toIdent=e=>e.trim().replace(/(?!^)\b\w|\s+|\W+/g,((e,t)=>/\W/.test(e)?"":0===t?e:e.toUpperCase())),toAttributeString=(e,t=!0)=>t?String(e).replace(/&/g,"&#38;").replace(/"/g,"&#34;"):e,kebab=e=>e.toLowerCase()===e?e:e.replace(/[A-Z]/g,(e=>`-${e.toLowerCase()}`)),toStyleString=e=>Object.entries(e).filter((([e,t])=>"string"==typeof t&&t.trim()||"number"==typeof t)).map((([e,t])=>"-"!==e[0]&&"-"!==e[1]?`${kebab(e)}:${t}`:`${e}:${t}`)).join(";");function defineScriptVars(e){let t="";for(const[r,n]of Object.entries(e))t+=`const ${toIdent(r)} = ${JSON.stringify(n)?.replace(/<\/script>/g,"\\x3C/script>")};\n`;return markHTMLString(t)}function formatList(e){return 1===e.length?e[0]:`${e.slice(0,-1).join(", ")} or ${e[e.length-1]}`}function addAttribute(e,t,r=!0){if(null==e)return"";if(!1===e)return htmlEnumAttributes.test(t)||svgEnumAttributes.test(t)?markHTMLString(` ${t}="false"`):"";if(STATIC_DIRECTIVES.has(t))return console.warn(`[astro] The "${t}" directive cannot be applied dynamically at runtime. It will not be rendered as an attribute.\n\nMake sure to use the static attribute syntax (\`${t}={value}\`) instead of the dynamic spread syntax (\`{...{ "${t}": value }}\`).`),"";if("class:list"===t){const n=toAttributeString(clsx(e),r);return""===n?"":markHTMLString(` ${t.slice(0,-5)}="${n}"`)}if("style"===t&&!(e instanceof HTMLString)){if(Array.isArray(e)&&2===e.length)return markHTMLString(` ${t}="${toAttributeString(`${toStyleString(e[0])};${e[1]}`,r)}"`);if("object"==typeof e)return markHTMLString(` ${t}="${toAttributeString(toStyleString(e),r)}"`)}return"className"===t?markHTMLString(` class="${toAttributeString(e,r)}"`):"string"==typeof e&&e.includes("&")&&urlCanParse(e)?markHTMLString(` ${t}="${toAttributeString(e,!1)}"`):!0===e&&(t.startsWith("data-")||htmlBooleanAttributes.test(t))?markHTMLString(` ${t}`):markHTMLString(` ${t}="${toAttributeString(e,r)}"`)}function internalSpreadAttributes(e,t=!0){let r="";for(const[n,o]of Object.entries(e))r+=addAttribute(o,n,t);return markHTMLString(r)}function renderElement(e,{props:t,children:r=""},n=!0){const{lang:o,"data-astro-id":i,"define:vars":s,...a}=t;return s&&("style"===e&&(delete a["is:global"],delete a["is:scoped"]),"script"===e&&(delete a.hoist,r=defineScriptVars(s)+"\n"+r)),null!=r&&""!=r||!voidElementNames.test(e)?`<${e}${internalSpreadAttributes(a,n)}>${r}</${e}>`:`<${e}${internalSpreadAttributes(a,n)}>`}function renderToBufferDestination(e){const t=[],r={write:e=>t.push(e)},n=e(r);return Promise.resolve(n).catch((()=>{})),{async renderToFinalDestination(e){for(const r of t)e.write(r);r.write=t=>e.write(t),await n}}}function urlCanParse(e){try{return new URL(e),!0}catch{return!1}}"undefined"!=typeof process&&Object.prototype.toString.call(process);const uniqueElements=(e,t,r)=>{const n=JSON.stringify(e.props),o=e.children;return t===r.findIndex((e=>JSON.stringify(e.props)===n&&e.children==o))};function renderAllHeadContent(e){e._metadata.hasRenderedHead=!0;const t=Array.from(e.styles).filter(uniqueElements).map((e=>"stylesheet"===e.props.rel?renderElement("link",e):renderElement("style",e)));e.styles.clear();const r=Array.from(e.scripts).filter(uniqueElements).map((e=>renderElement("script",e,!1))),n=Array.from(e.links).filter(uniqueElements).map((e=>renderElement("link",e,!1)));let o=t.join("\n")+n.join("\n")+r.join("\n");if(e._metadata.extraHead.length>0)for(const t of e._metadata.extraHead)o+=t;return markHTMLString(o)}function renderHead(){return createRenderInstruction({type:"head"})}function maybeRenderHead(){return createRenderInstruction({type:"maybe-head"})}const slotString=Symbol.for("astro:slot-string");class SlotString extends HTMLString{instructions;[slotString];constructor(e,t){super(e),this.instructions=t,this[slotString]=!0}}function isSlotString(e){return!!e[slotString]}function renderSlot(e,t,r){return!t&&r?renderSlot(e,r):{async render(r){await renderChild(r,"function"==typeof t?t(e):t)}}}async function renderSlotToString(e,t,r){let n="",o=null;const i={write(t){if(t instanceof SlotString)n+=t,t.instructions&&(o??=[],o.push(...t.instructions));else{if(t instanceof Response)return;"object"==typeof t&&"type"in t&&"string"==typeof t.type?(null===o&&(o=[]),o.push(t)):n+=chunkToString(e,t)}}},s=renderSlot(e,t,r);return await s.render(i),markHTMLString(new SlotString(n,o))}async function renderSlots(e,t={}){let r=null,n={};return t&&await Promise.all(Object.entries(t).map((([t,o])=>renderSlotToString(e,o).then((e=>{e.instructions&&(null===r&&(r=[]),r.push(...e.instructions)),n[t]=e}))))),{slotInstructions:r,children:n}}const Fragment=Symbol.for("astro:fragment"),Renderer=Symbol.for("astro:renderer");new TextEncoder;const decoder=new TextDecoder;function stringifyChunk(e,t){if(isRenderInstruction(t)){const r=t;switch(r.type){case"directive":{const{hydration:t}=r;let n=t&&determineIfNeedsHydrationScript(e),o=t&&determinesIfNeedsDirectiveScript(e,t.directive),i=n?"both":o?"directive":null;if(i){let r=getPrescripts(e,i,t.directive);return markHTMLString(r)}return""}case"head":return e._metadata.hasRenderedHead||e.partial?"":renderAllHeadContent(e);case"maybe-head":return e._metadata.hasRenderedHead||e._metadata.headInTree||e.partial?"":renderAllHeadContent(e);case"renderer-hydration-script":{const{rendererSpecificHydrationScripts:t}=e._metadata,{rendererName:n}=r;return t.has(n)?"":(t.add(n),r.render())}default:throw new Error(`Unknown chunk type: ${t.type}`)}}else{if(t instanceof Response)return"";if(isSlotString(t)){let r="";const n=t;if(n.instructions)for(const t of n.instructions)r+=stringifyChunk(e,t);return r+=t.toString(),r}}return t.toString()}function chunkToString(e,t){return ArrayBuffer.isView(t)?decoder.decode(t):stringifyChunk(e,t)}function isRenderInstance(e){return!!e&&"object"==typeof e&&"render"in e&&"function"==typeof e.render}async function renderChild(e,t){if((t=await t)instanceof SlotString)e.write(t);else if(isHTMLString(t))e.write(t);else if(Array.isArray(t)){const r=t.map((e=>renderToBufferDestination((t=>renderChild(t,e)))));for(const t of r)t&&await t.renderToFinalDestination(e)}else if("function"==typeof t)await renderChild(e,t());else if("string"==typeof t)e.write(markHTMLString(escapeHTML(t)));else if(t||0===t)if(isRenderInstance(t))await t.render(e);else if(isRenderTemplateResult(t))await t.render(e);else if(isAstroComponentInstance(t))await t.render(e);else if(ArrayBuffer.isView(t))e.write(t);else if("object"==typeof t&&(Symbol.asyncIterator in t||Symbol.iterator in t))for await(const r of t)await renderChild(e,r);else e.write(t);else;}const astroComponentInstanceSym=Symbol.for("astro.componentInstance");class AstroComponentInstance{[astroComponentInstanceSym]=!0;result;props;slotValues;factory;returnValue;constructor(e,t,r,n){this.result=e,this.props=t,this.factory=n,this.slotValues={};for(const t in r){let n=!1,o=r[t](e);this.slotValues[t]=()=>n?r[t](e):(n=!0,o)}}async init(e){return void 0!==this.returnValue||(this.returnValue=this.factory(e,this.props,this.slotValues)),this.returnValue}async render(e){void 0===this.returnValue&&await this.init(this.result);let t=this.returnValue;isPromise(t)&&(t=await t),isHeadAndContent(t)?await t.content.render(e):await renderChild(e,t)}}function validateComponentProps(e,t){if(null!=e)for(const r of Object.keys(e))r.startsWith("client:")&&console.warn(`You are attempting to render <${t} ${r} />, but ${t} is an Astro component. Astro components do not render in the client and should not have a hydration directive. Please use a framework component for client rendering.`)}function createAstroComponentInstance(e,t,r,n,o={}){validateComponentProps(n,t);const i=new AstroComponentInstance(e,n,o,r);return isAPropagatingComponent(e,r)&&e._metadata.propagators.add(i),i}function isAstroComponentInstance(e){return"object"==typeof e&&!!e[astroComponentInstanceSym]}const renderTemplateResultSym=Symbol.for("astro.renderTemplateResult");class RenderTemplateResult{[renderTemplateResultSym]=!0;htmlParts;expressions;error;constructor(e,t){this.htmlParts=e,this.error=void 0,this.expressions=t.map((e=>isPromise(e)?Promise.resolve(e).catch((e=>{if(!this.error)throw this.error=e,e})):e))}async render(e){const t=this.expressions.map((e=>renderToBufferDestination((t=>{if(e||0===e)return renderChild(t,e)}))));for(let r=0;r<this.htmlParts.length;r++){const n=this.htmlParts[r],o=t[r];e.write(markHTMLString(n)),o&&await o.renderToFinalDestination(e)}}}function isRenderTemplateResult(e){return"object"==typeof e&&!!e[renderTemplateResultSym]}function renderTemplate(e,...t){return new RenderTemplateResult(e,t)}function componentIsHTMLElement(e){return"undefined"!=typeof HTMLElement&&HTMLElement.isPrototypeOf(e)}async function renderHTMLElement(e,t,r,n){const o=getHTMLElementName(t);let i="";for(const e in r)i+=` ${e}="${toAttributeString(await r[e])}"`;return markHTMLString(`<${o}${i}>${await renderSlotToString(e,n?.default)}</${o}>`)}function getHTMLElementName(e){const t=customElements.getName(e);if(t)return t;return e.name.replace(/^HTML|Element$/g,"").replace(/[A-Z]/g,"-$&").toLowerCase().replace(/^-/,"html-")}const rendererAliases=new Map([["solid","solid-js"]]);function guessRenderers(e){const t=e?.split(".").pop();switch(t){case"svelte":return["@astrojs/svelte"];case"vue":return["@astrojs/vue"];case"jsx":case"tsx":return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue (jsx)"];default:return["@astrojs/react","@astrojs/preact","@astrojs/solid-js","@astrojs/vue","@astrojs/svelte","@astrojs/lit"]}}function isFragmentComponent(e){return e===Fragment}function isHTMLComponent(e){return e&&!0===e["astro:html"]}const ASTRO_SLOT_EXP=/<\/?astro-slot\b[^>]*>/g,ASTRO_STATIC_SLOT_EXP=/<\/?astro-static-slot\b[^>]*>/g;function removeStaticAstroSlot(e,t=!0){const r=t?ASTRO_STATIC_SLOT_EXP:ASTRO_SLOT_EXP;return e.replace(r,"")}async function renderFrameworkComponent(e,t,r,n,o={}){if(!r&&!n["client:only"])throw new Error(`Unable to render ${t} because it is ${r}!\nDid you forget to import the component or is it possible there is a typo?`);const{renderers:i,clientDirectives:s}=e,a={astroStaticSlot:!0,displayName:t},{hydration:c,isPage:l,props:d,propsWithoutTransitionAttributes:u}=extractDirectives(n,s);let m,p="";c&&(a.hydrate=c.directive,a.hydrateArgs=c.value,a.componentExport=c.componentExport,a.componentUrl=c.componentUrl);const h=guessRenderers(a.componentUrl),f=i.filter((e=>"astro:jsx"!==e.name)),{children:g,slotInstructions:y}=await renderSlots(e,o);let b,S;if("only"!==a.hydrate){let t=!1;try{t=r&&r[Renderer]}catch{}if(t){const e=r[Renderer];b=i.find((({name:t})=>t===e))}if(!b){let t;for(const n of i)try{if(await n.ssr.check.call({result:e},r,d,g)){b=n;break}}catch(e){t??=e}if(!b&&t)throw t}if(!b&&"function"==typeof HTMLElement&&componentIsHTMLElement(r)){const t=await renderHTMLElement(e,r,n,o);return{render(e){e.write(t)}}}}else{if(a.hydrateArgs){const e=a.hydrateArgs,t=rendererAliases.has(e)?rendererAliases.get(e):e;b=i.find((({name:e})=>e===`@astrojs/${t}`||e===t))}if(b||1!==f.length||(b=f[0]),!b){const e=a.componentUrl?.split(".").pop();b=i.filter((({name:t})=>t===`@astrojs/${e}`||t===e))[0]}}if(b)if("only"===a.hydrate)p=await renderSlotToString(e,o?.fallback);else{const t=performance.now();({html:p,attrs:m}=await b.ssr.renderToStaticMarkup.call({result:e},r,u,g,a)),"development"===process.env.NODE_ENV&&(S=performance.now()-t)}else{if("only"===a.hydrate)throw new AstroError({...NoClientOnlyHint,message:NoClientOnlyHint.message(a.displayName),hint:NoClientOnlyHint.hint(h.map((e=>e.replace("@astrojs/",""))).join("|"))});if("string"!=typeof r){const t=f.filter((e=>h.includes(e.name))),n=f.length>1;if(0===t.length)throw new AstroError({...NoMatchingRenderer,message:NoMatchingRenderer.message(a.displayName,a?.componentUrl?.split(".").pop(),n,f.length),hint:NoMatchingRenderer.hint(formatList(h.map((e=>"`"+e+"`"))))});if(1!==t.length)throw new Error(`Unable to render ${a.displayName}!\n\nThis component likely uses ${formatList(h)},\nbut Astro encountered an error during server-side rendering.\n\nPlease ensure that ${a.displayName}:\n1. Does not unconditionally access browser-specific globals like \`window\` or \`document\`.\n   If this is unavoidable, use the \`client:only\` hydration directive.\n2. Does not conditionally return \`null\` or \`undefined\` when rendered on the server.\n\nIf you're still stuck, please open an issue on GitHub or join us at https://astro.build/chat.`);b=t[0],({html:p,attrs:m}=await b.ssr.renderToStaticMarkup.call({result:e},r,u,g,a))}}if(b&&!b.clientEntrypoint&&"@astrojs/lit"!==b.name&&a.hydrate)throw new AstroError({...NoClientEntrypoint,message:NoClientEntrypoint.message(t,a.hydrate,b.name)});if(!p&&"string"==typeof r){const t=sanitizeElementName(r),n=Object.values(g).join(""),o=renderTemplate`<${t}${internalSpreadAttributes(d)}${markHTMLString(""===n&&voidElementNames.test(t)?"/>":`>${n}</${t}>`)}`;p="";const i={write(t){t instanceof Response||(p+=chunkToString(e,t))}};await o.render(i)}if(!c)return{render(e){if(y)for(const t of y)e.write(t);l||"astro:jsx"===b?.name?e.write(p):p&&p.length>0&&e.write(markHTMLString(removeStaticAstroSlot(p,b?.ssr?.supportsAstroStaticSlot)))}};const v=shorthash(`\x3c!--${a.componentExport.value}:${a.componentUrl}--\x3e\n${p}\n${serializeProps(d,a)}`),A=await generateHydrateScript({renderer:b,result:e,astroId:v,props:d,attrs:m},a);S&&"development"===process.env.NODE_ENV&&(A.props["server-render-time"]=S);let w=[];if(p){if(Object.keys(g).length>0)for(const e of Object.keys(g)){let t=b?.ssr?.supportsAstroStaticSlot?a.hydrate?"astro-slot":"astro-static-slot":"astro-slot",r="default"===e?`<${t}>`:`<${t} name="${e}">`;p.includes(r)||w.push(e)}}else w=Object.keys(g);const C=w.length>0?w.map((e=>`<template data-astro-template${"default"!==e?`="${e}"`:""}>${g[e]}</template>`)).join(""):"";return A.children=`${p??""}${C}`,A.children&&(A.props["await-children"]="",A.children+="\x3c!--astro:end--\x3e"),{render(e){if(y)for(const t of y)e.write(t);e.write(createRenderInstruction({type:"directive",hydration:c})),"only"!==c.directive&&b?.ssr.renderHydrationScript&&e.write(createRenderInstruction({type:"renderer-hydration-script",rendererName:b.name,render:b.ssr.renderHydrationScript}));const t=renderElement("astro-island",A,!1);e.write(markHTMLString(t))}}}function sanitizeElementName(e){const t=/[&<>'"\s]+/;return t.test(e)?e.trim().split(t)[0].trim():e}async function renderFragmentComponent(e,t={}){const r=await renderSlotToString(e,t?.default);return{render(e){null!=r&&e.write(r)}}}async function renderHTMLComponent(e,t,r,n={}){const{slotInstructions:o,children:i}=await renderSlots(e,n),s=t({slots:i}),a=o?o.map((t=>chunkToString(e,t))).join(""):"";return{render(e){e.write(markHTMLString(a+s))}}}function renderAstroComponent(e,t,r,n,o={}){const i=createAstroComponentInstance(e,t,r,n,o);return{async render(e){await i.render(e)}}}async function renderComponent(e,t,r,n,o={}){return isPromise(r)&&(r=await r.catch(i)),isFragmentComponent(r)?await renderFragmentComponent(e,o).catch(i):(n=normalizeProps(n),isHTMLComponent(r)?await renderHTMLComponent(e,r,n,o).catch(i):isAstroComponentFactory(r)?renderAstroComponent(e,t,r,n,o):await renderFrameworkComponent(e,t,r,n,o).catch(i));function i(t){if(e.cancelled)return{render(){}};throw t}}function normalizeProps(e){if(void 0!==e["class:list"]){const t=e["class:list"];delete e["class:list"],e.class=clsx(e.class,t),""===e.class&&delete e.class}return e}function spreadAttributes(e={},t,{class:r}={}){let n="";r&&(void 0!==e.class?e.class+=` ${r}`:void 0!==e["class:list"]?e["class:list"]=[e["class:list"],r]:e.class=r);for(const[t,r]of Object.entries(e))n+=addAttribute(r,t,!0);return markHTMLString(n)}function defineStyleVars(e){let t="",r=Array.isArray(e)?e:[e];for(const e of r)for(const[r,n]of Object.entries(e))(n||0===n)&&(t+=`--${r}: ${n};`);return markHTMLString(t)}"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ-_".split("").reduce(((e,t)=>(e[t.charCodeAt(0)]=t,e)),[]),"-0123456789_".split("").reduce(((e,t)=>(e[t.charCodeAt(0)]=t,e)),[]);export{AstroError,ExpectedImage,ExpectedImageOptions,FailedToFetchRemoteImageDimensions,Fragment,ImageMissingAlt,IncompatibleDescriptorOptions,InvalidImageService,LocalImageUsedWrongly,MissingImageDimension,MissingSharp,UnsupportedImageConversion,UnsupportedImageFormat,addAttribute,createAstro,createComponent,defineStyleVars,maybeRenderHead,renderComponent,renderHead,renderSlot,renderTemplate,spreadAttributes,unescapeHTML};