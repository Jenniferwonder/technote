import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="bowser-cache">Bowser Cache<a class="anchor" href="#bowser-cache"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="浏览器缓存类型">浏览器缓存类型<a class="anchor" href="#浏览器缓存类型"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。\n浏览器缓存主要分为以下几种类型：</p>\n<ol>\n<li><strong>强缓存</strong>： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制：\n<ul>\n<li><code>Expires</code>：指定资源的过期时间。例如：<code>Expires: Wed, 21 Oct 2023 07:28:00 GMT</code>。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。</li>\n<li><code>Cache-Control</code>：使用更现代且准确的方式控制缓存。例如：<code>Cache-Control: max-age=3600</code>，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 <code>no-cache</code>、<code>no-store</code>、<code>must-revalidate</code> 等。</li>\n</ul>\n</li>\n<li><strong>协商缓存</strong>： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制：\n<ul>\n<li><code>Last-Modified</code> 和 <code>If-Modified-Since</code>：服务器返回资源时，通过 <code>Last-Modified</code> 响应头指定资源最后修改时间。浏览器下次请求时会通过 <code>If-Modified-Since</code> 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 <code>304 Not Modified</code> 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 <code>Last-Modified</code> 时间。</li>\n<li><code>ETag</code> 和 <code>If-None-Match</code>：<code>ETag</code> 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 <code>If-None-Match</code> 请求头发送这个标识。服务器会比较这个标识和资源的当前 <code>ETag</code>，如果相同，则返回 <code>304 Not Modified</code> 状态码；否则返回更新后的资源和新的 <code>ETag</code>。</li>\n</ul>\n</li>\n<li><strong>其他缓存技术</strong>： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。</li>\n</ol>\n<h3 id="什么是强缓存策略">什么是强缓存策略？<a class="anchor" href="#什么是强缓存策略"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>浏览器缓存 Expires 属性和 Cache-Control 属性都属于强缓存策略。\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\nhttp 头信息中的 <strong>Expires</strong> 属性\n服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个<strong>绝对时间，它是服务器的时间</strong>，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\nhttp 头信息中的 <strong>Cache-Control</strong> 属性\nExpires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如：\n通过设置 <strong>max-age</strong> 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires 来说，这种方式更加有效一些。\n<strong>private</strong>，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。\n<strong>no-store</strong> ，用来指定资源不能够被缓存。\n<strong>no-cache</strong> 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。</p>\n<h3 id="浏览器的离线缓存与本地缓存的区别">浏览器的离线缓存与本地缓存的区别<a class="anchor" href="#浏览器的离线缓存与本地缓存的区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：</p>\n<ol>\n<li>目的：\n离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。\n本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。</li>\n<li>存储类型：\n离线缓存：使用 HTML5 的 Application Cache（AppCache）和 Service Worker 技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括 HTML、CSS、JavaScript 等资源。\n本地缓存：使用浏览器提供的缓存策略和存储机制实现，如 HTTP 缓存、Cookie、Web Storage（包括 localStorage 和 sessionStorage）和 IndexedDB 等。</li>\n<li>生命周期：\n离线缓存：由开发者通过 AppCache 或 Service Worker 配置文件控制，包括缓存资源的更新和过期策略。\n本地缓存：由浏览器或服务器通过 HTTP 头部字段（如 Cache-Control、Expires 等）控制，或通过脚本（如 localStorage 和 IndexedDB）设置的存储时间限制。</li>\n<li>适用场景：\n离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。\n本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。\n总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。</li>\n</ol>\n<h2 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWvc0lkLpgyEW_u7bbMdvpQ" title="https://mp.weixin.qq.com/s/Wvc0lkLpgyEW_u7bbMdvpQ">关于浏览器缓存你知道多少</a></li>\n<li><a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiangxingchen%2Fblog%2Fissues%2F9" title="https://github.com/xiangxingchen/blog/issues/9">浏览器缓存</a></li>\n<li><a href="https://link.segmentfault.com/?enc=VEalvxDiCPNvvV%2F3rJkacA%3D%3D.wColD0sWDLmBR9ceJ6kUV5SKtSZ%2Bax3ECpL856lAOTPMTe8dFknkEO0LW5GUJ%2FLR">浏览器缓存知识小结及应用</a></li>\n<li><a href="https://link.segmentfault.com/?enc=Qw7RpAR%2B2QlW3yjE8s2PdA%3D%3D.vbod66g%2Fl0GTIboRNtYpY4dmZ8iMRU2oAY3gBtWsV9xFOGCeD1dxwhHQuLBy%2BuIoWJdGHCjaGe1EsY5lZi6G%2Fw%3D%3D">浅谈 Web 缓存</a></li>\n</ul>',frontmatter={category:"Network",title:"Bowser Cache",topic:["Browser"],type:"D",tags:["Network","Browser"],DateStarted:"2024-04-11T00:00:00.000Z",DateModified:"2024-06-11T00:00:00.000Z",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,aliases:["Bowser Cache"],"linter-yaml-title-alias":"Bowser Cache",draft:!0,minutes:8,words:1633},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/network/browser/bowser-cache.md",url=void 0;function rawContent(){return'\n# Bowser Cache\n### 浏览器缓存类型\n浏览器缓存是一种性能优化技术，通过将已请求的资源（如 HTML、CSS、JavaScript、图片等）存储在本地，以减少网络请求和数据传输。当用户再次访问相同的资源时，浏览器可以直接从缓存中获取，从而加快页面加载速度、降低服务器压力和减少网络流量消耗。\n浏览器缓存主要分为以下几种类型：\n1. **强缓存**： 强缓存是指浏览器在缓存期间内不会再向服务器发送任何请求，而是直接从本地缓存中获取资源。强缓存由以下两个 HTTP 响应头控制：\n   - `Expires`：指定资源的过期时间。例如：`Expires: Wed, 21 Oct 2023 07:28:00 GMT`。但由于服务器时间和客户端时间可能存在差异，所以这个响应头不太准确。\n   - `Cache-Control`：使用更现代且准确的方式控制缓存。例如：`Cache-Control: max-age=3600`，表示资源的缓存有效期为 3600 秒。其他可用的指令还包括 `no-cache`、`no-store`、`must-revalidate` 等。\n2. **协商缓存**： 当强缓存失效后，浏览器会向服务器发送请求，以验证资源是否有更新。协商缓存通过以下 HTTP 响应头和请求头控制：\n   - `Last-Modified` 和 `If-Modified-Since`：服务器返回资源时，通过 `Last-Modified` 响应头指定资源最后修改时间。浏览器下次请求时会通过 `If-Modified-Since` 请求头发送这个时间。服务器会比较这个时间和资源的实际修改时间，如果没有变化，则返回 `304 Not Modified` 状态码，浏览器将使用本地缓存；否则返回更新后的资源和新的 `Last-Modified` 时间。\n   - `ETag` 和 `If-None-Match`：`ETag` 是服务器为资源生成的唯一标识（通常是哈希值）。浏览器下次请求时会通过 `If-None-Match` 请求头发送这个标识。服务器会比较这个标识和资源的当前 `ETag`，如果相同，则返回 `304 Not Modified` 状态码；否则返回更新后的资源和新的 `ETag`。\n3. **其他缓存技术**： 除了上述浏览器缓存机制外，还有一些其他缓存技术，如 Service Workers、Memory Cache、IndexedDB 等。它们可以根据具体需求和场景进行灵活地缓存策略配置。\n### 什么是强缓存策略？\n浏览器缓存 Expires 属性和 Cache-Control 属性都属于强缓存策略。\n使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。\nhttp 头信息中的 **Expires** 属性\n服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个**绝对时间，它是服务器的时间**，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。\nhttp 头信息中的 **Cache-Control** 属性\nExpires 是 http1.0 中的方式，因为它的一些缺点，在 http 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，常用的比如：\n通过设置 **max-age** 来指定资源能够被缓存的时间的大小，这是一个相对的时间，它会根据这个时间的大小和资源第一次请求时的时间来计算出资源过期的时间，因此相对于 Expires 来说，这种方式更加有效一些。\n**private**，用来规定资源只能被客户端缓存，不能够代理服务器所缓存。\n**no-store** ，用来指定资源不能够被缓存。\n**no-cache** 代表该资源能够被缓存，但是立即失效，每次都需要向服务器发起请求。\n一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires 。\n### 浏览器的离线缓存与本地缓存的区别\n浏览器的离线缓存和本地缓存都是用于在用户设备上存储数据以提高网页性能的技术，但它们的实现方式和使用场景略有不同。下面是它们之间的一些主要区别：\n1. 目的：\n离线缓存：主要用于在用户离线时仍然可以访问网页。它可以在没有网络连接的情况下提供基本的功能，如查看已缓存页面的内容。\n本地缓存：主要用于减少网络延迟，提高加载速度。通过在用户设备上缓存常用资源，如图片、脚本、样式等，可以在用户再次访问网站时直接从缓存中读取，降低服务器负担和提高用户体验。\n1. 存储类型：\n离线缓存：使用 HTML5 的 Application Cache（AppCache）和 Service Worker 技术实现。这些技术允许开发者为用户设备创建一个离线版本的网页，包括 HTML、CSS、JavaScript 等资源。\n本地缓存：使用浏览器提供的缓存策略和存储机制实现，如 HTTP 缓存、Cookie、Web Storage（包括 localStorage 和 sessionStorage）和 IndexedDB 等。\n1. 生命周期：\n离线缓存：由开发者通过 AppCache 或 Service Worker 配置文件控制，包括缓存资源的更新和过期策略。\n本地缓存：由浏览器或服务器通过 HTTP 头部字段（如 Cache-Control、Expires 等）控制，或通过脚本（如 localStorage 和 IndexedDB）设置的存储时间限制。\n1. 适用场景：\n离线缓存：适用于需要在无网络环境下访问的网页，例如离线阅读应用、PWA（Progressive Web Apps）等。\n本地缓存：适用于任何需要提高网站性能和加载速度的场景，减少不必要的网络请求。\n总之，离线缓存和本地缓存都是为了优化网页性能，它们各自针对不同的使用场景。离线缓存主要是为了在没有网络连接时继续访问网页，而本地缓存则是为了提高网页加载速度和降低服务器负担。\n## Reference\n- [关于浏览器缓存你知道多少](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2FWvc0lkLpgyEW_u7bbMdvpQ "https://mp.weixin.qq.com/s/Wvc0lkLpgyEW_u7bbMdvpQ")\n- [浏览器缓存](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fxiangxingchen%2Fblog%2Fissues%2F9 "https://github.com/xiangxingchen/blog/issues/9")\n- [浏览器缓存知识小结及应用](https://link.segmentfault.com/?enc=VEalvxDiCPNvvV%2F3rJkacA%3D%3D.wColD0sWDLmBR9ceJ6kUV5SKtSZ%2Bax3ECpL856lAOTPMTe8dFknkEO0LW5GUJ%2FLR)\n- [浅谈 Web 缓存](https://link.segmentfault.com/?enc=Qw7RpAR%2B2QlW3yjE8s2PdA%3D%3D.vbod66g%2Fl0GTIboRNtYpY4dmZ8iMRU2oAY3gBtWsV9xFOGCeD1dxwhHQuLBy%2BuIoWJdGHCjaGe1EsY5lZi6G%2Fw%3D%3D)\n\n\n\n'}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"bowser-cache",text:"Bowser Cache#"},{depth:3,slug:"浏览器缓存类型",text:"浏览器缓存类型#"},{depth:3,slug:"什么是强缓存策略",text:"什么是强缓存策略？#"},{depth:3,slug:"浏览器的离线缓存与本地缓存的区别",text:"浏览器的离线缓存与本地缓存的区别#"},{depth:2,slug:"reference",text:"Reference#"}]}const Content=createComponent(((e,n,o)=>{const{layout:t,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};