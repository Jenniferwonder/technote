import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="weakmap">WeakMap<a class="anchor" href="#weakmap"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="basic-api">Basic API<a class="anchor" href="#basic-api"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>const wm = new WeakMap();</li>\n<li>构造函数可以接收一个可迭代对象，其中需要包含键/值对数组</li>\n<li>使用嵌套数组初始化弱映射</li>\n<li>只要有一个键无效就会抛出错误，导致整个初始化失败</li>\n<li>WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集</li>\n<li>WeakMap 中的“weak”（弱）， 描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式</li>\n<li>set()</li>\n<li>get()</li>\n<li>has()</li>\n<li>delete()</li>\n</ul>\n<h2 id="weak-keys">Weak Keys<a class="anchor" href="#weak-keys"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>这些键不属于正式的引用， 不会阻止垃圾回收</li>\n<li>弱映射中值</li>\n<li>只要键存在，键/值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收</li>\n</ul>\n<h2 id="non-iterable-keys">Non-Iterable Keys<a class="anchor" href="#non-iterable-keys"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>clear()\n<ul>\n<li>。WeakMap 确实没有这个方法</li>\n</ul>\n</li>\n<li>WeakMap 中的键/值对任何时候都可能被销毁</li>\n</ul>\n<h2 id="utility">Utility<a class="anchor" href="#utility"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>Private Variables\n<ul>\n<li>私有变量</li>\n<li>用一个闭包把 WeakMap 包装起来，这样就可以把弱映 射与外界完全隔离开了</li>\n<li>虽然这防止了前面提到的访问，但 整个代码也完全陷入了 ES6 之前的闭包私有变量模式</li>\n</ul>\n</li>\n<li>DOM Node Metadata\n<ul>\n<li>DOM 节点元数据</li>\n<li>因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691559775005.png" alt=""></li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691559786052.png" alt=""></li>\n</ul>\n</li>\n</ul>',frontmatter={Datereviewed:null,reviewed:null,difficulty:null,comment:null,aliases:["WeakMap"],title:"WeakMap",type:"D",DateStarted:"2023-08-06T00:00:00.000Z",DateModified:"2024-06-11T00:00:00.000Z",status:"Snooze",pages:6,Up:[["C06-Collection Reference Type-集合引用类型"]],Pomo:1,topic:["DS+"],category:"Programming",tags:["JavaScript"],draft:!0,"linter-yaml-title-alias":"WeakMap",minutes:2,words:307},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/ds-plus/weakmap.md",url=void 0;function rawContent(){return"\n# WeakMap\n\n## Basic API\n\n- const wm = new WeakMap();\n- 构造函数可以接收一个可迭代对象，其中需要包含键/值对数组\n- 使用嵌套数组初始化弱映射\n- 只要有一个键无效就会抛出错误，导致整个初始化失败\n- WeakMap 是 Map 的“兄弟”类型，其 API 也是 Map 的子集\n- WeakMap 中的“weak”（弱）， 描述的是 JavaScript 垃圾回收程序对待“弱映射”中键的方式\n- set()\n- get()\n- has()\n- delete()\n\n## Weak Keys\n\n- 这些键不属于正式的引用， 不会阻止垃圾回收\n- 弱映射中值\n- 只要键存在，键/值 对就会存在于映射中，并被当作对值的引用，因此就不会被当作垃圾回收\n\n## Non-Iterable Keys\n\n- clear()\n  - 。WeakMap 确实没有这个方法\n- WeakMap 中的键/值对任何时候都可能被销毁\n\n## Utility\n\n- Private Variables\n  - 私有变量\n  - 用一个闭包把 WeakMap 包装起来，这样就可以把弱映 射与外界完全隔离开了\n  - 虽然这防止了前面提到的访问，但 整个代码也完全陷入了 ES6 之前的闭包私有变量模式\n- DOM Node Metadata\n  - DOM 节点元数据\n  - 因为 WeakMap 实例不会妨碍垃圾回收，所以非常适合保存关联元数据\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691559775005.png)\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1691559786052.png)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"weakmap",text:"WeakMap#"},{depth:2,slug:"basic-api",text:"Basic API#"},{depth:2,slug:"weak-keys",text:"Weak Keys#"},{depth:2,slug:"non-iterable-keys",text:"Non-Iterable Keys#"},{depth:2,slug:"utility",text:"Utility#"}]}const Content=createComponent(((n,e,a)=>{const{layout:i,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};