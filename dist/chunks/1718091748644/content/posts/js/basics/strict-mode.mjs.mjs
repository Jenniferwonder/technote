import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h2 id="对严格模式的理解">对严格模式的理解<a class="anchor" href="#对严格模式的理解"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>要启用严格模式，可以在脚本或函数开头添加<code>"use strict";</code>指令。这将对整个脚本或函数体中的代码启用严格模式。推荐使用严格模式编写代码，因为它可以帮助发现潜在的错误并避免一些不良的编程实践。</p>\n<p>在 JavaScript 中，严格模式（strict mode）和非严格模式（sloppy mode）主要有以下几个区别：</p>\n<ol>\n<li>变量声明： 在严格模式下，必须明确地声明变量（使用<code>let</code>、<code>const</code>或<code>var</code>关键字）。否则，将会抛出一个引用错误（ReferenceError）。在非严格模式下，如果没有声明变量，JavaScript 会自动将其声明为全局变量，这可能会导致意外的全局污染。</li>\n<li>this 指针： 在严格模式下，全局作用域中的<code>this</code>值为<code>undefined</code>。在非严格模式下，全局作用域中的<code>this</code>值为全局对象（浏览器环境中为<code>window</code>对象，Node.js 环境中为<code>global</code>对象）。此外，在严格模式下，不允许使用<code>call</code>、<code>apply</code>或<code>bind</code>将<code>this</code>值设置为<code>null</code>或<code>undefined</code>。</li>\n<li>禁止使用未来保留字： 严格模式中，不能将一些未来保留字（如<code>implements</code>、<code>interface</code>、<code>let</code>、<code>package</code>、<code>private</code>、<code>protected</code>、<code>public</code>、<code>static</code>和<code>yield</code>）用作变量名或函数名。</li>\n<li>禁止使用八进制字面量： 在严格模式下，不允许使用八进制字面量（如<code>0123</code>）。非严格模式下，八进制字面量是允许的。</li>\n<li>禁止删除变量、函数和函数参数： 严格模式中，使用<code>delete</code>操作符删除变量、函数和函数参数会引发语法错误（SyntaxError）。在非严格模式下，这样的操作是允许的，但实际上不会删除这些对象。</li>\n<li>限制函数参数的重复声明： 在严格模式下，如果一个函数具有多个相同名称的参数，将会抛出一个语法错误。非严格模式下允许这种重复声明，但只有最后一个参数值会生效。</li>\n<li>错误处理： 严格模式相较于非严格模式，更严格地处理某些类型的错误。例如，当试图修改只读属性、给不可扩展的对象添加属性或删除不可配置的属性时，严格模式会抛出类型错误（TypeError），而非严格模式下则会静默失败。</li>\n</ol>',frontmatter={title:"strict-mode",topic:["Practice"],type:"D",tags:["JavaScript"],category:"Programming",DateStarted:"2024-04-25T00:00:00.000Z",DateModified:"2024-06-11T00:00:00.000Z",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,draft:!0,minutes:3,words:593},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/basics/strict-mode.md",url=void 0;function rawContent(){return'## 对严格模式的理解\n要启用严格模式，可以在脚本或函数开头添加`"use strict";`指令。这将对整个脚本或函数体中的代码启用严格模式。推荐使用严格模式编写代码，因为它可以帮助发现潜在的错误并避免一些不良的编程实践。\n\n在 JavaScript 中，严格模式（strict mode）和非严格模式（sloppy mode）主要有以下几个区别：\n1. 变量声明： 在严格模式下，必须明确地声明变量（使用`let`、`const`或`var`关键字）。否则，将会抛出一个引用错误（ReferenceError）。在非严格模式下，如果没有声明变量，JavaScript 会自动将其声明为全局变量，这可能会导致意外的全局污染。\n2. this 指针： 在严格模式下，全局作用域中的`this`值为`undefined`。在非严格模式下，全局作用域中的`this`值为全局对象（浏览器环境中为`window`对象，Node.js 环境中为`global`对象）。此外，在严格模式下，不允许使用`call`、`apply`或`bind`将`this`值设置为`null`或`undefined`。\n3. 禁止使用未来保留字： 严格模式中，不能将一些未来保留字（如`implements`、`interface`、`let`、`package`、`private`、`protected`、`public`、`static`和`yield`）用作变量名或函数名。\n4. 禁止使用八进制字面量： 在严格模式下，不允许使用八进制字面量（如`0123`）。非严格模式下，八进制字面量是允许的。\n5. 禁止删除变量、函数和函数参数： 严格模式中，使用`delete`操作符删除变量、函数和函数参数会引发语法错误（SyntaxError）。在非严格模式下，这样的操作是允许的，但实际上不会删除这些对象。\n6. 限制函数参数的重复声明： 在严格模式下，如果一个函数具有多个相同名称的参数，将会抛出一个语法错误。非严格模式下允许这种重复声明，但只有最后一个参数值会生效。\n7. 错误处理： 严格模式相较于非严格模式，更严格地处理某些类型的错误。例如，当试图修改只读属性、给不可扩展的对象添加属性或删除不可配置的属性时，严格模式会抛出类型错误（TypeError），而非严格模式下则会静默失败。'}function compiledContent(){return html}function getHeadings(){return[{depth:2,slug:"对严格模式的理解",text:"对严格模式的理解#"}]}const Content=createComponent(((e,o,t)=>{const{layout:c,...n}=frontmatter;return n.file=file,n.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};