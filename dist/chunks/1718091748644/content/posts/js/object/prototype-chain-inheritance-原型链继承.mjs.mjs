import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="prototype-chain-inheritance-原型链继承">Prototype Chain Inheritance-原型链继承<a class="anchor" href="#prototype-chain-inheritance-原型链继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="理解原型链-prototype-chain">理解原型链 (Prototype Chain)<a class="anchor" href="#理解原型链-prototype-chain"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>原型链是 JavaScript 中实现继承的一种机制，它通过让一个对象的原型指向另一个对象，从而使得一个对象可以访问另一个对象中定义的属性和方法。当我们试图访问一个对象中不存在的属性或方法时，JavaScript 引擎会沿着原型链一直向上查找，直到找到该属性或方法为止，或者最终抵达 Object.prototype（所有对象的祖先）上停止查找。<br>\nThe prototype will have its own prototype, making what’s called a <strong>prototype chain</strong>. The chain ends when we reach a prototype that has <code>null</code> for its own prototype.<br>\n它的作用就是当你在访问一个对象上属性的时候，如果该对象内部不存在这个属性，那么就会去它<code>__proto__</code>属性所指向的对象（原型对象）上查找。如果原型对象依旧不存在这个属性，那么就会去其原型的<code>__proto__</code>属性所指向的原型对象上去查找。以此类推，直到找到<code>nul</code>，而这个查找的线路，也就构成了我们常说的<strong>原型链</strong></p>\n<h3 id="原型链继承">原型链继承<a class="anchor" href="#原型链继承"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p><a href="">prototype-chain-inheritance-原型链继承</a></p>\n</blockquote>\n<ul>\n<li><code>SubType.prototype = new SuperType();</code></li>\n<li>通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型\n<ul>\n<li>原型链扩展了前面描述的原型搜索机制</li>\n</ul>\n</li>\n<li>任何函数的默认原型都是一个 Object 的实例</li>\n<li>子类有时候需要覆盖父类的方法，或者增加父类没有的方法\n<ul>\n<li>这些方法必须在原型赋值之后再添加到原型上</li>\n<li>上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的</li>\n</ul>\n</li>\n</ul>\n<h4 id="特点">特点<a class="anchor" href="#特点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>实例可继承的属性有：</p>\n<ul>\n<li>实例的构造函数的属性\n<ul>\n<li>属性通常会在构造函数中定义而不会定义在原型上</li>\n</ul>\n</li>\n<li>父类构造函数属性</li>\n<li>父类原型的属性（新实例不会继承父类实例的属性）</li>\n</ul>\n<h4 id="原型链继承的问题">原型链继承的问题<a class="anchor" href="#原型链继承的问题"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>The prototype chain’s behavior is less like inheritance and more like <strong>delegation</strong>.</li>\n<li>原型中包含的引用值会在所有实例间共享，会导致所有实例默认都取得相同的属性值</li>\n<li>原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！</li>\n<li>继承单一，新实例无法向父类构造函数传参</li>\n</ul>\n<h2 id="prototype-pattern-原型模式"><a href="prototype-pattern-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F">Prototype Pattern-原型模式</a><a class="anchor" href="#prototype-pattern-原型模式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">Inheritance and the prototype chain - JavaScript | MDN</a></li>\n<li><a href="https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes">Object prototypes - Learn web development | MDN</a></li>\n<li>[一文吃透所有 JS 原型相关知识点](<a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a> <a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a>)</li>\n<li>[最详尽的 JS 原型与原型链终极详解](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771">https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771</a> <a href="https://www.jianshu.com/p/dee9f8b14771">https://www.jianshu.com/p/dee9f8b14771</a>)</li>\n<li>[深入理解 JavaScript 原型](<a href="https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1UDILezroK5wrcK-Z5bHOg">https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1UDILezroK5wrcK-Z5bHOg</a> <a href="https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg">https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg</a>)</li>\n<li>[【THE LAST TIME】一文吃透所有 JS 原型相关知识点](<a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a> <a href="https://juejin.cn/post/6844903984335945736">https://juejin.cn/post/6844903984335945736</a>)</li>\n<li>[重新认识构造函数、原型和原型链](<a href="https://juejin.cn/post/6844903779079290887">https://juejin.cn/post/6844903779079290887</a> <a href="https://juejin.cn/post/6844903779079290887">https://juejin.cn/post/6844903779079290887</a>)</li>\n<li>[JavaScript 深入之从原型到原型链](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2Fblog%2Fissues%2F2">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2Fblog%2Fissues%2F2</a> <a href="https://github.com/mqyqingfeng/blog/issues/2">https://github.com/mqyqingfeng/blog/issues/2</a>)</li>\n<li>[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771">https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771</a> <a href="https://www.jianshu.com/p/dee9f8b14771">https://www.jianshu.com/p/dee9f8b14771</a>)</li>\n<li>[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F652991a67186">https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F652991a67186</a> <a href="https://www.jianshu.com/p/652991a67186">https://www.jianshu.com/p/652991a67186</a>)</li>\n<li>[最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa4e1e7b6f4f8">https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa4e1e7b6f4f8</a> <a href="https://www.jianshu.com/p/a4e1e7b6f4f8">https://www.jianshu.com/p/a4e1e7b6f4f8</a>)</li>\n<li>[JavaScript 引擎基础：原型优化](<a href="https://link.juejin.cn?target=https%3A%2F%2Fhijiangtao.github.io%2F2018%2F08%2F21%2FPrototypes%2F">https://link.juejin.cn?target=https%3A%2F%2Fhijiangtao.github.io%2F2018%2F08%2F21%2FPrototypes%2F</a> <a href="https://hijiangtao.github.io/2018/08/21/Prototypes/">https://hijiangtao.github.io/2018/08/21/Prototypes/</a>)</li>\n<li>[Prototypes in JavaScript](<a href="https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fbetter-programming%2Fprototypes-in-javascript-5bba2990e04b">https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fbetter-programming%2Fprototypes-in-javascript-5bba2990e04b</a> <a href="https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b">https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b</a>)</li>\n<li>[JavaScript 深入之创建对象的多种方式以及优缺点](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F15">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F15</a> <a href="https://github.com/mqyqingfeng/Blog/issues/15">https://github.com/mqyqingfeng/Blog/issues/15</a>)</li>\n<li>[详解 JS 原型链与继承](<a href="https://link.juejin.cn?target=http%3A%2F%2Flouiszhai.github.io%2F2015%2F12%2F15%2FprototypeChain%2F">https://link.juejin.cn?target=http%3A%2F%2Flouiszhai.github.io%2F2015%2F12%2F15%2FprototypeChain%2F</a> <a href="http://louiszhai.github.io/2015/12/15/prototypeChain/">http://louiszhai.github.io/2015/12/15/prototypeChain/</a>)</li>\n<li>[从<strong>proto</strong>和 prototype 来深入理解 JS 对象和原型链](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcreeperyang%2Fblog%2Fissues%2F9">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcreeperyang%2Fblog%2Fissues%2F9</a> <a href="https://github.com/creeperyang/blog/issues/9">https://github.com/creeperyang/blog/issues/9</a>)</li>\n<li>[代码复用模式](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjayli%2Fjavascript-patterns%2Fblob%2Fmaster%2Fchapter6.markdown">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjayli%2Fjavascript-patterns%2Fblob%2Fmaster%2Fchapter6.markdown</a> <a href="https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown">https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown</a>)</li>\n<li>[JavaScript 中的继承：ES3、ES5 和 ES6](<a href="https://link.juejin.cn?target=http%3A%2F%2Ftianfangye.com%2F2017%2F12%2F31%2Finheritance-in-javascript-es3-es5-and-es6%2F">https://link.juejin.cn?target=http%3A%2F%2Ftianfangye.com%2F2017%2F12%2F31%2Finheritance-in-javascript-es3-es5-and-es6%2F</a> <a href="http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/">http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/</a>)</li>\n</ul>\n<h2 id="more-questions">More Questions<a class="anchor" href="#more-questions"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>Prototypes and the “in” Operator</li>\n<li>Property Enumeration Order</li>\n<li>对象迭代-Object Iteration\n<ul>\n<li>其他原型语法-Alternate Prototype Syntax</li>\n<li>原型的动态性-Dynamic Nature of Prototypes</li>\n<li>原生对象原型-Native Object Prototypes</li>\n</ul>\n</li>\n</ul>',frontmatter={draft:!1,aliases:["Prototype Chain Inheritance-原型链继承"],title:"Prototype Chain Inheritance-原型链继承",tags:["JavaScript"],topic:["OOP"],type:"D",DateStarted:"2022-12-02T00:00:00.000Z",DateModified:"2024-06-11T00:00:00.000Z",Datereviewed:null,status:["ToCapture"],difficulty:"Hard",comment:null,reviewed:1,"linter-yaml-title-alias":"Prototype Chain Inheritance-原型链继承",category:"Programming",minutes:5,words:916},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/object/prototype-chain-inheritance-原型链继承.md",url=void 0;function rawContent(){return"\n# Prototype Chain Inheritance-原型链继承\n\n### 理解原型链 (Prototype Chain)\n\n原型链是 JavaScript 中实现继承的一种机制，它通过让一个对象的原型指向另一个对象，从而使得一个对象可以访问另一个对象中定义的属性和方法。当我们试图访问一个对象中不存在的属性或方法时，JavaScript 引擎会沿着原型链一直向上查找，直到找到该属性或方法为止，或者最终抵达 Object.prototype（所有对象的祖先）上停止查找。  \nThe prototype will have its own prototype, making what's called a **prototype chain**. The chain ends when we reach a prototype that has `null` for its own prototype.  \n它的作用就是当你在访问一个对象上属性的时候，如果该对象内部不存在这个属性，那么就会去它`__proto__`属性所指向的对象（原型对象）上查找。如果原型对象依旧不存在这个属性，那么就会去其原型的`__proto__`属性所指向的原型对象上去查找。以此类推，直到找到`nul`，而这个查找的线路，也就构成了我们常说的**原型链**\n\n### 原型链继承\n\n> [prototype-chain-inheritance-原型链继承]()\n\n- `SubType.prototype = new SuperType();`\n- 通过原型链实现继承之后，搜索就可以继承向上，搜索原型的原型\n  - 原型链扩展了前面描述的原型搜索机制\n- 任何函数的默认原型都是一个 Object 的实例\n- 子类有时候需要覆盖父类的方法，或者增加父类没有的方法\n  - 这些方法必须在原型赋值之后再添加到原型上\n  - 上述两个方法都是在把原型赋值为 SuperType 的实例之后定义的\n\n#### 特点\n\n实例可继承的属性有：\n\n- 实例的构造函数的属性\n  - 属性通常会在构造函数中定义而不会定义在原型上\n- 父类构造函数属性\n- 父类原型的属性（新实例不会继承父类实例的属性）\n\n#### 原型链继承的问题\n\n- The prototype chain's behavior is less like inheritance and more like **delegation**.\n- 原型中包含的引用值会在所有实例间共享，会导致所有实例默认都取得相同的属性值\n- 原型上的属性是共享的，一个实例修改了原型属性，另一个实例的原型属性也会被修改！\n- 继承单一，新实例无法向父类构造函数传参\n\n## [Prototype Pattern-原型模式](prototype-pattern-原型模式)\n\n## Reference\n\n- [Inheritance and the prototype chain - JavaScript | MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)\n- [Object prototypes - Learn web development | MDN](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes)\n- [一文吃透所有 JS 原型相关知识点](https://juejin.cn/post/6844903984335945736 https://juejin.cn/post/6844903984335945736)\n- [最详尽的 JS 原型与原型链终极详解](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771 https://www.jianshu.com/p/dee9f8b14771)\n- [深入理解 JavaScript 原型](https://link.juejin.cn?target=https%3A%2F%2Fmp.weixin.qq.com%2Fs%2F1UDILezroK5wrcK-Z5bHOg https://mp.weixin.qq.com/s/1UDILezroK5wrcK-Z5bHOg)\n- [【THE LAST TIME】一文吃透所有 JS 原型相关知识点](https://juejin.cn/post/6844903984335945736 https://juejin.cn/post/6844903984335945736)\n- [重新认识构造函数、原型和原型链](https://juejin.cn/post/6844903779079290887 https://juejin.cn/post/6844903779079290887)\n- [JavaScript 深入之从原型到原型链](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2Fblog%2Fissues%2F2 https://github.com/mqyqingfeng/blog/issues/2)\n- [最详尽的 JS 原型与原型链终极详解，没有「可能是」。（一）](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fdee9f8b14771 https://www.jianshu.com/p/dee9f8b14771)\n- [最详尽的 JS 原型与原型链终极详解，没有「可能是」。（二）](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2F652991a67186 https://www.jianshu.com/p/652991a67186)\n- [最详尽的 JS 原型与原型链终极详解，没有「可能是」。（三）](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fa4e1e7b6f4f8 https://www.jianshu.com/p/a4e1e7b6f4f8)\n- [JavaScript 引擎基础：原型优化](https://link.juejin.cn?target=https%3A%2F%2Fhijiangtao.github.io%2F2018%2F08%2F21%2FPrototypes%2F https://hijiangtao.github.io/2018/08/21/Prototypes/)\n- [Prototypes in JavaScript](https://link.juejin.cn?target=https%3A%2F%2Fmedium.com%2Fbetter-programming%2Fprototypes-in-javascript-5bba2990e04b https://medium.com/better-programming/prototypes-in-javascript-5bba2990e04b)\n- [JavaScript 深入之创建对象的多种方式以及优缺点](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F15 https://github.com/mqyqingfeng/Blog/issues/15)\n- [详解 JS 原型链与继承](https://link.juejin.cn?target=http%3A%2F%2Flouiszhai.github.io%2F2015%2F12%2F15%2FprototypeChain%2F http://louiszhai.github.io/2015/12/15/prototypeChain/)\n- [从**proto**和 prototype 来深入理解 JS 对象和原型链](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcreeperyang%2Fblog%2Fissues%2F9 https://github.com/creeperyang/blog/issues/9)\n- [代码复用模式](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjayli%2Fjavascript-patterns%2Fblob%2Fmaster%2Fchapter6.markdown https://github.com/jayli/javascript-patterns/blob/master/chapter6.markdown)\n- [JavaScript 中的继承：ES3、ES5 和 ES6](https://link.juejin.cn?target=http%3A%2F%2Ftianfangye.com%2F2017%2F12%2F31%2Finheritance-in-javascript-es3-es5-and-es6%2F http://tianfangye.com/2017/12/31/inheritance-in-javascript-es3-es5-and-es6/)\n\n## More Questions\n\n- Prototypes and the “in” Operator\n- Property Enumeration Order\n- 对象迭代-Object Iteration\n  - 其他原型语法-Alternate Prototype Syntax\n  - 原型的动态性-Dynamic Nature of Prototypes\n  - 原生对象原型-Native Object Prototypes\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"prototype-chain-inheritance-原型链继承",text:"Prototype Chain Inheritance-原型链继承#"},{depth:3,slug:"理解原型链-prototype-chain",text:"理解原型链 (Prototype Chain)#"},{depth:3,slug:"原型链继承",text:"原型链继承#"},{depth:4,slug:"特点",text:"特点#"},{depth:4,slug:"原型链继承的问题",text:"原型链继承的问题#"},{depth:2,slug:"prototype-pattern-原型模式",text:"Prototype Pattern-原型模式#"},{depth:2,slug:"reference",text:"Reference#"},{depth:2,slug:"more-questions",text:"More Questions#"}]}const Content=createComponent(((t,e,n)=>{const{layout:i,...a}=frontmatter;return a.file=file,a.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};