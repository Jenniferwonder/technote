import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="this-in-js">this in JS<a class="anchor" href="#this-in-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<hr>\n<p>Basic</p>\n<h2 id="对-this-的理解-绑定方式">对 <code>this</code> 的理解 (绑定方式)<a class="anchor" href="#对-this-的理解-绑定方式"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>Back:</p>\n<blockquote>\n<p><code>this</code> 是 JavaScript 中一个动态上下文的关键字，它的值取决于函数调用的方式。</p>\n</blockquote>\n<p>在 JavaScript 中，<code>this</code> 是一个特殊的关键字，<code>this</code> 的值取决于函数的调用方式，不同的调用方式会导致 <code>this</code> 指向不同的对象。以下是一些关于 <code>this</code> 的不同用法和场景：</p>\n<h4 id="1-全局上下文">1. 全局上下文<a class="anchor" href="#1-全局上下文"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>当在全局作用域中使用 <code>this</code> 时，它指向全局对象。在浏览器环境中，全局对象是 <code>window</code>；在 Node.js 环境中，全局对象是 <code>global</code>。</p>\n<h4 id="2-函数调用-默认绑定">2. 函数调用 (默认绑定)<a class="anchor" href="#2-函数调用-默认绑定"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>当在函数内部使用 <code>this</code> 且函数作为普通函数调用时（非对象方法调用），<code>this</code> 通常指向全局对象。但在严格模式下（使用 <code>"use strict"</code>），<code>this</code> 会被设置为 <code>undefined</code>。<br>\n定时器中的 this 指向 window</p>\n<h4 id="3-对象方法调用-隐式绑定">3. 对象方法调用 (隐式绑定)<a class="anchor" href="#3-对象方法调用-隐式绑定"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>当在对象的方法内部使用 <code>this</code> 时，<code>this</code> 指向调用该方法的对象。这也适用于原型链中的方法。</li>\n<li>事件中的 this 指向事件的调用者</li>\n</ul>\n<h4 id="4-构造函数调用">4. 构造函数调用<a class="anchor" href="#4-构造函数调用"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>当在构造函数内部使用 <code>this</code> 且使用 <code>new</code> 关键字调用构造函数时，<code>this</code> 指向新创建的对象实例。<br>\n类 class 中的 this 指向由 constructor 构造器 new 出来的实例对象</p>\n<h4 id="5-显式绑定">5. 显式绑定<a class="anchor" href="#5-显式绑定"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>使用 <code>call</code>、<code>apply</code> 或 <code>bind</code> 方法调用函数时，可以显式地将 <code>this</code> 绑定到一个指定的对象。</p>\n<h4 id="6-箭头函数">6. 箭头函数<a class="anchor" href="#6-箭头函数"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>箭头函数没有自己的 <code>this</code>，它从包围它的普通函数或全局作用域继承 <code>this</code>。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 <code>this</code>。</p>\n<ul>\n<li>在事件回调或定时回调中调用某个函数时\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1fc4c4837ed533b9b66067107fee23b3.png" alt="image"></li>\n<li>`setTimeout(() =console.log(this.royaltyName), 1000);</li>\n</ul>\n</li>\n</ul>\n<p>📌: JS::JS-Function<br>\n🏷️: JS-Function</p>\n\x3c!--ID: 1708065505751--\x3e\n<hr>\n<h4 id="2-this-题目-1">2. this 题目 1<a class="anchor" href="#2-this-题目-1"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">use strict;</span></span>\n<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// var定义的a变量挂载到window对象上</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> foo</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(this1, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// undefined</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(window.a); </span><span style="color:#6A737D">// 10</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a); </span><span style="color:#6A737D">//  报错，Uncaught TypeError: Cannot read properties of undefined (reading \'a\')</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(this2, </span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// window</span></span>\n<span class="line"><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"></span></code></pre>\n<p>注意：开启了严格模式，只是使得函数内的 this 指向<code>undefined</code>，它并不会改变全局中 this 的指向。因此<code>this1</code>中打印的是<code>undefined</code>，而<code>this2</code>还是<code>window</code>对象。</p>\n<h4 id="3-this-题目-2">3. this 题目 2<a class="anchor" href="#3-this-题目-2"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">let</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 10</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">const</span><span style="color:#79B8FF"> b</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 20</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> foo</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a); </span><span style="color:#6A737D">// undefined</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.b); </span><span style="color:#6A737D">// undefined</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(window.a); </span><span style="color:#6A737D">// undefined</span></span>\n<span class="line"><span style="color:#E1E4E8">复制代码;</span></span>\n<span class="line"></span></code></pre>\n<p>如果把 var 改成了 let 或 const，变量是不会被绑定到 window 上的，所以此时会打印出三个 undefined</p>\n<h4 id="4-this-题目-3">4. this 题目 3<a class="anchor" href="#4-this-题目-3"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> foo</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">\tvar</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// window</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a); </span><span style="color:#6A737D">// 1</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#B392F0">foo</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"></span></code></pre>\n<p>foo()函数内的 this 指向的是 window，因为是 window 调用的 foo，打印出的<code>this.a</code>是 window 下的<code>a</code></p>\n<h4 id="5-this-题目-4">5. this 题目 4<a class="anchor" href="#5-this-题目-4"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> obj2 </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\ta: </span><span style="color:#79B8FF">2</span><span style="color:#E1E4E8">,</span></span>\n<span class="line"><span style="color:#B392F0">\tfoo1</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a); </span><span style="color:#6A737D">// 2</span></span>\n<span class="line"><span style="color:#E1E4E8">\t},</span></span>\n<span class="line"><span style="color:#B392F0">\tfoo2</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#B392F0">\t\tsetTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// window</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.a); </span><span style="color:#6A737D">// 3</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t},</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> a </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 3</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#E1E4E8">obj2.</span><span style="color:#B392F0">foo1</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">obj2.</span><span style="color:#B392F0">foo2</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"></span></code></pre>\n<p>对于<code>setTimeout</code>中的函数，这里存在隐式绑定的 this 丢失，也就是当我们将函数作为参数传递时,会被隐式赋值，回调函数丢失 this 绑定，因此这时候 setTimeout 中函数内的 this 是指向<code>window</code></p>\n<h4 id="6-this-题目-5">6. this 题目 5<a class="anchor" href="#6-this-题目-5"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> obj </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tname: obj,</span></span>\n<span class="line"><span style="color:#B392F0">\tfoo1</span><span style="color:#E1E4E8">: () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.name); </span><span style="color:#6A737D">// window</span></span>\n<span class="line"><span style="color:#E1E4E8">\t},</span></span>\n<span class="line"><span style="color:#B392F0">\tfoo2</span><span style="color:#E1E4E8">: </span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.name); </span><span style="color:#6A737D">// obj</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> () </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">this</span><span style="color:#E1E4E8">.name); </span><span style="color:#6A737D">// obj</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t};</span></span>\n<span class="line"><span style="color:#E1E4E8">\t},</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"><span style="color:#F97583">var</span><span style="color:#E1E4E8"> name </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> window;</span></span>\n<span class="line"><span style="color:#E1E4E8">obj.</span><span style="color:#B392F0">foo1</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">obj.</span><span style="color:#B392F0">foo2</span><span style="color:#E1E4E8">()();</span></span>\n<span class="line"></span></code></pre>\n<p>这道题非常经典，它证明了<strong>箭头函数内的 this 是由外层作用域决定的</strong></p>\n<h5 id="61-题目-5-解析">6.1. 题目 5 解析：<a class="anchor" href="#61-题目-5-解析"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h5>\n<p>1）对于<code>obj.foo1()</code>函数的调用，它的外层作用域是 window，对象 obj 当然不属于作用域了(作用域只有全局作用域、函数作用域、块级作用域)，所以会打印出<code>window</code><br>\n2）<code>obj.foo2()()</code>，首先会执行<code>obj.foo2()</code>，这不是个箭头函数，所以它里面的 this 是调用它的 obj 对象，因此第二个打印为<code>obj</code>，而返回的匿名函数是一个箭头函数，<strong>它的 this 由外层作用域决定</strong>，那也就是它的 this 会和 foo2 函数里的 this 一样，第三个打印也是<code>obj</code></p>\n<h2 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>[JavaScript 基础心法——this](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F6">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F6</a> <a href="https://github.com/axuebin/articles/issues/6">https://github.com/axuebin/articles/issues/6</a>)</li>\n<li>[面试官问：JS 的 this 指向](<a href="https://juejin.cn/post/6844903746984476686">https://juejin.cn/post/6844903746984476686</a> <a href="https://juejin.cn/post/6844903746984476686">https://juejin.cn/post/6844903746984476686</a>)</li>\n<li>[JavaScript 深入之从 ECMAScript 规范解读 this](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F7">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F7</a> <a href="https://github.com/mqyqingfeng/Blog/issues/7">https://github.com/mqyqingfeng/Blog/issues/7</a>)</li>\n<li>[前端基础进阶（七）：全方位解读 this](<a href="https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd647aa6d1ae6">https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd647aa6d1ae6</a> <a href="https://www.jianshu.com/p/d647aa6d1ae6">https://www.jianshu.com/p/d647aa6d1ae6</a>)</li>\n<li>[再来 40 道 this 面试题酸爽继续(1.2w 字用手整理)](<a href="https://juejin.cn/post/6844904083707396109">https://juejin.cn/post/6844904083707396109</a> <a href="https://juejin.cn/post/6844904083707396109">https://juejin.cn/post/6844904083707396109</a>)</li>\n</ul>',frontmatter={draft:!1,aliases:["this in JS "],title:"this in JS ",topic:["Function"],type:"D",tags:["JavaScript"],DateStarted:"2024-02-16T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",Datereviewed:"2024-02-16T00:00:00.000Z",reviewed:1,difficulty:null,status:null,comment:null,category:"Programming","linter-yaml-title-alias":"this in JS ",minutes:5,words:1075},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/scope/this-in-js.md",url=void 0;function rawContent(){return"\n# this in JS \n\n---\nBasic\n## 对 `this` 的理解 (绑定方式)\nBack:\n\n>`this` 是 JavaScript 中一个动态上下文的关键字，它的值取决于函数调用的方式。\n\n在 JavaScript 中，`this` 是一个特殊的关键字，`this` 的值取决于函数的调用方式，不同的调用方式会导致 `this` 指向不同的对象。以下是一些关于 `this` 的不同用法和场景：\n\n#### 1. 全局上下文\n 当在全局作用域中使用 `this` 时，它指向全局对象。在浏览器环境中，全局对象是 `window`；在 Node.js 环境中，全局对象是 `global`。\n#### 2. 函数调用 (默认绑定)\n 当在函数内部使用 `this` 且函数作为普通函数调用时（非对象方法调用），`this` 通常指向全局对象。但在严格模式下（使用 `\"use strict\"`），`this` 会被设置为 `undefined`。  \n定时器中的 this 指向 window\n#### 3. 对象方法调用 (隐式绑定)\n- 当在对象的方法内部使用 `this` 时，`this` 指向调用该方法的对象。这也适用于原型链中的方法。\n- 事件中的 this 指向事件的调用者 \n#### 4. 构造函数调用\n当在构造函数内部使用 `this` 且使用 `new` 关键字调用构造函数时，`this` 指向新创建的对象实例。  \n类 class 中的 this 指向由 constructor 构造器 new 出来的实例对象\n#### 5. 显式绑定\n使用 `call`、`apply` 或 `bind` 方法调用函数时，可以显式地将 `this` 绑定到一个指定的对象。\n#### 6. 箭头函数\n 箭头函数没有自己的 `this`，它从包围它的普通函数或全局作用域继承 `this`。这使得在事件处理器或回调函数中使用箭头函数非常方便，因为它们自动捕获外部的 `this`。\n - 在事件回调或定时回调中调用某个函数时\n\t - ![image](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/1fc4c4837ed533b9b66067107fee23b3.png)\n\t - `setTimeout(() =console.log(this.royaltyName), 1000);\n\n📌: JS::JS-Function  \n🏷️: JS-Function\n\x3c!--ID: 1708065505751--\x3e\n\n---\n\n#### 2. this 题目 1\n\n```javascript\nuse strict;\nvar a = 10; // var定义的a变量挂载到window对象上\nfunction foo() {\n\tconsole.log(this1, this); // undefined\n\tconsole.log(window.a); // 10\n\tconsole.log(this.a); //  报错，Uncaught TypeError: Cannot read properties of undefined (reading 'a')\n}\nconsole.log(this2, this); // window\nfoo();\n```\n\n注意：开启了严格模式，只是使得函数内的 this 指向`undefined`，它并不会改变全局中 this 的指向。因此`this1`中打印的是`undefined`，而`this2`还是`window`对象。\n\n#### 3. this 题目 2\n\n```javascript\nlet a = 10;\nconst b = 20;\nfunction foo() {\n\tconsole.log(this.a); // undefined\n\tconsole.log(this.b); // undefined\n}\nfoo();\nconsole.log(window.a); // undefined\n复制代码;\n```\n\n如果把 var 改成了 let 或 const，变量是不会被绑定到 window 上的，所以此时会打印出三个 undefined\n\n#### 4. this 题目 3\n\n```javascript\nvar a = 1;\nfunction foo() {\n\tvar a = 2;\n\tconsole.log(this); // window\n\tconsole.log(this.a); // 1\n}\nfoo();\n```\n\nfoo()函数内的 this 指向的是 window，因为是 window 调用的 foo，打印出的`this.a`是 window 下的`a`\n\n#### 5. this 题目 4\n\n```javascript\nvar obj2 = {\n\ta: 2,\n\tfoo1: function () {\n\t\tconsole.log(this.a); // 2\n\t},\n\tfoo2: function () {\n\t\tsetTimeout(function () {\n\t\t\tconsole.log(this); // window\n\t\t\tconsole.log(this.a); // 3\n\t\t}, 0);\n\t},\n};\nvar a = 3;\n\nobj2.foo1();\nobj2.foo2();\n```\n\n对于`setTimeout`中的函数，这里存在隐式绑定的 this 丢失，也就是当我们将函数作为参数传递时,会被隐式赋值，回调函数丢失 this 绑定，因此这时候 setTimeout 中函数内的 this 是指向`window`\n\n#### 6. this 题目 5\n\n```javascript\nvar obj = {\n\tname: obj,\n\tfoo1: () => {\n\t\tconsole.log(this.name); // window\n\t},\n\tfoo2: function () {\n\t\tconsole.log(this.name); // obj\n\t\treturn () => {\n\t\t\tconsole.log(this.name); // obj\n\t\t};\n\t},\n};\nvar name = window;\nobj.foo1();\nobj.foo2()();\n```\n\n这道题非常经典，它证明了**箭头函数内的 this 是由外层作用域决定的**\n\n##### 6.1. 题目 5 解析：\n\n1）对于`obj.foo1()`函数的调用，它的外层作用域是 window，对象 obj 当然不属于作用域了(作用域只有全局作用域、函数作用域、块级作用域)，所以会打印出`window`  \n2）`obj.foo2()()`，首先会执行`obj.foo2()`，这不是个箭头函数，所以它里面的 this 是调用它的 obj 对象，因此第二个打印为`obj`，而返回的匿名函数是一个箭头函数，**它的 this 由外层作用域决定**，那也就是它的 this 会和 foo2 函数里的 this 一样，第三个打印也是`obj`\n\n## Reference\n\n- [JavaScript 基础心法——this](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F6 https://github.com/axuebin/articles/issues/6)\n- [面试官问：JS 的 this 指向](https://juejin.cn/post/6844903746984476686 https://juejin.cn/post/6844903746984476686)\n- [JavaScript 深入之从 ECMAScript 规范解读 this](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fmqyqingfeng%2FBlog%2Fissues%2F7 https://github.com/mqyqingfeng/Blog/issues/7)\n- [前端基础进阶（七）：全方位解读 this](https://link.juejin.cn?target=https%3A%2F%2Fwww.jianshu.com%2Fp%2Fd647aa6d1ae6 https://www.jianshu.com/p/d647aa6d1ae6)\n- [再来 40 道 this 面试题酸爽继续(1.2w 字用手整理)](https://juejin.cn/post/6844904083707396109 https://juejin.cn/post/6844904083707396109)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"this-in-js",text:"this in JS#"},{depth:2,slug:"对-this-的理解-绑定方式",text:"对 this 的理解 (绑定方式)#"},{depth:4,slug:"1-全局上下文",text:"1. 全局上下文#"},{depth:4,slug:"2-函数调用-默认绑定",text:"2. 函数调用 (默认绑定)#"},{depth:4,slug:"3-对象方法调用-隐式绑定",text:"3. 对象方法调用 (隐式绑定)#"},{depth:4,slug:"4-构造函数调用",text:"4. 构造函数调用#"},{depth:4,slug:"5-显式绑定",text:"5. 显式绑定#"},{depth:4,slug:"6-箭头函数",text:"6. 箭头函数#"},{depth:4,slug:"2-this-题目-1",text:"2. this 题目 1#"},{depth:4,slug:"3-this-题目-2",text:"3. this 题目 2#"},{depth:4,slug:"4-this-题目-3",text:"4. this 题目 3#"},{depth:4,slug:"5-this-题目-4",text:"5. this 题目 4#"},{depth:4,slug:"6-this-题目-5",text:"6. this 题目 5#"},{depth:5,slug:"61-题目-5-解析",text:"6.1. 题目 5 解析：#"},{depth:2,slug:"reference",text:"Reference#"}]}const Content=createComponent(((s,n,a)=>{const{layout:o,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};