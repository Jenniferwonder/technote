import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="js-internal-feature">JS Internal Feature<a class="anchor" href="#js-internal-feature"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="what-is-javascript">What is JavaScript?<a class="anchor" href="#what-is-javascript"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>[How JavaScript works](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a> <a href="https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5">https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5</a>)</li>\n<li>A <strong>single-threaded</strong> non-blocking asynchronous concurrent language.</li>\n<li>JS 是一个单线程、异步、并发、非阻塞 I/O 模型，拥有：\n<ul>\n<li><strong>a call stack</strong></li>\n<li>event loop 事件循环机制 > <a href="event-loop-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF">Event Loop-事件循环</a></li>\n<li>a callback queue</li>\n<li>and other APIs…</li>\n</ul>\n</li>\n<li>所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\n<ul>\n<li>同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。</li>\n<li>异步任务指的是，不进入主线程、而进入”任务队列”（task queue）的任务，只有”任务队列”通知主线程， 某个异步任务可以执行了，该任务才会进入主线程执行。</li>\n</ul>\n</li>\n</ul>\n<h3 id="v8">V8<a class="anchor" href="#v8"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>A JS runtime</li>\n<li>Have a callstack and a heap</li>\n<li>The V8 can do one thing at a time, but not the browser which can access other APIs.</li>\n</ul>\n<h4 id="对-v8-垃圾回收的理解">对 V8 垃圾回收的理解？<a class="anchor" href="#对-v8-垃圾回收的理解"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>V8 引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。</p>\n<ol>\n<li>分代收集：V8 将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用 Scavenge 算法进行垃圾回收，通常采用 Cheney 算法，将内存分为两个半区（From Space 和 To Space），每次垃圾回收时，会将存活的对象复制到 To Space 中，并清空 From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。</li>\n<li>增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8 采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript 程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。<br>\nV8 垃圾回收是对 JavaScript 垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。</li>\n</ol>\n<h4 id="如何优化和减少垃圾回收的影响从而提高应用性能">如何优化和减少垃圾回收的影响，从而提高应用性能？<a class="anchor" href="#如何优化和减少垃圾回收的影响从而提高应用性能"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：</p>\n<ol>\n<li><strong>避免全局变量</strong>：全局变量不会被垃圾回收，除非它们被设置为 <code>null</code>。只有在确实需要时才应该使用它们。</li>\n<li><strong>使用对象池</strong>：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。</li>\n<li><strong>小心闭包</strong>：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。</li>\n<li><strong>手动释放大对象</strong>：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 <code>null</code>，从而提前提示垃圾回收器。</li>\n<li><strong>避免循环引用</strong>：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。</li>\n<li><strong>使用弱引用</strong>：在合适的场景下，使用 <code>WeakMap</code> 或 <code>WeakSet</code> 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。</li>\n<li><strong>优化事件监听器</strong>：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。</li>\n<li><strong>减少内存分配</strong>：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。</li>\n<li><strong>使用浏览器开发者工具</strong>：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。</li>\n<li><strong>考虑使用 WebAssembly</strong>：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。</li>\n</ol>\n<h4 id="解释下-javascript-栈内存和堆内存">解释下 JavaScript 栈内存和堆内存？<a class="anchor" href="#解释下-javascript-栈内存和堆内存"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>在 JavaScript 中，栈内存（Stack Memory）和堆内存（Heap Memory）扮演着不同的角色，它们分别负责存储不同类型的数据。以下是它们在 JavaScript 中的简要说明：</p>\n<ol>\n<li>栈内存（Stack Memory）：\n<ul>\n<li>栈内存主要用于存储基本类型（原始类型）的值，如 <code>number</code>、<code>string</code>、<code>boolean</code>、<code>null</code> 和 <code>undefined</code>。这些类型的值通常<strong>较小且固定大小</strong>。</li>\n<li>栈内存还负责存储函数调用的执行上下文、局部变量和临时数据。</li>\n<li>栈内存遵循后进先出（LIFO）的原则进行分配和释放空间。当函数被调用时，函数的执行上下文、局部变量和相关信息会被压入栈中；当函数返回时，这些数据会从栈中弹出。</li>\n<li>栈内存的分配和回收速度较快，因为内存管理由 JavaScript 引擎自动完成。</li>\n<li>由于栈内存有限，如果递归调用过深或者分配大量的局部变量，可能导致栈溢出。</li>\n</ul>\n</li>\n<li>堆内存（Heap Memory）：\n<ul>\n<li>堆内存主要用于存储引用类型的值，如对象（<code>object</code>）、数组（<code>array</code>）和函数（<code>function</code>）。这些类型的值通常<strong>较大，大小不固定</strong>。</li>\n<li>JavaScript 引擎使用垃圾回收机制自动管理堆内存中的对象。当对象不再被引用时，它们会被标记为垃圾，并在下一次垃圾回收时释放内存。</li>\n<li>与栈内存相比，堆内存分配和回收速度较慢，因为需要管理更复杂的数据结构和垃圾回收机制。</li>\n<li>堆内存可以动态分配，因此可以存储更多数据。</li>\n<li>如果没有正确处理引用关系，可能导致内存泄漏。<br>\n总结一下，在 JavaScript 中，栈内存用于存储基本类型的值、函数调用的执行上下文和局部变量，堆内存用于存储引用类型的值。理解栈内存和堆内存的差异有助于编写高效且内存友好的 JavaScript 程序。</li>\n</ul>\n</li>\n</ol>',frontmatter={title:"JS Internal Feature",topic:["Basics"],type:"D",tags:["JavaScript"],category:"Programming",Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,aliases:["JS Internal Feature"],draft:!1,DateStarted:"2024-04-25T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z","linter-yaml-title-alias":"JS Internal Feature",minutes:8,words:1591},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/js-internal/js-internal-feature.md",url=void 0;function rawContent(){return'\n# JS Internal Feature\n\n### What is JavaScript?\n\n- [How JavaScript works](https://link.juejin.cn/?target=https%3A%2F%2Fblog.sessionstack.com%2Fhow-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5 https://blog.sessionstack.com/how-javascript-works-event-loop-and-the-rise-of-async-programming-5-ways-to-better-coding-with-2f077c4438b5)\n- A **single-threaded** non-blocking asynchronous concurrent language.\n- JS 是一个单线程、异步、并发、非阻塞 I/O 模型，拥有：\n  - **a call stack**\n  - event loop 事件循环机制 > [Event Loop-事件循环](event-loop-事件循环)\n  - a callback queue\n  - and other APIs...\n- 所有任务可以分成两种，一种是同步任务（synchronous），另一种是异步任务（asynchronous）。\n  - 同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务。\n  - 异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程， 某个异步任务可以执行了，该任务才会进入主线程执行。\n\n### V8\n\n- A JS runtime\n- Have a callstack and a heap\n- The V8 can do one thing at a time, but not the browser which can access other APIs.\n\n#### 对 V8 垃圾回收的理解？\n\nV8 引擎主要采用了两种算法来处理垃圾回收：分代收集（Generational Collection）和增量标记（Incremental Marking）。\n\n1. 分代收集：V8 将内存分为两个代：新生代（Young Generation）和老生代（Old Generation）。新生代中的对象存活时间较短，而老生代中的对象存活时间较长。新生代使用 Scavenge 算法进行垃圾回收，通常采用 Cheney 算法，将内存分为两个半区（From Space 和 To Space），每次垃圾回收时，会将存活的对象复制到 To Space 中，并清空 From Space。当一个对象在新生代中经历了多次垃圾回收仍然存活时，会将其移动到老生代。\n2. 增量标记：老生代采用标记-清除（Mark-Sweep）算法进行垃圾回收。这种算法首先会标记所有可达的对象，然后清除所有未被标记的对象。为了避免在标记过程中产生长时间的停顿（Stop-The-World），V8 采用了增量标记策略。这种策略将标记过程分为多个阶段，在每个阶段之间，JavaScript 程序可以继续执行。这样可以降低垃圾回收对程序性能的影响。  \n   V8 垃圾回收是对 JavaScript 垃圾回收策略的具体实现。它采用分代收集和增量标记两种算法，有效降低了垃圾回收对程序性能的影响。\n\n#### 如何优化和减少垃圾回收的影响，从而提高应用性能？\n\n以下是一些建议和技巧来帮助优化和减少垃圾回收的影响：\n\n1. **避免全局变量**：全局变量不会被垃圾回收，除非它们被设置为 `null`。只有在确实需要时才应该使用它们。\n2. **使用对象池**：对于频繁创建和销毁的对象（如在游戏或高性能应用中的实体），使用对象池可以重用对象而不是每次都创建新的对象。这可以避免频繁的垃圾回收。\n3. **小心闭包**：闭包可能会导致意外的引用，从而阻止对象被垃圾回收。确保你只在需要时使用闭包，并在不再需要它们时断开引用。\n4. **手动释放大对象**：对于大的数据结构或数组，如果你知道它们不再需要，可以手动将它们设置为 `null`，从而提前提示垃圾回收器。\n5. **避免循环引用**：确保对象之间没有循环引用，因为这可能导致它们无法被垃圾回收。\n6. **使用弱引用**：在合适的场景下，使用 `WeakMap` 或 `WeakSet` 可以让你存储对对象的引用，而不会阻止这些对象被垃圾回收。\n7. **优化事件监听器**：确保及时删除不再需要的事件监听器。未删除的事件监听器可能会导致内存泄漏。\n8. **减少内存分配**：减少动态创建对象、数组和闭包的频率可以帮助减少需要回收的垃圾量。\n9. **使用浏览器开发者工具**：浏览器提供的开发者工具（如 Chrome DevTools）可以帮助你监测和诊断内存使用情况和潜在的泄漏。\n10. **考虑使用 WebAssembly**：对于需要高性能和低延迟的应用，使用 WebAssembly 可能会帮助减少 JavaScript 的垃圾回收的影响，因为 WebAssembly 有自己的内存管理模型。\n\n#### 解释下 JavaScript 栈内存和堆内存？\n\n在 JavaScript 中，栈内存（Stack Memory）和堆内存（Heap Memory）扮演着不同的角色，它们分别负责存储不同类型的数据。以下是它们在 JavaScript 中的简要说明：\n\n1. 栈内存（Stack Memory）：\n   - 栈内存主要用于存储基本类型（原始类型）的值，如 `number`、`string`、`boolean`、`null` 和 `undefined`。这些类型的值通常**较小且固定大小**。\n   - 栈内存还负责存储函数调用的执行上下文、局部变量和临时数据。\n   - 栈内存遵循后进先出（LIFO）的原则进行分配和释放空间。当函数被调用时，函数的执行上下文、局部变量和相关信息会被压入栈中；当函数返回时，这些数据会从栈中弹出。\n   - 栈内存的分配和回收速度较快，因为内存管理由 JavaScript 引擎自动完成。\n   - 由于栈内存有限，如果递归调用过深或者分配大量的局部变量，可能导致栈溢出。\n2. 堆内存（Heap Memory）：\n   - 堆内存主要用于存储引用类型的值，如对象（`object`）、数组（`array`）和函数（`function`）。这些类型的值通常**较大，大小不固定**。\n   - JavaScript 引擎使用垃圾回收机制自动管理堆内存中的对象。当对象不再被引用时，它们会被标记为垃圾，并在下一次垃圾回收时释放内存。\n   - 与栈内存相比，堆内存分配和回收速度较慢，因为需要管理更复杂的数据结构和垃圾回收机制。\n   - 堆内存可以动态分配，因此可以存储更多数据。\n   - 如果没有正确处理引用关系，可能导致内存泄漏。  \n     总结一下，在 JavaScript 中，栈内存用于存储基本类型的值、函数调用的执行上下文和局部变量，堆内存用于存储引用类型的值。理解栈内存和堆内存的差异有助于编写高效且内存友好的 JavaScript 程序。\n'}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"js-internal-feature",text:"JS Internal Feature#"},{depth:3,slug:"what-is-javascript",text:"What is JavaScript?#"},{depth:3,slug:"v8",text:"V8#"},{depth:4,slug:"对-v8-垃圾回收的理解",text:"对 V8 垃圾回收的理解？#"},{depth:4,slug:"如何优化和减少垃圾回收的影响从而提高应用性能",text:"如何优化和减少垃圾回收的影响，从而提高应用性能？#"},{depth:4,slug:"解释下-javascript-栈内存和堆内存",text:"解释下 JavaScript 栈内存和堆内存？#"}]}const Content=createComponent(((n,e,a)=>{const{layout:t,...o}=frontmatter;return o.file=file,o.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};