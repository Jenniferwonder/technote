import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="modules">Modules<a class="anchor" href="#modules"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<blockquote>\n<p><a href="https://juejin.cn/post/6844903959283367950">juejin.cn/post/6844903959283367950</a></p>\n</blockquote>\n<ul>\n<li>命令\n<ul>\n<li><strong>export</strong>：规定模块对外接口\n<ul>\n<li><strong>默认导出</strong>：<code>export default Person</code>(导入时可指定模块任意名称，无需知晓内部真实名称)</li>\n<li><strong>单独导出</strong>：<code>export const name = "Bruce"</code></li>\n<li><strong>按需导出</strong>：<code>export { age, name, sex }</code>(推荐)</li>\n<li><strong>改名导出</strong>：<code>export { name as newName }</code></li>\n</ul>\n</li>\n<li><strong>import</strong>：导入模块内部功能\n<ul>\n<li><strong>默认导入</strong>：<code>import Person from "person"</code></li>\n<li><strong>整体导入</strong>：<code>import * as Person from "person"</code></li>\n<li><strong>按需导入</strong>：<code>import { age, name, sex } from "person"</code></li>\n<li><strong>改名导入</strong>：<code>import { name as newName } from "person"</code></li>\n<li><strong>自执导入</strong>：<code>import "person"</code></li>\n<li><strong>复合导入</strong>：<code>import Person, { name } from "person"</code></li>\n</ul>\n</li>\n<li><strong>复合模式</strong>：<code>export命令</code>和<code>import命令</code>结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量\n<ul>\n<li><strong>默认导入导出</strong>：<code>export { default } from "person"</code></li>\n<li><strong>整体导入导出</strong>：<code>export * from "person"</code></li>\n<li><strong>按需导入导出</strong>：<code>export { age, name, sex } from "person"</code></li>\n<li><strong>改名导入导出</strong>：<code>export { name as newName } from "person"</code></li>\n<li><strong>具名改默认导入导出</strong>：<code>export { name as default } from "person"</code></li>\n<li><strong>默认改具名导入导出</strong>：<code>export { default as name } from "person"</code></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>继承：<code>默认导出</code>和<code>改名导出</code>结合使用可使模块具备继承性</li>\n<li>设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量</li>\n<li>严格模式：ES6 模块自动采用严格模式(不管模块头部是否添加<code>use strict</code>)</li>\n</ul>\n<h3 id="esm-和-commonjs-的区别">ESM 和 CommonJS 的区别<a class="anchor" href="#esm-和-commonjs-的区别"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>ESM（ECMAScript Modules）和 CommonJS 是 JavaScript 中两种不同的模块系统。它们都允许将代码拆分成可重用的模块，并在需要时导入这些模块。尽管它们都实现了相似的功能，但它们之间存在一些关键差异：</p>\n<ol>\n<li>\n<p>语法：ESM 和 CommonJS 使用不同的语法来导入和导出模块。</p>\n<ul>\n<li>ESM 使用 <code>import</code> 和 <code>export</code> 关键字</li>\n<li>CommonJS 使用 <code>require</code> 和 <code>module.exports</code>关键字</li>\n</ul>\n</li>\n<li>\n<p>运行时加载与静态加载：</p>\n<ul>\n<li>CommonJS 是<strong>运行时加载</strong>，这意味着模块在运行时解析和加载。因此，在运行时可以动态修改模块和依赖关系。</li>\n<li>ESM 是<strong>静态加载</strong>，这意味着模块在编译时解析和加载。这允许更好的优化，如代码消除和更快的加载速度，但不允许在运行时动态修改模块。</li>\n</ul>\n</li>\n<li>\n<p>作用域：ESM 和 CommonJS 在处理变量作用域方面有所不同。</p>\n<ul>\n<li>ESM 使用<strong>模块作用域</strong>，每个模块具有自己的顶级作用域。在模块内声明的变量不会污染全局作用域。</li>\n<li>CommonJS 使用<strong>文件作用域</strong>，但与 ESM 不同，CommonJS 模块可以通过 <code>global</code> 对象访问全局作用域。</li>\n</ul>\n</li>\n<li>\n<p>循环依赖：ESM 和 CommonJS 处理循环依赖的方式不同。</p>\n<ul>\n<li>ESM 可以更好地处理循环依赖，因为模块是静态加载的。在循环依赖中，导入的值可能是不完整的，但不会导致错误。</li>\n<li>CommonJS 在处理循环依赖时可能会遇到问题，因为模块是运行时加载的。这可能导致在循环依赖中的模块中获得一个不完整的对象。</li>\n</ul>\n</li>\n<li>\n<p>兼容性和使用场景：</p>\n<ul>\n<li>CommonJS 主要用于 Node.js 环境，因为它是 Node.js 的原生模块系统。虽然现代 Node.js 版本也支持 ESM，但很多旧的 Node.js 代码仍使用 CommonJS。然而，许多新的 Node.js 项目逐渐采用 ESM。</li>\n<li>ESM 通常用于现代 Web 开发，因为大多数现代浏览器原生支持 ESM。在使用构建工具（如 Webpack、Rollup 或 Parcel）时，ESM 也提供了更好的优化和打包能力。</li>\n</ul>\n</li>\n<li>\n<p>实时绑定与值拷贝：</p>\n<ul>\n<li>ESM 使用<strong>实时绑定</strong>，当导入的值发生更改时，导入模块的值也会跟着更改。这意味着导入的值始终保持最新。</li>\n<li>CommonJS 使用<strong>值拷贝</strong>，当模块被导入时，值被复制到导入模块。这意味着在导入模块中，值的更改不会反映到原始模块，导入的值在导入时是固定的。</li>\n</ul>\n</li>\n<li>\n<p>导出值：</p>\n<ul>\n<li>ESM 导出值是<strong>映射关系</strong>，<strong>可读，不可修改</strong>，但可通过导出的函数修改导出的值。</li>\n<li>CoomonJS 导出<strong>值的拷贝</strong>，<strong>可以修改导出的值</strong>。</li>\n</ul>\n</li>\n<li>\n<p>export 使用：</p>\n<ul>\n<li>ESM export 和 export default 支持一起使用。</li>\n<li>CoomonJS module.exports 和 exports 不支持一起使用，会被覆盖。</li>\n</ul>\n</li>\n</ol>\n<p>总结一下，ESM 和 CommonJS 的主要区别在于它们的语法、加载机制、作用域、循环依赖处理、兼容性和使用场景以及实时绑定与值拷贝。尽管它们在某些方面有所不同，它们都是为了解决 JavaScript 模块化编程的问题。</p>\n<ul>\n<li>\n<p>UNDERSTANDING THE MODULE PATTERN</p>\n</li>\n<li>\n<p>Module Identifiers</p>\n</li>\n<li>\n<p>Module Dependencies</p>\n</li>\n<li>\n<p>Module Loading</p>\n</li>\n<li>\n<p>Entry Points</p>\n</li>\n<li>\n<p>Asynchronous Dependencies</p>\n</li>\n<li>\n<p>Programmatic Dependencies</p>\n</li>\n<li>\n<p>Static Analysis</p>\n</li>\n<li>\n<p>Circular Dependencies</p>\n</li>\n<li>\n<p>IMPROVISING MODULE SYSTEMS</p>\n</li>\n<li>\n<p>WORKING WITH PRE-ES6 MODULE LOADERS</p>\n</li>\n<li>\n<p>CommonJS</p>\n</li>\n<li>\n<p>Asynchronous Module Definition “</p>\n</li>\n<li>\n<p>Universal Module Definition “</p>\n</li>\n<li>\n<p>Module Loader Deprecation “</p>\n</li>\n<li>\n<p>WORKING WITH ES6 MODULES “</p>\n</li>\n<li>\n<p>Module Tagging and Definition “</p>\n</li>\n<li>\n<p>Module Loading “</p>\n</li>\n<li>\n<p>Module Behavior “</p>\n</li>\n<li>\n<p>Module Exports “</p>\n</li>\n<li>\n<p>Module Imports “</p>\n</li>\n<li>\n<p>Module Passthrough Exports “</p>\n</li>\n<li>\n<p>Worker Modules “</p>\n</li>\n<li>\n<p>Backwards Compatibility ”</p>\n</li>\n</ul>',frontmatter={status:null,type:"D",tags:["JavaScript"],category:"Programming",reviewed:1,difficulty:null,comment:null,draft:!0,DateStarted:"2023-07-14T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",aliases:["Modules"],Datereviewed:"2024-04-25T00:00:00.000Z",topic:["Practice"],title:"Modules","linter-yaml-title-alias":"Modules",minutes:6,words:1226},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/practice/modules.md",url=void 0;function rawContent(){return'\n# Modules\n\n> [juejin.cn/post/6844903959283367950](https://juejin.cn/post/6844903959283367950)\n\n- 命令\n  - **export**：规定模块对外接口\n    - **默认导出**：`export default Person`(导入时可指定模块任意名称，无需知晓内部真实名称)\n    - **单独导出**：`export const name = "Bruce"`\n    - **按需导出**：`export { age, name, sex }`(推荐)\n    - **改名导出**：`export { name as newName }`\n  - **import**：导入模块内部功能\n    - **默认导入**：`import Person from "person"`\n    - **整体导入**：`import * as Person from "person"`\n    - **按需导入**：`import { age, name, sex } from "person"`\n    - **改名导入**：`import { name as newName } from "person"`\n    - **自执导入**：`import "person"`\n    - **复合导入**：`import Person, { name } from "person"`\n  - **复合模式**：`export命令`和`import命令`结合在一起写成一行，变量实质没有被导入当前模块，相当于对外转发接口，导致当前模块无法直接使用其导入变量\n    - **默认导入导出**：`export { default } from "person"`\n    - **整体导入导出**：`export * from "person"`\n    - **按需导入导出**：`export { age, name, sex } from "person"`\n    - **改名导入导出**：`export { name as newName } from "person"`\n    - **具名改默认导入导出**：`export { name as default } from "person"`\n    - **默认改具名导入导出**：`export { default as name } from "person"`\n- 继承：`默认导出`和`改名导出`结合使用可使模块具备继承性\n- 设计思想：尽量地静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量\n- 严格模式：ES6 模块自动采用严格模式(不管模块头部是否添加`use strict`)\n\n### ESM 和 CommonJS 的区别\n\nESM（ECMAScript Modules）和 CommonJS 是 JavaScript 中两种不同的模块系统。它们都允许将代码拆分成可重用的模块，并在需要时导入这些模块。尽管它们都实现了相似的功能，但它们之间存在一些关键差异：\n\n1. 语法：ESM 和 CommonJS 使用不同的语法来导入和导出模块。\n\n   - ESM 使用 `import` 和 `export` 关键字\n   - CommonJS 使用 `require` 和 `module.exports`关键字\n\n2. 运行时加载与静态加载：\n\n   - CommonJS 是**运行时加载**，这意味着模块在运行时解析和加载。因此，在运行时可以动态修改模块和依赖关系。\n   - ESM 是**静态加载**，这意味着模块在编译时解析和加载。这允许更好的优化，如代码消除和更快的加载速度，但不允许在运行时动态修改模块。\n\n3. 作用域：ESM 和 CommonJS 在处理变量作用域方面有所不同。\n\n   - ESM 使用**模块作用域**，每个模块具有自己的顶级作用域。在模块内声明的变量不会污染全局作用域。\n   - CommonJS 使用**文件作用域**，但与 ESM 不同，CommonJS 模块可以通过 `global` 对象访问全局作用域。\n\n4. 循环依赖：ESM 和 CommonJS 处理循环依赖的方式不同。\n\n   - ESM 可以更好地处理循环依赖，因为模块是静态加载的。在循环依赖中，导入的值可能是不完整的，但不会导致错误。\n   - CommonJS 在处理循环依赖时可能会遇到问题，因为模块是运行时加载的。这可能导致在循环依赖中的模块中获得一个不完整的对象。\n\n5. 兼容性和使用场景：\n\n   - CommonJS 主要用于 Node.js 环境，因为它是 Node.js 的原生模块系统。虽然现代 Node.js 版本也支持 ESM，但很多旧的 Node.js 代码仍使用 CommonJS。然而，许多新的 Node.js 项目逐渐采用 ESM。\n   - ESM 通常用于现代 Web 开发，因为大多数现代浏览器原生支持 ESM。在使用构建工具（如 Webpack、Rollup 或 Parcel）时，ESM 也提供了更好的优化和打包能力。\n\n6. 实时绑定与值拷贝：\n\n   - ESM 使用**实时绑定**，当导入的值发生更改时，导入模块的值也会跟着更改。这意味着导入的值始终保持最新。\n   - CommonJS 使用**值拷贝**，当模块被导入时，值被复制到导入模块。这意味着在导入模块中，值的更改不会反映到原始模块，导入的值在导入时是固定的。\n\n7. 导出值：\n\n   - ESM 导出值是**映射关系**，**可读，不可修改**，但可通过导出的函数修改导出的值。\n   - CoomonJS 导出**值的拷贝**，**可以修改导出的值**。\n\n8. export 使用：\n\n   - ESM export 和 export default 支持一起使用。\n   - CoomonJS module.exports 和 exports 不支持一起使用，会被覆盖。\n\n总结一下，ESM 和 CommonJS 的主要区别在于它们的语法、加载机制、作用域、循环依赖处理、兼容性和使用场景以及实时绑定与值拷贝。尽管它们在某些方面有所不同，它们都是为了解决 JavaScript 模块化编程的问题。\n\n- UNDERSTANDING THE MODULE PATTERN\n\n- Module Identifiers\n\n- Module Dependencies\n\n- Module Loading\n\n- Entry Points\n\n- Asynchronous Dependencies\n\n- Programmatic Dependencies\n\n- Static Analysis\n\n- Circular Dependencies\n\n- IMPROVISING MODULE SYSTEMS\n\n- WORKING WITH PRE-ES6 MODULE LOADERS\n\n- CommonJS\n\n- Asynchronous Module Definition "\n\n- Universal Module Definition "\n\n- Module Loader Deprecation "\n\n- WORKING WITH ES6 MODULES "\n\n- Module Tagging and Definition "\n\n- Module Loading "\n\n- Module Behavior "\n\n- Module Exports "\n\n- Module Imports "\n\n- Module Passthrough Exports "\n\n- Worker Modules "\n\n- Backwards Compatibility "\n'}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"modules",text:"Modules#"},{depth:3,slug:"esm-和-commonjs-的区别",text:"ESM 和 CommonJS 的区别#"}]}const Content=createComponent(((n,o,e)=>{const{layout:l,...r}=frontmatter;return r.file=file,r.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};