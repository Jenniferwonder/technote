import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="garbage-collection-垃圾回收">Garbage Collection-垃圾回收<a class="anchor" href="#garbage-collection-垃圾回收"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="garbage-collected-language">garbage-collected language<a class="anchor" href="#garbage-collected-language"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>automatically allocating what is needed and reclaiming memory that is no longer being used</li>\n<li>Mark-and-Sweep 标记清理</li>\n<li>除所有在上下文中的变量，以及被在上下文中的变量引用的变量外的变量将被标记清理</li>\n<li>Reference Counting 引用计数</li>\n<li>对每个值都记录它被引用的次数，引用为 0 则被清理</li>\n</ul>\n<h2 id="performance">Performance<a class="anchor" href="#performance"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。</li>\n<li>minimizing the number of garbage collection operations the browser performs-合理使用分配的内存，并避免多余的垃圾回收.</li>\n<li>浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行</li>\n</ul>\n<h2 id="managing-memory">Managing Memory<a class="anchor" href="#managing-memory"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li>memory limits affect 内存限制会影响</li>\n<li>variable allocation 变量分配</li>\n<li>call stack 调用栈</li>\n<li>number of statements that can be executed in a single thread 同在一个线程执行的语句数量</li>\n<li>优化内存占用的最佳手段\n<ul>\n<li>dereferencing the value 解除引用</li>\n<li>When data is no longer necessary, it’s best to set the value to null, freeing up the reference</li>\n<li>applies mostly to global values and properties of global objects</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-18-x65-y456.png" alt=""></li>\n<li>Use const and let Declarations</li>\n<li>signal to the garbage collector that an allocated variable is eligible for cleanup far sooner</li>\n<li>Hidden Classes and the delete Operation-隐藏类与删除操作</li>\n<li>V8 will associate hidden classes for every object created to keep track of the shape of its properties</li>\n<li>Objects that are able to share the same hidden class will have better performance</li>\n<li>在构造函数中一次性声明所有属性\n<ul>\n<li>避免动态添加属性\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-19-x89-y398.png" alt=""></li>\n</ul>\n</li>\n<li>避免动态删除属性\n<ul>\n<li>Best practices dictate that unwanted properties should be set to null.</li>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-19-x91-y95.png" alt=""></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Memory Leaks-内存泄漏 3 种情形避免</li>\n<li>the variable is not prefixed with a declaration keyword</li>\n<li>没有用关键字声明变量，意外声明全局变量</li>\n<li>Interval timers</li>\n<li>定时器的回调通过闭包引用了外部变量</li>\n<li>JavaScript closures</li>\n<li>函数内的闭包引用了外部变量</li>\n<li>Static Allocation and Object Pools 静态分配与对象池</li>\n<li>object pool-对象池</li>\n<li>管理一组可回收的对象。\n<ul>\n<li>应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。</li>\n</ul>\n</li>\n<li>对象池必须使用某种结构维护所有对象，数组是比较好的选择\n<ul>\n<li>在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作</li>\n</ul>\n</li>\n<li>静态分配是优化的一种极端形式，大多数情况下，这都属于过早优化，因此不用考虑。</li>\n</ul>\n</li>\n</ul>',frontmatter={aliases:["Garbage Collection-垃圾回收"],title:"Garbage Collection-垃圾回收",tags:["JavaScript"],topic:["Basics"],type:"D",Datereviewed:null,reviewed:null,difficulty:null,comment:null,DateStarted:"2023-07-28T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:["Snooze"],category:"Programming",draft:!0,"linter-yaml-title-alias":"Garbage Collection-垃圾回收",minutes:4,words:718},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/js-internal/garbage-collection-垃圾回收.md",url=void 0;function rawContent(){return"\n# Garbage Collection-垃圾回收\n\n## garbage-collected language\n\n- automatically allocating what is needed and reclaiming memory that is no longer being used\n- Mark-and-Sweep 标记清理\n- 除所有在上下文中的变量，以及被在上下文中的变量引用的变量外的变量将被标记清理\n- Reference Counting 引用计数\n- 对每个值都记录它被引用的次数，引用为 0 则被清理\n\n## Performance\n\n- 垃圾回收程序会周期性运行，如果内存中分配了很多变量，则可能造成性能损失，因此垃圾回收的时间调度很重要。\n- minimizing the number of garbage collection operations the browser performs-合理使用分配的内存，并避免多余的垃圾回收.\n- 浏览器决定何时运行垃圾回收程序的一个标准就是对象更替的速度。如果有很多对象被初始化，然后一下子又都超出了作用域，那么浏览器就会采用更激进的方式调度垃圾回收程序运行\n\n## Managing Memory\n\n- memory limits affect 内存限制会影响\n- variable allocation 变量分配\n- call stack 调用栈\n- number of statements that can be executed in a single thread 同在一个线程执行的语句数量\n- 优化内存占用的最佳手段\n  - dereferencing the value 解除引用\n  - When data is no longer necessary, it’s best to set the value to null, freeing up the reference\n  - applies mostly to global values and properties of global objects\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-18-x65-y456.png)\n  - Use const and let Declarations\n  - signal to the garbage collector that an allocated variable is eligible for cleanup far sooner\n  - Hidden Classes and the delete Operation-隐藏类与删除操作\n  - V8 will associate hidden classes for every object created to keep track of the shape of its properties\n  - Objects that are able to share the same hidden class will have better performance\n  - 在构造函数中一次性声明所有属性\n    - 避免动态添加属性\n      - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-19-x89-y398.png)\n    - 避免动态删除属性\n      - Best practices dictate that unwanted properties should be set to null.\n      - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/C04VariablesScopeMemory-19-x91-y95.png)\n  - Memory Leaks-内存泄漏 3 种情形避免\n  - the variable is not prefixed with a declaration keyword\n  - 没有用关键字声明变量，意外声明全局变量\n  - Interval timers\n  - 定时器的回调通过闭包引用了外部变量\n  - JavaScript closures\n  - 函数内的闭包引用了外部变量\n  - Static Allocation and Object Pools 静态分配与对象池\n  - object pool-对象池\n  - 管理一组可回收的对象。\n    - 应用程序可以向这个对象池请求一个对象、设置其属性、使用它，然后在操作完成后再把它还给对象池。由于没发生对象初始化，垃圾回收探测就不会发现有对象更替，因此垃圾回收程序就不会那么频繁地运行。\n  - 对象池必须使用某种结构维护所有对象，数组是比较好的选择\n    - 在初始化时就创建一个大小够用的数组，从而避免上述先删除再创建的操作\n  - 静态分配是优化的一种极端形式，大多数情况下，这都属于过早优化，因此不用考虑。\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"garbage-collection-垃圾回收",text:"Garbage Collection-垃圾回收#"},{depth:2,slug:"garbage-collected-language",text:"garbage-collected language#"},{depth:2,slug:"performance",text:"Performance#"},{depth:2,slug:"managing-memory",text:"Managing Memory#"}]}const Content=createComponent(((e,n,a)=>{const{layout:l,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};