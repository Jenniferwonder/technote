import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<hr>\n<p>Basic</p>\n<h3 id="call-apply-bind-三者功能与异同">call apply bind 三者功能与异同<a class="anchor" href="#call-apply-bind-三者功能与异同"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>Back:</p>\n<h4 id="功能">功能<a class="anchor" href="#功能"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>将任意对象设置为任意函数的作用域，这样对象可以不用关心方法\n<ul>\n<li>都可以显式绑定函数的 this 指向</li>\n</ul>\n</li>\n</ul>\n<h4 id="异同">异同<a class="anchor" href="#异同"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>三者第一个参数都是 <code>this</code> 要指向的对象，若该参数为 <code>undefined</code> 或 <code>null</code>，<code>this</code> 则默认指向全局 window</li>\n<li>传参不同：\n<ul>\n<li><code>apply</code> 是数组\n<ul>\n<li>可以是 Array 的实例</li>\n<li>也可以是 arguments 对象</li>\n<li><code>return sum.apply(this, arguments); // 传入 arguments 对象</code></li>\n</ul>\n</li>\n<li><code>call</code> 是参数列表\n<ul>\n<li><code>return sum.call(this, num1, num2);</code></li>\n</ul>\n</li>\n<li><code>bind</code> (ES5) 可以分为多次传入，实现参数的合并\n<ul>\n<li><code>let objectSayColor = sayColor.bind(o);</code>\n<ul>\n<li><code>objectSayColor();  // blue</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><code>call</code>、<code>apply</code> 是立即执行，<code>bind</code> 是返回绑定 <code>this</code> 之后的函数，如果这个新的函数作为构造函数被调用，那么 <code>this</code> 不再指向传入给 <code>bind</code> 的第一个参数，而是指向新生成的对象<br>\n📌: JS::JS-Function<br>\n🏷️: JS-Function</li>\n</ul>\n\x3c!--ID: 1708065412000--\x3e\n<hr>\n<h3 id="手写-call-apply-bind">手写 call apply bind<a class="anchor" href="#手写-call-apply-bind"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#6A737D">// 手写call</span></span>\n<span class="line"><span style="color:#79B8FF">Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">Call</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">context</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">...</span><span style="color:#FFAB70">args</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t// context为undefined或null时，则this默认指向全局window</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">context </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> context </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tcontext </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> window;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#6A737D">\t// 利用Symbol创建一个唯一的key值，防止新增加的属性与obj中的属性名重复</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> fn </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Symbol</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#6A737D">\t// this指向调用call的函数</span></span>\n<span class="line"><span style="color:#E1E4E8">\tcontext[fn] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#6A737D">\t// 隐式绑定this，如执行obj.foo(), foo内的this指向obj</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> res </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> context[fn](</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args);</span></span>\n<span class="line"><span style="color:#6A737D">\t// 执行完以后，删除新增加的属性</span></span>\n<span class="line"><span style="color:#F97583">\tdelete</span><span style="color:#E1E4E8"> context[fn];</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> res;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// apply与call相似，只有第二个参数是一个数组，</span></span>\n<span class="line"><span style="color:#79B8FF">Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">Apply</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">context</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">args</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">context </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> context </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tcontext </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> window;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> fn </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Symbol</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">\tcontext[fn] </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> res </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> context[fn](</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args);</span></span>\n<span class="line"><span style="color:#F97583">\tdelete</span><span style="color:#E1E4E8"> context[fn];</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> res;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// bind要考虑返回的函数，作为构造函数被调用的情况</span></span>\n<span class="line"><span style="color:#79B8FF">Function</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">Bind</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">context</span><span style="color:#E1E4E8">, </span><span style="color:#F97583">...</span><span style="color:#FFAB70">args</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">!</span><span style="color:#E1E4E8">context </span><span style="color:#F97583">||</span><span style="color:#E1E4E8"> context </span><span style="color:#F97583">===</span><span style="color:#79B8FF"> null</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tcontext </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> window;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> fn </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> f </span><span style="color:#F97583">=</span><span style="color:#B392F0"> Symbol</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#B392F0"> result</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">...</span><span style="color:#FFAB70">args1</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\tif</span><span style="color:#E1E4E8"> (</span><span style="color:#79B8FF">this</span><span style="color:#F97583"> instanceof</span><span style="color:#B392F0"> fn</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// result如果作为构造函数被调用，this指向的是new出来的对象</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// this instanceof fn，判断new出来的对象是否为fn的实例</span></span>\n<span class="line"><span style="color:#79B8FF">\t\t\tthis</span><span style="color:#E1E4E8">[f] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fn;</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tlet</span><span style="color:#E1E4E8"> res </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">[f](</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args1);</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tdelete</span><span style="color:#79B8FF"> this</span><span style="color:#E1E4E8">[f];</span></span>\n<span class="line"><span style="color:#F97583">\t\t\treturn</span><span style="color:#E1E4E8"> res;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// bind返回的函数作为普通函数被调用时</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tcontext[f] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> fn;</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tlet</span><span style="color:#E1E4E8"> res </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> context[f](</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args, </span><span style="color:#F97583">...</span><span style="color:#E1E4E8">args1);</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tdelete</span><span style="color:#E1E4E8"> context[f];</span></span>\n<span class="line"><span style="color:#F97583">\t\t\treturn</span><span style="color:#E1E4E8"> res;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t};</span></span>\n<span class="line"><span style="color:#6A737D">\t// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法</span></span>\n<span class="line"><span style="color:#6A737D">\t// 实现继承的方式: 使用Object.create</span></span>\n<span class="line"><span style="color:#79B8FF">\tresult</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> Object.</span><span style="color:#B392F0">create</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">fn</span><span style="color:#E1E4E8">.</span><span style="color:#79B8FF">prototype</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> result;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>\n<h3 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><a href="https://juejin.cn/post/7128233572380442660">面试官为啥总是让我们手撕 call、apply、bind? - 掘金</a></li>\n<li>[JavaScript 深入之 call 和 apply 的模拟实现](<a href="https://juejin.cn/post/6844903476477034510">https://juejin.cn/post/6844903476477034510</a> <a href="https://juejin.cn/post/6844903476477034510">https://juejin.cn/post/6844903476477034510</a>)</li>\n<li>[JavaScript 基础心法—— call apply bind](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F7">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F7</a> <a href="https://github.com/axuebin/articles/issues/7">https://github.com/axuebin/articles/issues/7</a>)</li>\n<li>[面试官问：能否模拟实现 JS 的 call 和 apply 方法](<a href="https://juejin.cn/post/6844903728147857415">https://juejin.cn/post/6844903728147857415</a> <a href="https://juejin.cn/post/6844903728147857415">https://juejin.cn/post/6844903728147857415</a>)</li>\n<li>[回味 JS 基础:call apply 与 bind](<a href="https://juejin.cn/post/6844903444348665870">https://juejin.cn/post/6844903444348665870</a> <a href="https://juejin.cn/post/6844903444348665870">https://juejin.cn/post/6844903444348665870</a>)</li>\n<li>[面试官问：能否模拟实现 JS 的 bind 方法](<a href="https://juejin.cn/post/6844903718089916429">https://juejin.cn/post/6844903718089916429</a> <a href="https://juejin.cn/post/6844903718089916429">https://juejin.cn/post/6844903718089916429</a>)</li>\n<li>[不用 call 和 apply 方法模拟实现 ES5 的 bind 方法](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjawil%2Fblog%2Fissues%2F16">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjawil%2Fblog%2Fissues%2F16</a> <a href="https://github.com/jawil/blog/issues/16">https://github.com/jawil/blog/issues/16</a>)</li>\n</ul>',frontmatter={title:"call-apply-bind",topic:["Scope","Objects","Function"],type:"D",tags:["JavaScript"],Datereviewed:"2024-02-16T00:00:00.000Z",reviewed:2,difficulty:null,comment:null,DateStarted:"2022-12-16T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:null,category:"Programming",draft:!0,minutes:3,words:688},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/function/call-apply-bind.md",url=void 0;function rawContent(){return"\n---\n\nBasic\n\n### call apply bind 三者功能与异同\n\nBack:\n\n#### 功能\n\n- 将任意对象设置为任意函数的作用域，这样对象可以不用关心方法\n  - 都可以显式绑定函数的 this 指向\n\n#### 异同\n\n- 三者第一个参数都是 `this` 要指向的对象，若该参数为 `undefined` 或 `null`，`this` 则默认指向全局 window\n- 传参不同：\n  - `apply` 是数组\n    - 可以是 Array 的实例\n    - 也可以是 arguments 对象\n    - `return sum.apply(this, arguments); // 传入 arguments 对象`\n  - `call` 是参数列表\n    - `return sum.call(this, num1, num2);`\n  - `bind` (ES5) 可以分为多次传入，实现参数的合并\n    - `let objectSayColor = sayColor.bind(o);`\n      - `objectSayColor();  // blue`\n- `call`、`apply` 是立即执行，`bind` 是返回绑定 `this` 之后的函数，如果这个新的函数作为构造函数被调用，那么 `this` 不再指向传入给 `bind` 的第一个参数，而是指向新生成的对象  \n📌: JS::JS-Function  \n🏷️: JS-Function\n\x3c!--ID: 1708065412000--\x3e\n\n---\n\n### 手写 call apply bind\n\n```js\n// 手写call\nFunction.prototype.Call = function (context, ...args) {\n\t// context为undefined或null时，则this默认指向全局window\n\tif (!context || context === null) {\n\t\tcontext = window;\n\t}\n\t// 利用Symbol创建一个唯一的key值，防止新增加的属性与obj中的属性名重复\n\tlet fn = Symbol();\n\t// this指向调用call的函数\n\tcontext[fn] = this;\n\t// 隐式绑定this，如执行obj.foo(), foo内的this指向obj\n\tlet res = context[fn](...args);\n\t// 执行完以后，删除新增加的属性\n\tdelete context[fn];\n\treturn res;\n};\n\n// apply与call相似，只有第二个参数是一个数组，\nFunction.prototype.Apply = function (context, args) {\n\tif (!context || context === null) {\n\t\tcontext = window;\n\t}\n\tlet fn = Symbol();\n\tcontext[fn] = this;\n\tlet res = context[fn](...args);\n\tdelete context[fn];\n\treturn res;\n};\n\n// bind要考虑返回的函数，作为构造函数被调用的情况\nFunction.prototype.Bind = function (context, ...args) {\n\tif (!context || context === null) {\n\t\tcontext = window;\n\t}\n\tlet fn = this;\n\tlet f = Symbol();\n\tconst result = function (...args1) {\n\t\tif (this instanceof fn) {\n\t\t\t// result如果作为构造函数被调用，this指向的是new出来的对象\n\t\t\t// this instanceof fn，判断new出来的对象是否为fn的实例\n\t\t\tthis[f] = fn;\n\t\t\tlet res = this[f](...args, ...args1);\n\t\t\tdelete this[f];\n\t\t\treturn res;\n\t\t} else {\n\t\t\t// bind返回的函数作为普通函数被调用时\n\t\t\tcontext[f] = fn;\n\t\t\tlet res = context[f](...args, ...args1);\n\t\t\tdelete context[f];\n\t\t\treturn res;\n\t\t}\n\t};\n\t// 如果绑定的是构造函数 那么需要继承构造函数原型属性和方法\n\t// 实现继承的方式: 使用Object.create\n\tresult.prototype = Object.create(fn.prototype);\n\treturn result;\n};\n```\n\n### Reference\n\n- [面试官为啥总是让我们手撕 call、apply、bind? - 掘金](https://juejin.cn/post/7128233572380442660)\n- [JavaScript 深入之 call 和 apply 的模拟实现](https://juejin.cn/post/6844903476477034510 https://juejin.cn/post/6844903476477034510)\n- [JavaScript 基础心法—— call apply bind](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faxuebin%2Farticles%2Fissues%2F7 https://github.com/axuebin/articles/issues/7)\n- [面试官问：能否模拟实现 JS 的 call 和 apply 方法](https://juejin.cn/post/6844903728147857415 https://juejin.cn/post/6844903728147857415)\n- [回味 JS 基础:call apply 与 bind](https://juejin.cn/post/6844903444348665870 https://juejin.cn/post/6844903444348665870)\n- [面试官问：能否模拟实现 JS 的 bind 方法](https://juejin.cn/post/6844903718089916429 https://juejin.cn/post/6844903718089916429)\n- [不用 call 和 apply 方法模拟实现 ES5 的 bind 方法](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fjawil%2Fblog%2Fissues%2F16 https://github.com/jawil/blog/issues/16)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:3,slug:"call-apply-bind-三者功能与异同",text:"call apply bind 三者功能与异同#"},{depth:4,slug:"功能",text:"功能#"},{depth:4,slug:"异同",text:"异同#"},{depth:3,slug:"手写-call-apply-bind",text:"手写 call apply bind#"},{depth:3,slug:"reference",text:"Reference#"}]}const Content=createComponent(((n,s,a)=>{const{layout:l,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};