import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="14最长公共前缀longest-common-prefix">14.最长公共前缀(Longest-Common-Prefix)<a class="anchor" href="#14最长公共前缀longest-common-prefix"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="题目要求">题目要求<a class="anchor" href="#题目要求"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本题要求编写一个函数查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串  “。</p>\n<h2 id="核心方法"><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95">核心方法</a><a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<ul>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F">核心方法 > 数组排序</a></li>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E6%B1%82%E5%92%8C">核心方法 > 求和</a></li>\n<li><a href="%E6%A0%B8%E5%BF%83%E6%96%B9%E6%B3%95#%E5%8F%96%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9C%80%E7%9F%AD/%E6%9C%80%E9%95%BF%E5%AD%97%E7%AC%A6%E4%B8%B2%E9%95%BF%E5%BA%A6">核心方法 > 取数组中最短/最长字符串长度</a></li>\n</ul>\n<h2 id="关键步骤">关键步骤<a class="anchor" href="#关键步骤"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h2 id="代码实现">代码实现<a class="anchor" href="#代码实现"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="方案三更优-字符串长度远小于-n取最短字符串长度比较">方案三（更优-字符串长度远小于 n）：取最短字符串长度比较<a class="anchor" href="#方案三更优-字符串长度远小于-n取最短字符串长度比较"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>时间复杂度 <code>O(n * m)</code>，空间复杂度 <code>O(m)</code>，因为在大多数情况下，m 远小于 n，因此可以将 m 视为常数，最终的时间复杂度近似为 O(n)。</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> longestCommonPrefix</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">strs</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (strs.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> ;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#6A737D">\t// 找到最短的字符串长度：T = O(n)</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> minLen </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">min</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">...</span><span style="color:#E1E4E8">strs.</span><span style="color:#B392F0">map</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">str</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> str.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">));</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> prefix </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ;</span></span>\n<span class="line"><span style="color:#6A737D">\t// 比较字符：：T = O(n * m)</span></span>\n<span class="line"><span style="color:#F97583">\tfor</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> minLen; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\tlet</span><span style="color:#E1E4E8"> charToMatch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> strs[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">][i]; </span><span style="color:#6A737D">// 取第一个字符串的当前字符</span></span>\n<span class="line"><span style="color:#F97583">\t\tif</span><span style="color:#E1E4E8"> (strs.</span><span style="color:#B392F0">every</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">str</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> str[i] </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> charToMatch)) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tprefix </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> charToMatch;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tbreak</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> prefix;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>\n<h3 id="方案二更优-字符串长度接近-n数组排序后比较">方案二（更优-字符串长度接近 n）：数组排序后比较<a class="anchor" href="#方案二更优-字符串长度接近-n数组排序后比较"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>排序本身 <code>T = O(n*logn)</code> 非必须？</p>\n</blockquote>\n<p>时间复杂度 <code>O(n*log(n))</code>，空间复杂度 <code>O(m)</code>, <code>m</code> 近似 1，故可视为<code>O(1)</code> 用 JavaScript 实现如下：</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> longestCommonPrefix</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">strs</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (strs.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> ;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t} </span><span style="color:#6A737D">// 排序字符串数组，以便在比较时只需考虑第一个和最后一个字符串</span></span>\n<span class="line"><span style="color:#E1E4E8">\tstrs.</span><span style="color:#B392F0">sort</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> firstStr</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> strs[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>\n<span class="line"><span style="color:#F97583">\tconst</span><span style="color:#79B8FF"> lastStr</span><span style="color:#F97583"> =</span><span style="color:#E1E4E8"> strs[strs.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">];</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> prefix </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ; </span><span style="color:#6A737D">// 比较第一个和最后一个字符串的字符</span></span>\n<span class="line"><span style="color:#F97583">\tfor</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> firstStr.</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\tif</span><span style="color:#E1E4E8"> (firstStr[i] </span><span style="color:#F97583">===</span><span style="color:#E1E4E8"> lastStr[i]) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tprefix </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> firstStr[i];</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tbreak</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> prefix;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>\n<h3 id="方案一嵌套循环">方案一：嵌套循环<a class="anchor" href="#方案一嵌套循环"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>时间复杂度 <code>O(n^2)</code>，空间复杂度 <code>O(1)</code>，用 JavaScript 实现如下：</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> longestCommonPrefix</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">strs</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t// 定义初始前缀与字符串匹配元素</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> prefix </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ;</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> match </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> ; </span><span style="color:#6A737D">// 若数组长度为 1，返回第一位元素</span></span>\n<span class="line"><span style="color:#F97583">\tif</span><span style="color:#E1E4E8"> (strs.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> ===</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#F97583">\t\treturn</span><span style="color:#E1E4E8"> strs[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>\n<span class="line"><span style="color:#E1E4E8">\t} </span><span style="color:#6A737D">// 依次比较每个前缀元素</span></span>\n<span class="line"><span style="color:#F97583">\tfor</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">let</span><span style="color:#E1E4E8"> i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">, j </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; j </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> strs[i].</span><span style="color:#79B8FF">length</span><span style="color:#E1E4E8">; j</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t// 依次比较每个字符串对应的前缀元素是否匹配</span></span>\n<span class="line"><span style="color:#F97583">\t\tfor</span><span style="color:#E1E4E8"> (i </span><span style="color:#F97583">=</span><span style="color:#79B8FF"> 0</span><span style="color:#E1E4E8">; i </span><span style="color:#F97583">&#x3C;</span><span style="color:#E1E4E8"> strs.</span><span style="color:#79B8FF">length</span><span style="color:#F97583"> -</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; i</span><span style="color:#F97583">++</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tmatch </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> strs[i][j];</span></span>\n<span class="line"><span style="color:#F97583">\t\t\tif</span><span style="color:#E1E4E8"> (match </span><span style="color:#F97583">!=</span><span style="color:#E1E4E8"> strs[i </span><span style="color:#F97583">+</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">][j]) {</span></span>\n<span class="line"><span style="color:#F97583">\t\t\t\treturn</span><span style="color:#E1E4E8"> prefix;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#F97583">\t\t\t\tbreak</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tprefix </span><span style="color:#F97583">+=</span><span style="color:#E1E4E8"> match;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t}</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> prefix;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>\n<h2 id="实现过程总结">实现过程总结<a class="anchor" href="#实现过程总结"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="i-确定变量">I-确定变量<a class="anchor" href="#i-确定变量"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>思考给定变量或已知变量:\n<ul>\n<li><code>strs</code></li>\n</ul>\n</li>\n<li>定义其他需要的输入变量\n<ul>\n<li>初始前缀：<code>prefix</code></li>\n<li>字符串迭代元素：<code>match</code></li>\n<li>第一个（最短）和最后一个（最长）字符串：<code>firstStr</code>, <code>lastStr</code></li>\n</ul>\n</li>\n<li>输出变量:\n<ul>\n<li>“</li>\n<li><code>prefix</code></li>\n<li><code>strs[0]</code></li>\n</ul>\n</li>\n</ol>\n<h3 id="f-确定循环条件">F-确定循环条件<a class="anchor" href="#f-确定循环条件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>实现方式：</p>\n<ul>\n<li>字符串内循环 + 数组外循环</li>\n<li>小于最短字符串长度 <code>i &#x3C; firstStr.length</code></li>\n</ul>\n<h3 id="d-考虑并测试所有可能情况绘图可视化">D-考虑并测试所有可能情况，绘图可视化<a class="anchor" href="#d-考虑并测试所有可能情况绘图可视化"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>这一步可用 DrawIO 绘图或动笔记录，能避免遗漏，并减轻大脑负担，每通过一种情况，标绿一个，确保所有边际情况都在内即可，可以不用测试太多……：</p>\n</blockquote>\n<ul>\n<li>初版流程图：\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-14.svg" alt=""></li>\n</ul>\n</li>\n</ul>\n<h3 id="s-优化精简勿死磕善用-gpt">S-优化精简，勿死磕，善用 GPT<a class="anchor" href="#s-优化精简勿死磕善用-gpt"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>这一步实在不行不要死磕，不要硬抗…… 不防看看题解，或者问 GPT 或许直接豁然开朗，省下不少时间</p>\n</blockquote>\n<ul>\n<li>二版：</li>\n</ul>\n<h3 id="c-代码实现除-bug善用-gpt">C-代码实现除 BUG，善用 GPT<a class="anchor" href="#c-代码实现除-bug善用-gpt"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>! 切记 JS 条件判断不要用 <code>=</code>，而是用 <code>===</code></li>\n</ul>\n<h3 id="本题难点与相关知识点">本题难点与相关知识点<a class="anchor" href="#本题难点与相关知识点"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>? 怎样对比数组中的字符串\n<ul>\n<li>$ <code>strs.sort()</code> 先排序，减少比较次数</li>\n</ul>\n</li>\n<li>? 相关 JS 字符串方法\n<ul>\n<li><code>startsWith()</code></li>\n</ul>\n</li>\n</ul>',frontmatter={tags:["Algo"],category:"Programming",draft:!1,LCID:"LC-14",title:"14.最长公共前缀(Longest-Common-Prefix)",type:"A",Similar:[[["217.存在重复元素(Includes Duplicates)|LC-217"]]],topic:["Array","String","NestedLoop","Sorting"],difficulty:"Easy",Time:"O(n*logn)",Space:"O(m)",Like:null,Solution:"排序或字符串数组嵌套循环",SourceLink:"https://leetcode.cn/problems/longest-common-prefix/solutions/2430197/lc-14-zi-fu-chuan-shu-zu-cha-zhao-zui-ch-wtj7/",DateStarted:"2023-09-06T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:null,aliases:["14.最长公共前缀(Longest-Common-Prefix)","LC-14"],comment:"Sort Asc, Compare left shortest string with right longest string; 记得 break 跳出循环",reviewed:6,TimeNeed:"Hard",Datereviewed:"2024-02-16T16:00:00.000Z","linter-yaml-title-alias":"14.最长公共前缀(Longest-Common-Prefix)",minutes:4,words:877},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/sorting/14.最长公共前缀-longest-common-prefix.md",url=void 0;function rawContent(){return"\n# 14.最长公共前缀(Longest-Common-Prefix)\n\n## 题目要求\n\n本题要求编写一个函数查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串  ``。\n\n## [核心方法](核心方法)\n\n- [核心方法 > 数组排序](核心方法#数组排序)\n- [核心方法 > 求和](核心方法#求和)\n- [核心方法 > 取数组中最短/最长字符串长度](核心方法#取数组中最短/最长字符串长度)\n\n## 关键步骤\n\n## 代码实现\n\n### 方案三（更优-字符串长度远小于 n）：取最短字符串长度比较\n\n时间复杂度 `O(n * m)`，空间复杂度 `O(m)`，因为在大多数情况下，m 远小于 n，因此可以将 m 视为常数，最终的时间复杂度近似为 O(n)。\n\n```js\nvar longestCommonPrefix = function (strs) {\n\tif (strs.length === 0) {\n\t\treturn ;\n\t}\n\t// 找到最短的字符串长度：T = O(n)\n\tlet minLen = Math.min(...strs.map((str) => str.length));\n\tlet prefix = ;\n\t// 比较字符：：T = O(n * m)\n\tfor (let i = 0; i < minLen; i++) {\n\t\tlet charToMatch = strs[0][i]; // 取第一个字符串的当前字符\n\t\tif (strs.every((str) => str[i] === charToMatch)) {\n\t\t\tprefix += charToMatch;\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn prefix;\n};\n```\n\n### 方案二（更优-字符串长度接近 n）：数组排序后比较\n\n> 排序本身 `T = O(n*logn)` 非必须？\n\n时间复杂度 `O(n*log(n))`，空间复杂度 `O(m)`, `m` 近似 1，故可视为`O(1)` 用 JavaScript 实现如下：\n\n```js\nvar longestCommonPrefix = function (strs) {\n\tif (strs.length === 0) {\n\t\treturn ;\n\t} // 排序字符串数组，以便在比较时只需考虑第一个和最后一个字符串\n\tstrs.sort();\n\tconst firstStr = strs[0];\n\tconst lastStr = strs[strs.length - 1];\n\tlet prefix = ; // 比较第一个和最后一个字符串的字符\n\tfor (let i = 0; i < firstStr.length; i++) {\n\t\tif (firstStr[i] === lastStr[i]) {\n\t\t\tprefix += firstStr[i];\n\t\t} else {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn prefix;\n};\n```\n\n### 方案一：嵌套循环\n\n时间复杂度 `O(n^2)`，空间复杂度 `O(1)`，用 JavaScript 实现如下：\n\n```js\nvar longestCommonPrefix = function (strs) {\n\t// 定义初始前缀与字符串匹配元素\n\tlet prefix = ;\n\tlet match = ; // 若数组长度为 1，返回第一位元素\n\tif (strs.length === 1) {\n\t\treturn strs[0];\n\t} // 依次比较每个前缀元素\n\tfor (let i = 0, j = 0; j < strs[i].length; j++) {\n\t\t// 依次比较每个字符串对应的前缀元素是否匹配\n\t\tfor (i = 0; i < strs.length - 1; i++) {\n\t\t\tmatch = strs[i][j];\n\t\t\tif (match != strs[i + 1][j]) {\n\t\t\t\treturn prefix;\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tprefix += match;\n\t}\n\treturn prefix;\n};\n```\n\n## 实现过程总结\n\n### I-确定变量\n\n1. 思考给定变量或已知变量:\n   - `strs`\n2. 定义其他需要的输入变量\n   - 初始前缀：`prefix`\n   - 字符串迭代元素：`match`\n   - 第一个（最短）和最后一个（最长）字符串：`firstStr`, `lastStr`\n3. 输出变量:\n   - ``\n   - `prefix`\n   - `strs[0]`\n\n### F-确定循环条件\n\n实现方式：\n\n- 字符串内循环 + 数组外循环\n- 小于最短字符串长度 `i < firstStr.length`\n\n### D-考虑并测试所有可能情况，绘图可视化\n\n> 这一步可用 DrawIO 绘图或动笔记录，能避免遗漏，并减轻大脑负担，每通过一种情况，标绿一个，确保所有边际情况都在内即可，可以不用测试太多……：\n\n- 初版流程图：\n  - ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-14.svg)\n\n### S-优化精简，勿死磕，善用 GPT\n\n> 这一步实在不行不要死磕，不要硬抗…… 不防看看题解，或者问 GPT 或许直接豁然开朗，省下不少时间\n\n- 二版：\n\n### C-代码实现除 BUG，善用 GPT\n\n- ! 切记 JS 条件判断不要用 `=`，而是用 `===`\n\n### 本题难点与相关知识点\n\n- ? 怎样对比数组中的字符串\n  - $ `strs.sort()` 先排序，减少比较次数\n- ? 相关 JS 字符串方法\n  - `startsWith()`\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"14最长公共前缀longest-common-prefix",text:"14.最长公共前缀(Longest-Common-Prefix)#"},{depth:2,slug:"题目要求",text:"题目要求#"},{depth:2,slug:"核心方法",text:"核心方法#"},{depth:2,slug:"关键步骤",text:"关键步骤#"},{depth:2,slug:"代码实现",text:"代码实现#"},{depth:3,slug:"方案三更优-字符串长度远小于-n取最短字符串长度比较",text:"方案三（更优-字符串长度远小于 n）：取最短字符串长度比较#"},{depth:3,slug:"方案二更优-字符串长度接近-n数组排序后比较",text:"方案二（更优-字符串长度接近 n）：数组排序后比较#"},{depth:3,slug:"方案一嵌套循环",text:"方案一：嵌套循环#"},{depth:2,slug:"实现过程总结",text:"实现过程总结#"},{depth:3,slug:"i-确定变量",text:"I-确定变量#"},{depth:3,slug:"f-确定循环条件",text:"F-确定循环条件#"},{depth:3,slug:"d-考虑并测试所有可能情况绘图可视化",text:"D-考虑并测试所有可能情况，绘图可视化#"},{depth:3,slug:"s-优化精简勿死磕善用-gpt",text:"S-优化精简，勿死磕，善用 GPT#"},{depth:3,slug:"c-代码实现除-bug善用-gpt",text:"C-代码实现除 BUG，善用 GPT#"},{depth:3,slug:"本题难点与相关知识点",text:"本题难点与相关知识点#"}]}const Content=createComponent(((s,n,a)=>{const{layout:l,...t}=frontmatter;return t.file=file,t.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};