import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="56合并区间-merge-intervals">56.合并区间 (Merge Intervals)<a class="anchor" href="#56合并区间-merge-intervals"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h2 id="解题思路与知识提炼">解题思路与知识提炼<a class="anchor" href="#解题思路与知识提炼"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组</p>\n<h3 id="核心方法">核心方法<a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>数组排序：\n<ul>\n<li>基本升序操作：<code>.sort()</code>（见 [LC-14](14.最长公共前缀(Longest-Common-Prefix)）</li>\n<li>二维数组中的区间按左端点升序排列\n<ul>\n<li>修改原始输入参数：<code>intervals.sort((a, b) => a[0] - b[0])</code></li>\n<li>不修改原始输入参数：<strong><code>intervals.slice().sort((a, b) => a[0] - b[0])</code></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>二维数组读取：\n<ul>\n<li>若当前区间的首位大于待加入区间末位，则推入上一个待加入区间，并更新待加入区间为当前区间，继续比较</li>\n</ul>\n</li>\n<li>数组栈方法：\n<ul>\n<li>将合并后的待加入区间推入新定义的空数组： <strong><code>.push()</code></strong></li>\n</ul>\n</li>\n<li>取最大值：\n<ul>\n<li>取末位最大值更新待加入区间 <strong><code>prev[1] = Math.max(prev[1], cur[1]);</code></strong></li>\n</ul>\n</li>\n</ol>\n<h3 id="代码优化考虑">代码优化考虑<a class="anchor" href="#代码优化考虑"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>简化代码，增强循环条件与变量名可读性：<strong><code>for (... of ...){}</code></strong></li>\n<li>解构赋值，可更清晰的处理区间起终点; <code>const [curStart, curEnd] = currentInterval;</code></li>\n<li>循环结构中的常量声明能用 <code>const</code> 而不是 <code>let</code> 符合最佳实践与代码规范，可防止意外修改</li>\n</ol>\n<h2 id="代码实现-js">代码实现 (JS)<a class="anchor" href="#代码实现-js"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>本方案可满足时间复杂度 <code>O(nlogn)</code>，空间复杂度 <code>O(n)</code>，用 JavaScript 实现如下：</p>\n\x3c!--SR:!2023-09-13,3,250!2023-09-13,3,250!2023-09-13,3,250--\x3e\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#B392F0"> merge</span><span style="color:#F97583"> =</span><span style="color:#F97583"> function</span><span style="color:#E1E4E8"> (</span><span style="color:#FFAB70">intervals</span><span style="color:#E1E4E8">) {</span></span>\n<span class="line"><span style="color:#6A737D">\t// 将列表中的区间按左端点升序排列：.slice() 可不修改原始输入参数</span></span>\n<span class="line"><span style="color:#E1E4E8">\tintervals </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> intervals.</span><span style="color:#B392F0">slice</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">sort</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">a</span><span style="color:#E1E4E8">, </span><span style="color:#FFAB70">b</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> a[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">-</span><span style="color:#E1E4E8"> b[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">]); </span><span style="color:#6A737D">// 定义返回的新区间数组，及待加入的区间</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> merged </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> [];</span></span>\n<span class="line"><span style="color:#F97583">\tlet</span><span style="color:#E1E4E8"> prev </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> intervals[</span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">];</span></span>\n<span class="line"><span style="color:#6A737D">\t// 简化代码，增强循环条件与变量名可读性</span></span>\n<span class="line"><span style="color:#F97583">\tfor</span><span style="color:#E1E4E8"> (</span><span style="color:#F97583">const</span><span style="color:#79B8FF"> currentInterval</span><span style="color:#F97583"> of</span><span style="color:#E1E4E8"> intervals) {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t// 解构赋值，可更清晰的处理区间起终点;</span></span>\n<span class="line"><span style="color:#F97583">\t\tconst</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">curStart</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">curEnd</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> currentInterval;</span></span>\n<span class="line"><span style="color:#F97583">\t\tconst</span><span style="color:#E1E4E8"> [</span><span style="color:#79B8FF">prevStart</span><span style="color:#E1E4E8">, </span><span style="color:#79B8FF">prevEnd</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> prev; </span><span style="color:#6A737D">// 若当前区间的首位大于待加入区间的末位，则两区间无重合可能</span></span>\n<span class="line"><span style="color:#F97583">\t\tif</span><span style="color:#E1E4E8"> (curStart </span><span style="color:#F97583">></span><span style="color:#E1E4E8"> prevEnd) {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// 将上个待加入区间推入区间数组，注意不是推入 cur</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tmerged.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(prev); </span><span style="color:#6A737D">// 更新待加入区间为当前区间</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tprev </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> currentInterval;</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t} </span><span style="color:#F97583">else</span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#6A737D">\t\t\t// 对比两区间，取末位最大值更新待加入区间</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t\tprev[</span><span style="color:#79B8FF">1</span><span style="color:#E1E4E8">] </span><span style="color:#F97583">=</span><span style="color:#E1E4E8"> Math.</span><span style="color:#B392F0">max</span><span style="color:#E1E4E8">(prevEnd, curEnd);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\t}</span></span>\n<span class="line"><span style="color:#E1E4E8">\t} </span><span style="color:#6A737D">// 最后一个待加入区间</span></span>\n<span class="line"><span style="color:#E1E4E8">\tmerged.</span><span style="color:#B392F0">push</span><span style="color:#E1E4E8">(prev);</span></span>\n<span class="line"><span style="color:#F97583">\treturn</span><span style="color:#E1E4E8"> merged;</span></span>\n<span class="line"><span style="color:#E1E4E8">};</span></span>\n<span class="line"></span></code></pre>\n<h2 id="实现过程说明">实现过程说明<a class="anchor" href="#实现过程说明"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="一确定变量">一、确定变量<a class="anchor" href="#一确定变量"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>思考给定变量或已知变量:\n<ul>\n<li>未排序的区间数组 <code>intervals</code></li>\n</ul>\n</li>\n<li>定义其他需要的输入、输出变量:\n<ul>\n<li>$ 按照左端点升序排序后的区间数组 <code>intervals.sort((a, b) => a[0] - b[0])</code></li>\n<li>$ 待返回的新区间数组 <code>merged</code></li>\n<li>待加入的区间 <code>prev</code></li>\n<li>当前对比区间 <code>cur</code> 或 <code>currentInterval</code></li>\n</ul>\n</li>\n</ol>\n<h3 id="二确定循环条件">二、确定循环条件<a class="anchor" href="#二确定循环条件"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ol>\n<li>依次比较区间数组中的每个区间：\n<ul>\n<li>一版：<code>for (i = 0; i &#x3C; intervals.length; i++)</code></li>\n<li>二版：<code>for (const currentInterval of Intervals)</code></li>\n</ul>\n</li>\n<li>判断<font color="#F36208">当前区间的首位</font>是否大于<font color="#F36208">待加入区间末位</font>\n<ul>\n<li>若是，则两区间无重合可能\n<ul>\n<li>$ 将上个待加入区间推入区间数组，注意不是推入 cur：<strong><code>merged.push(prev)</code></strong></li>\n<li>更新待加入区间为当前区间</li>\n</ul>\n</li>\n<li>若否，对比两区间末位\n<ul>\n<li>$ 取末位最大值更新待加入区间 <strong><code>prev[1] = Math.max(prev[1], cur[1]);</code></strong></li>\n</ul>\n</li>\n</ul>\n</li>\n</ol>\n<h3 id="三测试绘图可视化">三、测试、绘图可视化<a class="anchor" href="#三测试绘图可视化"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>这一步可用 VS Code Debugger (Node) + DrawIO 绘图：</p>\n</blockquote>\n<ul>\n<li><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-56.svg" alt=""></li>\n</ul>\n\x3c!--SR:!2023-09-13,3,250!2023-09-13,3,250--\x3e',frontmatter={title:"56.合并区间 (Merge Intervals)",tags:["Algo"],category:"Programming",draft:!1,LCID:"LC-56",type:"A",Similar:[],topic:["Array","2d-Array","Sorting","Greedy"],difficulty:"Medium",Time:"O(n*logn)",Space:"O(n)",Like:null,Solution:"二维数组排序与取最大值合并",SourceLink:"https://leetcode.cn/problems/merge-intervals/solutions/2432645/lc-56-he-bing-qu-jian-tu-wen-xiang-jie-e-uv85/",DateStarted:"2023-09-07T00:00:00.000Z",DateDone:"2023-09-08T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:null,aliases:["LC-56"],reviewed:8,Datereviewed:"2024-02-16T16:00:00.000Z",comment:"区间排序，区间对比 (prev, cur)，语义循环，解构赋值，择大结尾",TimeNeed:"Hard",minutes:4,words:807},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/recursive-algorithm/greedy/56.合并区间 (Merge Intervals).md",url=void 0;function rawContent(){return"\n# 56.合并区间 (Merge Intervals)\n\n## 解题思路与知识提炼\n\n本题涉及二维数组结构，要求合并所有重叠的区间，并返回一个不重叠的区间数组\n\n### 核心方法\n\n1. 数组排序：\n   - 基本升序操作：`.sort()`（见 [LC-14](14.最长公共前缀(Longest-Common-Prefix)）\n   - 二维数组中的区间按左端点升序排列\n     - 修改原始输入参数：`intervals.sort((a, b) => a[0] - b[0])`\n     - 不修改原始输入参数：**`intervals.slice().sort((a, b) => a[0] - b[0])`**\n2. 二维数组读取：\n   - 若当前区间的首位大于待加入区间末位，则推入上一个待加入区间，并更新待加入区间为当前区间，继续比较\n3. 数组栈方法：\n   - 将合并后的待加入区间推入新定义的空数组： **`.push()`**\n4. 取最大值：\n   - 取末位最大值更新待加入区间 **`prev[1] = Math.max(prev[1], cur[1]);`**\n\n### 代码优化考虑\n\n1. 简化代码，增强循环条件与变量名可读性：**`for (... of ...){}`**\n2. 解构赋值，可更清晰的处理区间起终点; `const [curStart, curEnd] = currentInterval;`\n3. 循环结构中的常量声明能用 `const` 而不是 `let` 符合最佳实践与代码规范，可防止意外修改\n\n## 代码实现 (JS)\n\n本方案可满足时间复杂度 `O(nlogn)`，空间复杂度 `O(n)`，用 JavaScript 实现如下：\n\n\x3c!--SR:!2023-09-13,3,250!2023-09-13,3,250!2023-09-13,3,250--\x3e\n\n```js\nvar merge = function (intervals) {\n\t// 将列表中的区间按左端点升序排列：.slice() 可不修改原始输入参数\n\tintervals = intervals.slice().sort((a, b) => a[0] - b[0]); // 定义返回的新区间数组，及待加入的区间\n\tlet merged = [];\n\tlet prev = intervals[0];\n\t// 简化代码，增强循环条件与变量名可读性\n\tfor (const currentInterval of intervals) {\n\t\t// 解构赋值，可更清晰的处理区间起终点;\n\t\tconst [curStart, curEnd] = currentInterval;\n\t\tconst [prevStart, prevEnd] = prev; // 若当前区间的首位大于待加入区间的末位，则两区间无重合可能\n\t\tif (curStart > prevEnd) {\n\t\t\t// 将上个待加入区间推入区间数组，注意不是推入 cur\n\t\t\tmerged.push(prev); // 更新待加入区间为当前区间\n\t\t\tprev = currentInterval;\n\t\t} else {\n\t\t\t// 对比两区间，取末位最大值更新待加入区间\n\t\t\tprev[1] = Math.max(prevEnd, curEnd);\n\t\t}\n\t} // 最后一个待加入区间\n\tmerged.push(prev);\n\treturn merged;\n};\n```\n\n## 实现过程说明\n\n### 一、确定变量\n\n1. 思考给定变量或已知变量:\n   - 未排序的区间数组 `intervals`\n2. 定义其他需要的输入、输出变量:\n   - $ 按照左端点升序排序后的区间数组 `intervals.sort((a, b) => a[0] - b[0])`\n   - $ 待返回的新区间数组 `merged`\n   - 待加入的区间 `prev`\n   - 当前对比区间 `cur` 或 `currentInterval`\n\n### 二、确定循环条件\n\n1. 依次比较区间数组中的每个区间：\n   - 一版：`for (i = 0; i < intervals.length; i++)`\n   - 二版：`for (const currentInterval of Intervals)`\n2. 判断<font color=#F36208>当前区间的首位</font>是否大于<font color=#F36208>待加入区间末位</font>\n   - 若是，则两区间无重合可能\n     - $ 将上个待加入区间推入区间数组，注意不是推入 cur：**`merged.push(prev)`**\n     - 更新待加入区间为当前区间\n   - 若否，对比两区间末位\n     - $ 取末位最大值更新待加入区间 **`prev[1] = Math.max(prev[1], cur[1]);`**\n\n### 三、测试、绘图可视化\n\n> 这一步可用 VS Code Debugger (Node) + DrawIO 绘图：\n\n- ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/LC-G-56.svg)\n\x3c!--SR:!2023-09-13,3,250!2023-09-13,3,250--\x3e\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"56合并区间-merge-intervals",text:"56.合并区间 (Merge Intervals)#"},{depth:2,slug:"解题思路与知识提炼",text:"解题思路与知识提炼#"},{depth:3,slug:"核心方法",text:"核心方法#"},{depth:3,slug:"代码优化考虑",text:"代码优化考虑#"},{depth:2,slug:"代码实现-js",text:"代码实现 (JS)#"},{depth:2,slug:"实现过程说明",text:"实现过程说明#"},{depth:3,slug:"一确定变量",text:"一、确定变量#"},{depth:3,slug:"二确定循环条件",text:"二、确定循环条件#"},{depth:3,slug:"三测试绘图可视化",text:"三、测试、绘图可视化#"}]}const Content=createComponent(((n,s,e)=>{const{layout:a,...l}=frontmatter;return l.file=file,l.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};