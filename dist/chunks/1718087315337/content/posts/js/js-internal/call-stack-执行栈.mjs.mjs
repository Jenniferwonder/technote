import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h2 id="执行栈-call-stack">执行栈 Call Stack<a class="anchor" href="#执行栈-call-stack"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<p>是一种 <code>先进后出</code> 的数据结构，用来存储代码运行的所有执行上下文</p>\n<ol>\n<li>当 JS 引擎第一次遇到 <code>.js</code> 脚本时，会创建一个全局的执行上下文并且压入当前执行栈</li>\n<li>每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部</li>\n<li>当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文</li>\n<li>一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文</li>\n</ol>\n<h3 id="执行栈示例">执行栈示例<a class="anchor" href="#执行栈示例"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#F97583">var</span><span style="color:#79B8FF"> a</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 1</span><span style="color:#E1E4E8">; </span><span style="color:#6A737D">// 1. 全局上下文环境</span></span>\n<span class="line"><span style="color:#F97583">function</span><span style="color:#B392F0"> bar</span><span style="color:#E1E4E8"> (x) {</span></span>\n<span class="line"><span style="color:#79B8FF">    console</span><span style="color:#F97583">.</span><span style="color:#79B8FF">log</span><span style="color:#E1E4E8">(</span><span style="color:#9ECBFF">\'bar\'</span><span style="color:#E1E4E8">)</span></span>\n<span class="line"><span style="color:#F97583">    var</span><span style="color:#79B8FF"> b</span><span style="color:#F97583"> =</span><span style="color:#79B8FF"> 2</span><span style="color:#E1E4E8">;</span></span>\n<span class="line"><span style="color:#F97583">    fn</span><span style="color:#E1E4E8">(x + b); // 3. fn上下文环境</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#E1E4E8">function fn (c) {</span></span>\n<span class="line"><span style="color:#E1E4E8">    console.log(c);</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#E1E4E8">bar(3); // 2. bar上下文环境</span></span>\n<span class="line"></span>\n<span class="line"></span></code></pre>\n<p><strong>执行栈图解</strong> <img src="https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bffb09739624bcdb3572c6ae963d8a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?" alt="执行上下文.png"></p>',frontmatter={draft:!1,title:"call-stack-执行栈",topic:["Basics"],tags:["JavaScript"],type:"D",DateStarted:"2022-12-16T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",Datereviewed:null,comment:null,reviewed:null,difficulty:null,status:null,category:"Programming",minutes:1,words:232},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/js-internal/call-stack-执行栈.md",url=void 0;function rawContent(){return"\n\n\n## 执行栈 Call Stack\n是一种 `先进后出` 的数据结构，用来存储代码运行的所有执行上下文\n\n1. 当 JS 引擎第一次遇到 `.js` 脚本时，会创建一个全局的执行上下文并且压入当前执行栈\n2. 每当 JS 引擎遇到一个函数调用，它会为该函数创建一个新的执行上下文并压入栈的顶部\n3. 当该函数执行结束时，执行上下文从栈中弹出，控制流程到达当前栈中的下一个上下文\n4. 一旦所有代码执行完毕，JS 引擎从当前栈中移除全局执行上下文\n\n### 执行栈示例\n\n```php\nvar a = 1; // 1. 全局上下文环境\nfunction bar (x) {\n    console.log('bar')\n    var b = 2;\n    fn(x + b); // 3. fn上下文环境\n}\nfunction fn (c) {\n    console.log(c);\n}\nbar(3); // 2. bar上下文环境\n\n```\n\n**执行栈图解** ![执行上下文.png](https://p6-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5bffb09739624bcdb3572c6ae963d8a2~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp?)\n"}function compiledContent(){return html}function getHeadings(){return[{depth:2,slug:"执行栈-call-stack",text:"执行栈 Call Stack#"},{depth:3,slug:"执行栈示例",text:"执行栈示例#"}]}const Content=createComponent(((n,s,a)=>{const{layout:l,...e}=frontmatter;return e.file=file,e.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};