import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h2 id="核心方法">核心方法<a class="anchor" href="#核心方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h2>\n<h3 id="哈希表"><a href="Hash-Table">哈希表</a><a class="anchor" href="#哈希表"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>Object 🏷️<a href="1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sums">LC-01</a>\n<ul>\n<li><code>{}</code></li>\n<li>包含：<code>.hasOwnProperty()</code></li>\n<li>存入：<code>numToIndex[nums[i]] = i</code></li>\n</ul>\n</li>\n<li>Map 🏷️<a href="1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sums">LC-01</a>\n<ul>\n<li><code>new Map()</code></li>\n<li>包含：<code>.has()</code></li>\n<li>读取：<code>.get()</code></li>\n<li>存入：<code>.set()</code></li>\n</ul>\n</li>\n</ul>\n<h3 id="数组"><a href="Array">数组</a><a class="anchor" href="#数组"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="嵌套循环">嵌套循环<a class="anchor" href="#嵌套循环"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>数组循环方法：\n<ul>\n<li><code>.every()</code> 🏷️<a href="14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-Longest-Common-Prefix">LC-14</a></li>\n</ul>\n</li>\n<li>不重复元素：\n<ul>\n<li><code>for (j = i + 1, j &#x3C;..., j++)</code> 🏷️<a href="1.%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C-Two-Sums">LC-01</a></li>\n</ul>\n</li>\n</ul>\n<h4 id="求和">求和<a class="anchor" href="#求和"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>数组元素值总和：<strong><code>nums.reduce((prev, cur) => prev + cur, 0)</code></strong> （见  <a href="1991.-%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE-Find-Pivot-Index">LC-1991</a>）</li>\n<li>迭代求和：<code>sum += nums[i]</code> （见  <a href="1991.-%E6%89%BE%E5%88%B0%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E9%97%B4%E4%BD%8D%E7%BD%AE-Find-Pivot-Index">LC-1991</a>）</li>\n</ul>\n<h4 id="数组排序">数组排序<a class="anchor" href="#数组排序"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>默认按字符串升序操作：<code>.sort()</code>（见  <a href="14.%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-Longest-Common-Prefix">LC-14</a>\n<ul>\n<li>! 不适用按数值大小升序</li>\n<li>返回：<code>[-1,-2,-3,0,1]</code></li>\n</ul>\n</li>\n<li>按数值大小升序排列：<strong><code>.sort((a,b)=>a-b)</code></strong>\n<ul>\n<li>返回：<code>[-3,-2,-1,0,1]</code></li>\n</ul>\n</li>\n<li>二维数组中的区间按左端点升序排列（见  <a href="56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals">LC-56</a>）\n<ul>\n<li>修改原始输入参数：<code>intervals.sort((a, b) => a[0] - b[0])</code></li>\n<li>不修改原始输入参数：<strong><code>intervals.slice().sort((a, b) => a[0] - b[0])</code></strong></li>\n</ul>\n</li>\n</ul>\n<h4 id="二维数组读取">二维数组读取<a class="anchor" href="#二维数组读取"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>若当前区间的首位大于待加入区间末位，则推入上一个待加入区间，并更新待加入区间为当前区间，继续比较 （见  <a href="56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals">LC-56</a>）</li>\n<li>解构赋值，可更清晰的处理区间起终点或增强可读性;\n<ul>\n<li><code>const [curStart, curEnd] = currentInterval;</code> 🏷️<a href="56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals">LC-56</a></li>\n<li><code>[cost, maxProfit] = [prices[0], 0];</code> 🏷️<a href="121.%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA-best-time-to-buy-and-sell-stock">LC-121</a></li>\n</ul>\n</li>\n</ul>\n<h4 id="数组栈方法">数组栈方法<a class="anchor" href="#数组栈方法"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>将合并后的待加入区间推入新定义的空数组： <strong><code>.push()</code></strong> （见  <a href="56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals">LC-56</a>）</li>\n</ul>\n<h4 id="取数组中最大值">取数组中最大值<a class="anchor" href="#取数组中最大值"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>取末位最大值更新待加入区间  <strong><code>prev[1] = Math.max(prev[1], cur[1]);</code></strong>\n<ul>\n<li>🏷️<a href="56.%E5%90%88%E5%B9%B6%E5%8C%BA%E9%97%B4-Merge-Intervals">LC-56</a></li>\n<li>🏷️LC-121</li>\n</ul>\n</li>\n</ul>\n<h4 id="取数组中最短最长字符串长度">取数组中最短/最长字符串长度<a class="anchor" href="#取数组中最短最长字符串长度"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li><strong><code>minLen = Math.min(...strs.map(str => str.length))</code></strong></li>\n</ul>\n<h4 id="二分法-分治">二分法 (分治)<a class="anchor" href="#二分法-分治"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>(见 <a href="LC-35">LC-35</a>)</li>\n</ul>\n<h4 id="双指针">双指针<a class="anchor" href="#双指针"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ul>\n<li>利用快指针遍历数组去重/去除给定值，慢指针追踪唯一/保留元素\n<ul>\n<li>去除给定值 🏷️<a href="27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-Remove-Element">LC-27</a></li>\n<li>去重 🏷️<a href="26.%E5%8E%BB%E9%99%A4%E9%87%8D%E5%A4%8D%E5%85%83%E7%B4%A0">LC-26</a>-Remove-duplicates-from-sorted-array</li>\n</ul>\n</li>\n</ul>',frontmatter={title:"核心方法",type:null,Datereviewed:null,reviewed:null,difficulty:null,status:null,comment:null,draft:!1,DateStarted:"2023-09-08T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",topic:["Algo"],tags:["Algo"],category:"Programming",minutes:2,words:378},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/algo/核心方法.md",url=void 0;function rawContent(){return"\n## 核心方法\n\n### [哈希表](Hash-Table)\n\n- Object 🏷️[LC-01](1.两数之和-Two-Sums)\n  - `{}`\n  - 包含：`.hasOwnProperty()`\n  - 存入：`numToIndex[nums[i]] = i`\n- Map 🏷️[LC-01](1.两数之和-Two-Sums)\n  - `new Map()`\n  - 包含：`.has()`\n  - 读取：`.get()`\n  - 存入：`.set()`\n\n### [数组](Array)\n\n#### 嵌套循环\n\n- 数组循环方法：\n  - `.every()` 🏷️[LC-14](14.最长公共前缀-Longest-Common-Prefix)\n- 不重复元素：\n  - `for (j = i + 1, j <..., j++)` 🏷️[LC-01](1.两数之和-Two-Sums)\n\n#### 求和\n\n- 数组元素值总和：**`nums.reduce((prev, cur) => prev + cur, 0)`** （见  [LC-1991](1991.-找到数组的中间位置-Find-Pivot-Index)）\n- 迭代求和：`sum += nums[i]` （见  [LC-1991](1991.-找到数组的中间位置-Find-Pivot-Index)）\n\n#### 数组排序\n\n- 默认按字符串升序操作：`.sort()`（见  [LC-14](14.最长公共前缀-Longest-Common-Prefix)\n  - ! 不适用按数值大小升序\n  - 返回：`[-1,-2,-3,0,1]`\n- 按数值大小升序排列：**`.sort((a,b)=>a-b)`**\n  - 返回：`[-3,-2,-1,0,1]`\n- 二维数组中的区间按左端点升序排列（见  [LC-56](56.合并区间-Merge-Intervals)）\n  - 修改原始输入参数：`intervals.sort((a, b) => a[0] - b[0])`\n  - 不修改原始输入参数：**`intervals.slice().sort((a, b) => a[0] - b[0])`**\n\n#### 二维数组读取\n\n- 若当前区间的首位大于待加入区间末位，则推入上一个待加入区间，并更新待加入区间为当前区间，继续比较 （见  [LC-56](56.合并区间-Merge-Intervals)）\n- 解构赋值，可更清晰的处理区间起终点或增强可读性;\n  - `const [curStart, curEnd] = currentInterval;` 🏷️[LC-56](56.合并区间-Merge-Intervals)\n  - `[cost, maxProfit] = [prices[0], 0];` 🏷️[LC-121](121.买卖股票最佳时机-best-time-to-buy-and-sell-stock)\n\n#### 数组栈方法\n\n- 将合并后的待加入区间推入新定义的空数组： **`.push()`** （见  [LC-56](56.合并区间-Merge-Intervals)）\n\n#### 取数组中最大值\n\n- 取末位最大值更新待加入区间  **`prev[1] = Math.max(prev[1], cur[1]);`**\n  - 🏷️[LC-56](56.合并区间-Merge-Intervals)\n  - 🏷️LC-121\n\n#### 取数组中最短/最长字符串长度\n\n- **`minLen = Math.min(...strs.map(str => str.length))`**\n\n#### 二分法 (分治)\n\n- (见 [LC-35](LC-35))\n\n#### 双指针\n\n- 利用快指针遍历数组去重/去除给定值，慢指针追踪唯一/保留元素\n  - 去除给定值 🏷️[LC-27](27.移除元素-Remove-Element)\n  - 去重 🏷️[LC-26](26.去除重复元素)-Remove-duplicates-from-sorted-array\n"}function compiledContent(){return html}function getHeadings(){return[{depth:2,slug:"核心方法",text:"核心方法#"},{depth:3,slug:"哈希表",text:"哈希表#"},{depth:3,slug:"数组",text:"数组#"},{depth:4,slug:"嵌套循环",text:"嵌套循环#"},{depth:4,slug:"求和",text:"求和#"},{depth:4,slug:"数组排序",text:"数组排序#"},{depth:4,slug:"二维数组读取",text:"二维数组读取#"},{depth:4,slug:"数组栈方法",text:"数组栈方法#"},{depth:4,slug:"取数组中最大值",text:"取数组中最大值#"},{depth:4,slug:"取数组中最短最长字符串长度",text:"取数组中最短/最长字符串长度#"},{depth:4,slug:"二分法-分治",text:"二分法 (分治)#"},{depth:4,slug:"双指针",text:"双指针#"}]}const Content=createComponent(((n,e,a)=>{const{layout:r,...l}=frontmatter;return l.file=file,l.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};