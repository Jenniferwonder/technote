import{createComponent,renderTemplate,maybeRenderHead,unescapeHTML}from"../../../../astro.mjs";import"kleur/colors";import"clsx";import"html-escaper";import"cssesc";const html='<h1 id="event-loop-事件循环">Event Loop-事件循环<a class="anchor" href="#event-loop-事件循环"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h1>\n<h3 id="相关术语">相关术语<a class="anchor" href="#相关术语"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>call stack > Web APIs > callback queue > 🔁event loop > task in callback queue? push task to the end of stack</li>\n<li>render queue：重绘</li>\n<li>调用栈、堆栈溢出（stack overflow）、回调队列/任务队列（回调函数）、事件循环</li>\n</ul>\n<h3 id="event-loop-事件轮询机制">Event Loop (事件轮询机制)<a class="anchor" href="#event-loop-事件轮询机制"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>事件循环（Event Loop）是 JavaScript 运行时环境中的一个核心概念，它负责协调异步操作和同步代码的执行。JavaScript 是单线程的，这意味着它一次只能执行一个任务。事件循环使 JavaScript 能够在执行同步代码的同时，处理异步操作（如定时器、用户交互和网络请求）的回调。<br>\n事件循环的目标是在处理同步代码和异步回调之间保持平衡，确保 JavaScript 代码的执行效率和响应能力。通过这种方式，事件循环允许 JavaScript 在单线程环境中有效地处理并发操作。</p>\n<p><img src="https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/Pasted-image-20221208182251.png" alt=""></p>\n<h4 id="事件轮询机制执行过程">事件轮询机制执行过程<a class="anchor" href="#事件轮询机制执行过程"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<ol>\n<li>首先，JavaScript 引擎执行全局同步代码（例如来自<code>&#x3C;script></code>标签或 Node.js 文件的代码）。</li>\n<li>当遇到异步操作，它们的回调函数会被放入相应的任务队列中（<strong>微任务队列</strong>或<strong>宏任务队列</strong>）。</li>\n<li>全局同步代码执行完成后，事件循环开始检查 <strong>微任务队列</strong>。如果队列中有任务，事件循环将依次执行它们，直到队列为空。</li>\n<li>接下来，事件循环检查 <strong>宏任务队列</strong>，并执行其中第一个宏任务，如果执行过程中，遇到微任务，依次加入微任务队列，然后<strong>返回到微任务队列</strong>，执行所有微任务。</li>\n<li>事件循环在微任务队列和宏任务队列之间循环，依次执行队列中的任务。当两个队列都为空时，事件循环将等待新的任务（如用户交互或网络请求回调）。</li>\n<li>当新任务出现时，事件循环将其添加到相应的队列中，并继续循环执行任务。</li>\n</ol>\n<h3 id="宏任务macrotasks">宏任务（Macrotasks）<a class="anchor" href="#宏任务macrotasks"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<blockquote>\n<p>macrotask 本质上是浏览器多个线程之间通信的一个消息队列<br>\n在 chrome 里，每个页面都对应一个进程，该进程又有多个线程，比如 js 线程、渲染线程、io 线程、网络线程、定时器线程等，这些线程之间的通信，是通过向对方的任务队列中添加一个任务（PostTask）来实现的。</p>\n</blockquote>\n<p>宏任务是一个个执行，执行一个宏任务，然后就把在任务队列中的所有微任务都执行完，再执行下一个宏任务，再执行所有微任务，依次类推<br>\n主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务</p>\n<ul>\n<li><code>script</code> 全部代码（注意同步代码也属于宏任务）</li>\n<li><code>setTimeout</code>、<code>setInterval</code>、<code>setImmediate</code> 等</li>\n</ul>\n<h3 id="微任务microtasks">微任务（Microtasks）<a class="anchor" href="#微任务microtasks"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>不进入主线程、而进入 微任务列表 的任务</p>\n<ul>\n<li><code>Promise</code>、<code>MutationObserver</code></li>\n</ul>\n<h3 id="浏览器更新渲染时机">浏览器更新渲染时机<a class="anchor" href="#浏览器更新渲染时机"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<p>1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即 <code>宏任务 → 微任务 → 渲染更新</code>（先宏任务 再微任务，然后再渲染更新）<br>\n2）宏任务队列中，如果有大量任务等待执行时，将 DOM 的变动作为微任务，能更快的将变化呈现给用户，这样就可以在这一次的事件轮询中更新 DOM</p>\n<h3 id="requestanimationframe"><code>requestAnimationFrame</code><a class="anchor" href="#requestanimationframe"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li><a href="https://juejin.cn/post/6991297852462858277?searchId=202402181438115229F57507550A5779CE">【今天你更博学了么】一个神奇的前端动画 API requestAnimationFrame - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7190728064458817591?searchId=202402181438115229F57507550A5779CE">性能优化之通俗易懂学习 requestAnimationFrame 和使用场景举例 - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7274346507037016104?searchId=202402181438115229F57507550A5779CE">另一种渲染大量数据的高效方法：requestAnimationFrame - 掘金</a></li>\n<li><a href="https://juejin.cn/post/7262900590937063482?searchId=202402181438115229F57507550A5779CE">利用 requestAnimationFrame 优化大数据列表渲染 - 掘金</a></li>\n</ul>\n<h3 id="reference">Reference<a class="anchor" href="#reference"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<ul>\n<li>⭐<a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ">What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube</a></li>\n<li>⭐<a href="https://www.youtube.com/watch?v=cCOL7MC4Pl0">Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame, … - YouTube</a><br>\n<a href="https://github.com/frontend9/fe9-library/issues/160">深入浏览器事件循环的本质 · Issue #160 · frontend9/fe9-library · GitHub</a></li>\n<li>[这一次，彻底弄懂 JavaScript 执行机制](<a href="https://juejin.cn/post/6844903512845860872">https://juejin.cn/post/6844903512845860872</a> <a href="https://juejin.cn/post/6844903512845860872">https://juejin.cn/post/6844903512845860872</a>)</li>\n<li>[从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机](<a href="https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5">https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5</a> <a href="https://github.com/aooy/blog/issues/5">https://github.com/aooy/blog/issues/5</a>)</li>\n<li>[【THE LAST TIME】彻底吃透 JavaScript 执行机制](<a href="https://juejin.cn/post/6844903955286196237">https://juejin.cn/post/6844903955286196237</a> <a href="https://juejin.cn/post/6844903955286196237">https://juejin.cn/post/6844903955286196237</a>)</li>\n<li>[一次弄懂 Event Loop（彻底解决此类面试问题）](<a href="https://juejin.cn/post/6844903764202094606">https://juejin.cn/post/6844903764202094606</a> <a href="https://juejin.cn/post/6844903764202094606">https://juejin.cn/post/6844903764202094606</a>)</li>\n<li>[深入理解 JavaScript Event Loop](<a href="https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323">https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323</a> <a href="https://zhuanlan.zhihu.com/p/34229323">https://zhuanlan.zhihu.com/p/34229323</a>)</li>\n<li>[Tasks, microtasks, queues and schedules](<a href="https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F">https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F</a> <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/">https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/</a>)</li>\n<li><a href="https://juejin.cn/post/7020710294083092493">详解宏任务、微任务与事件循环 Event Loop - 掘金</a></li>\n</ul>\n<h3 id="️-interview-exercise">🛠️ Interview Exercise<a class="anchor" href="#️-interview-exercise"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h3>\n<h4 id="event-loop-经典题目判断打印结果">Event Loop 经典题目：判断打印结果<a class="anchor" href="#event-loop-经典题目判断打印结果"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">()</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise0);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise5);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(timer1);</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise2);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise4);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(() </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(timer2);</span></span>\n<span class="line"><span style="color:#79B8FF">\tPromise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise3);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">.</span><span style="color:#B392F0">resolve</span><span style="color:#E1E4E8">().</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise1);</span></span>\n<span class="line"><span style="color:#E1E4E8">});</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(start);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3</span></span>\n<span class="line"></span></code></pre>\n<h4 id="事件轮询执行时机">事件轮询执行时机<a class="anchor" href="#事件轮询执行时机"><span class="anchor-icon" data-pagefind-ignore="">#</span></a></h4>\n<p>async 隐式返回 Promise，会产生一个微任务，await 后面的代码是在微任务时执行</p>\n<pre class="astro-code github-dark" style="background-color:#24292e;color:#e1e4e8; overflow-x: auto;" tabindex="0"><code><span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(script start);</span></span>\n<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> async1</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#F97583">\tawait</span><span style="color:#B392F0"> async2</span><span style="color:#E1E4E8">(); </span><span style="color:#6A737D">// await 隐式返回promise</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(async1 end); </span><span style="color:#6A737D">// 这里的执行时机：在执行微任务时执行</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#F97583">async</span><span style="color:#F97583"> function</span><span style="color:#B392F0"> async2</span><span style="color:#E1E4E8">() {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(async2 end); </span><span style="color:#6A737D">// 这里是同步代码</span></span>\n<span class="line"><span style="color:#E1E4E8">}</span></span>\n<span class="line"><span style="color:#B392F0">async1</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#B392F0">setTimeout</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(setTimeout);</span></span>\n<span class="line"><span style="color:#E1E4E8">}, </span><span style="color:#79B8FF">0</span><span style="color:#E1E4E8">);</span></span>\n<span class="line"><span style="color:#F97583">new</span><span style="color:#79B8FF"> Promise</span><span style="color:#E1E4E8">((</span><span style="color:#FFAB70">resolve</span><span style="color:#E1E4E8">) </span><span style="color:#F97583">=></span><span style="color:#E1E4E8"> {</span></span>\n<span class="line"><span style="color:#E1E4E8">\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(</span><span style="color:#79B8FF">Promise</span><span style="color:#E1E4E8">); </span><span style="color:#6A737D">// 这里是同步代码</span></span>\n<span class="line"><span style="color:#B392F0">\tresolve</span><span style="color:#E1E4E8">();</span></span>\n<span class="line"><span style="color:#E1E4E8">})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise1);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t})</span></span>\n<span class="line"><span style="color:#E1E4E8">\t.</span><span style="color:#B392F0">then</span><span style="color:#E1E4E8">(</span><span style="color:#F97583">function</span><span style="color:#E1E4E8"> () {</span></span>\n<span class="line"><span style="color:#E1E4E8">\t\tconsole.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(promise2);</span></span>\n<span class="line"><span style="color:#E1E4E8">\t});</span></span>\n<span class="line"><span style="color:#E1E4E8">console.</span><span style="color:#B392F0">log</span><span style="color:#E1E4E8">(script end);</span></span>\n<span class="line"></span>\n<span class="line"><span style="color:#6A737D">// 打印结果:  script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout</span></span>\n<span class="line"></span></code></pre>',frontmatter={aliases:["Event Loop-事件循环"],draft:!1,tags:["JavaScript"],comment:null,type:"D",title:"Event Loop-事件循环",DateStarted:"2022-12-08T00:00:00.000Z",DateModified:"2024-04-25T00:00:00.000Z",status:null,difficulty:"Hard",reviewed:3,topic:["Basics","Async"],Datereviewed:"2024-04-25T00:00:00.000Z",category:"Programming","linter-yaml-title-alias":"Event Loop-事件循环",minutes:7,words:1308},file="E:/SynologyDrive/Codespace/blog-site/mynote/my-fuwari-blog/src/content/posts/js/js-internal/event-loop-事件循环.md",url=void 0;function rawContent(){return"\n# Event Loop-事件循环\n### 相关术语\n- call stack > Web APIs > callback queue > 🔁event loop > task in callback queue? push task to the end of stack\n- render queue：重绘\n- 调用栈、堆栈溢出（stack overflow）、回调队列/任务队列（回调函数）、事件循环\n### Event Loop (事件轮询机制)\n事件循环（Event Loop）是 JavaScript 运行时环境中的一个核心概念，它负责协调异步操作和同步代码的执行。JavaScript 是单线程的，这意味着它一次只能执行一个任务。事件循环使 JavaScript 能够在执行同步代码的同时，处理异步操作（如定时器、用户交互和网络请求）的回调。  \n事件循环的目标是在处理同步代码和异步回调之间保持平衡，确保 JavaScript 代码的执行效率和响应能力。通过这种方式，事件循环允许 JavaScript 在单线程环境中有效地处理并发操作。\n\n  ![](https://cdn.jsdelivr.net/gh/jenniferwonder/bimg/programming/Pasted-image-20221208182251.png)\n\n#### 事件轮询机制执行过程\n1. 首先，JavaScript 引擎执行全局同步代码（例如来自`<script>`标签或 Node.js 文件的代码）。\n2. 当遇到异步操作，它们的回调函数会被放入相应的任务队列中（**微任务队列**或**宏任务队列**）。\n3. 全局同步代码执行完成后，事件循环开始检查 **微任务队列**。如果队列中有任务，事件循环将依次执行它们，直到队列为空。\n4. 接下来，事件循环检查 **宏任务队列**，并执行其中第一个宏任务，如果执行过程中，遇到微任务，依次加入微任务队列，然后**返回到微任务队列**，执行所有微任务。\n5. 事件循环在微任务队列和宏任务队列之间循环，依次执行队列中的任务。当两个队列都为空时，事件循环将等待新的任务（如用户交互或网络请求回调）。\n6. 当新任务出现时，事件循环将其添加到相应的队列中，并继续循环执行任务。\n\n### 宏任务（Macrotasks）\n> macrotask 本质上是浏览器多个线程之间通信的一个消息队列  \n> 在 chrome 里，每个页面都对应一个进程，该进程又有多个线程，比如 js 线程、渲染线程、io 线程、网络线程、定时器线程等，这些线程之间的通信，是通过向对方的任务队列中添加一个任务（PostTask）来实现的。\n\n宏任务是一个个执行，执行一个宏任务，然后就把在任务队列中的所有微任务都执行完，再执行下一个宏任务，再执行所有微任务，依次类推  \n主线程上排队执行的任务，只有前一个任务执行完毕，才能执行下一个任务\n- `script` 全部代码（注意同步代码也属于宏任务）\n- `setTimeout`、`setInterval`、`setImmediate` 等\n### 微任务（Microtasks）\n不进入主线程、而进入 微任务列表 的任务\n- `Promise`、`MutationObserver`\n\n### 浏览器更新渲染时机\n1） 浏览器更新渲染会在 event loop 中的 宏任务 和 微任务 完成后进行，即 `宏任务 → 微任务 → 渲染更新`（先宏任务 再微任务，然后再渲染更新）  \n2）宏任务队列中，如果有大量任务等待执行时，将 DOM 的变动作为微任务，能更快的将变化呈现给用户，这样就可以在这一次的事件轮询中更新 DOM\n\n### `requestAnimationFrame`\n- [【今天你更博学了么】一个神奇的前端动画 API requestAnimationFrame - 掘金](https://juejin.cn/post/6991297852462858277?searchId=202402181438115229F57507550A5779CE)\n- [性能优化之通俗易懂学习 requestAnimationFrame 和使用场景举例 - 掘金](https://juejin.cn/post/7190728064458817591?searchId=202402181438115229F57507550A5779CE)\n- [另一种渲染大量数据的高效方法：requestAnimationFrame - 掘金](https://juejin.cn/post/7274346507037016104?searchId=202402181438115229F57507550A5779CE)\n- [利用 requestAnimationFrame 优化大数据列表渲染 - 掘金](https://juejin.cn/post/7262900590937063482?searchId=202402181438115229F57507550A5779CE)\n\n### Reference\n- ⭐[What the heck is the event loop anyway? | Philip Roberts | JSConf EU - YouTube](https://www.youtube.com/watch?v=8aGhZQkoFbQ)\n- ⭐[Jake Archibald on the web browser event loop, setTimeout, micro tasks, requestAnimationFrame, ... - YouTube](https://www.youtube.com/watch?v=cCOL7MC4Pl0)  \n[深入浏览器事件循环的本质 · Issue #160 · frontend9/fe9-library · GitHub](https://github.com/frontend9/fe9-library/issues/160)\n- [这一次，彻底弄懂 JavaScript 执行机制](https://juejin.cn/post/6844903512845860872 https://juejin.cn/post/6844903512845860872)\n- [从 event loop 规范探究 javaScript 异步及浏览器更新渲染时机](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Faooy%2Fblog%2Fissues%2F5 https://github.com/aooy/blog/issues/5)\n- [【THE LAST TIME】彻底吃透 JavaScript 执行机制](https://juejin.cn/post/6844903955286196237 https://juejin.cn/post/6844903955286196237)\n- [一次弄懂 Event Loop（彻底解决此类面试问题）](https://juejin.cn/post/6844903764202094606 https://juejin.cn/post/6844903764202094606)\n- [深入理解 JavaScript Event Loop](https://link.juejin.cn?target=https%3A%2F%2Fzhuanlan.zhihu.com%2Fp%2F34229323 https://zhuanlan.zhihu.com/p/34229323)\n- [Tasks, microtasks, queues and schedules](https://link.juejin.cn/?target=https%3A%2F%2Fjakearchibald.com%2F2015%2Ftasks-microtasks-queues-and-schedules%2F https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)\n- [详解宏任务、微任务与事件循环 Event Loop - 掘金](https://juejin.cn/post/7020710294083092493)\n### 🛠️ Interview Exercise\n#### Event Loop 经典题目：判断打印结果\n\n```javascript\nPromise.resolve()\n\t.then(function () {\n\t\tconsole.log(promise0);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise5);\n\t});\nsetTimeout(() => {\n\tconsole.log(timer1);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise2);\n\t});\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise4);\n\t});\n}, 0);\nsetTimeout(() => {\n\tconsole.log(timer2);\n\tPromise.resolve().then(function () {\n\t\tconsole.log(promise3);\n\t});\n}, 0);\nPromise.resolve().then(function () {\n\tconsole.log(promise1);\n});\nconsole.log(start);\n\n// 打印结果： start promise0 promise1 promise5 timer1 promise2 promise4 timer2 promise3\n```\n\n#### 事件轮询执行时机\n\nasync 隐式返回 Promise，会产生一个微任务，await 后面的代码是在微任务时执行\n\n```javascript\nconsole.log(script start);\nasync function async1() {\n\tawait async2(); // await 隐式返回promise\n\tconsole.log(async1 end); // 这里的执行时机：在执行微任务时执行\n}\nasync function async2() {\n\tconsole.log(async2 end); // 这里是同步代码\n}\nasync1();\nsetTimeout(function () {\n\tconsole.log(setTimeout);\n}, 0);\nnew Promise((resolve) => {\n\tconsole.log(Promise); // 这里是同步代码\n\tresolve();\n})\n\t.then(function () {\n\t\tconsole.log(promise1);\n\t})\n\t.then(function () {\n\t\tconsole.log(promise2);\n\t});\nconsole.log(script end);\n\n// 打印结果:  script start => async2 end => Promise => script end => async1 end => promise1 => promise2 => setTimeout\n```\n"}function compiledContent(){return html}function getHeadings(){return[{depth:1,slug:"event-loop-事件循环",text:"Event Loop-事件循环#"},{depth:3,slug:"相关术语",text:"相关术语#"},{depth:3,slug:"event-loop-事件轮询机制",text:"Event Loop (事件轮询机制)#"},{depth:4,slug:"事件轮询机制执行过程",text:"事件轮询机制执行过程#"},{depth:3,slug:"宏任务macrotasks",text:"宏任务（Macrotasks）#"},{depth:3,slug:"微任务microtasks",text:"微任务（Microtasks）#"},{depth:3,slug:"浏览器更新渲染时机",text:"浏览器更新渲染时机#"},{depth:3,slug:"requestanimationframe",text:"requestAnimationFrame#"},{depth:3,slug:"reference",text:"Reference#"},{depth:3,slug:"️-interview-exercise",text:"🛠️ Interview Exercise#"},{depth:4,slug:"event-loop-经典题目判断打印结果",text:"Event Loop 经典题目：判断打印结果#"},{depth:4,slug:"事件轮询执行时机",text:"事件轮询执行时机#"}]}const Content=createComponent(((s,n,a)=>{const{layout:e,...o}=frontmatter;return o.file=file,o.url=url,renderTemplate`${maybeRenderHead()}${unescapeHTML(html)}`}));export{Content,compiledContent,Content as default,file,frontmatter,getHeadings,rawContent,url};